<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tsavorite.core</name>
    </assembly>
    <members>
        <member name="T:Tsavorite.core.AllocatorBase`4">
            <summary>
            Base class for hybrid log memory allocator. Contains utility methods, some of which are not performance-critical so can be virtual.
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.epoch">
            <summary>The epoch we are operating with</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.ownedEpoch">
            <summary>Whether we own (and thus must dispose) <see cref="F:Tsavorite.core.AllocatorBase`4.epoch"/></summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4._storeFunctions">
            <summary>The store functions for this instance of TsavoriteKV</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4._wrapper">
            <summary>The fully-derived allocator struct wrapper (so calls on it are inlined rather than virtual) for this log.</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.BufferSize">
            <summary>Buffer size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.LogPageSizeBits">
            <summary>Log page size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.PageSize">
            <summary>Page size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.PageSizeMask">
            <summary>Page size mask</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.BufferSizeMask">
            <summary>Buffer size mask</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.AlignedPageSizeBytes">
            <summary>Aligned page size in bytes</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.LogTotalSizeBits">
            <summary>Total hybrid log size (bits)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.LogTotalSizeBytes">
            <summary>Total hybrid log size (bytes)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.LogSegmentSizeBits">
            <summary>Segment size in bits</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.SegmentSize">
            <summary>Segment size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.SegmentBufferSize">
            <summary>Segment buffer size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.emptyPageCount">
            <summary>How many pages do we leave empty in the in-memory buffer (between 0 and BufferSize-1)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.minEmptyPageCount">
            <summary>Minimum number of empty pages in circular buffer to be maintained to account for non-power-of-two size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.HeadAddressLagOffset">
            <summary>HeadAddress offset from tail (currently page-aligned)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.LogMutableFraction">
            <summary>Log mutable fraction</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.ReadOnlyAddressLagOffset">
            <summary>ReadOnlyAddress offset from tail (currently page-aligned)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.ReadOnlyAddress">
            <summary>The maximum address of the immutable in-memory log region</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.SafeReadOnlyAddress">
            <summary>Safe read-only address</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.HeadAddress">
            <summary>
            The lowest in-memory address in the log. While we hold the epoch this may be changed by other threads as part of ShiftHeadAddress,
            but as long as an address was >= HeadAddress while we held the epoch, it cannot be actually evicted until we release the epoch.
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.SafeHeadAddress">
            <summary>
            The lowest reliable in-memory address. This is set by OnPagesClosed as the highest address of the range it is starting to close;
            thus it leads <see cref="F:Tsavorite.core.AllocatorBase`4.ClosedUntilAddress"/>. As long as we hold the epoch, records above this address will not be evicted.
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.FlushedUntilAddress">
            <summary>Flushed until address</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.ClosedUntilAddress">
            <summary>
            The highest address that has been closed by <see cref="M:Tsavorite.core.AllocatorBase`4.OnPagesClosed(System.Int64)"/>. It will catch up to <see cref="F:Tsavorite.core.AllocatorBase`4.SafeHeadAddress"/>
            when a region is closed.
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.BeginAddress">
            <summary>The lowest valid address in the log</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.PersistedBeginAddress">
            <summary>The lowest valid address on disk - updated when truncating log</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.OngoingCloseUntilAddress">
            <summary>
            Address until which we are currently closing. Used to coordinate linear closing of pages.
            Only one thread will be closing pages at a time.
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ToString">
            <inheritdoc/>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.device">
            <summary>Log Device</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.sectorSize">
            <summary>Sector size</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.TailPageOffset">
            <summary>Global address of the current tail (next element to be allocated from the circular buffer) </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.disposed">
            <summary>Whether log is disposed</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.IsNullDevice">
            <summary>Whether device is a null device</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.bufferPool">
            <summary>Buffer pool</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.IsReadCache">
            <summary>This hlog is an instance of a Read cache</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.EvictCallback">
            <summary>Read cache eviction callback</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.FlushCallback">
            <summary>Flush callback</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.PreallocateLog">
            <summary>Whether to preallocate log on initialization</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.errorList">
            <summary>Error handling</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.OnReadOnlyObserver">
            <summary>Observer for records entering read-only region</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.OnEvictionObserver">
            <summary>Observer for records getting evicted from memory (page closed)</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.OnDeserializationObserver">
            <summary>Observer for records brought into memory by deserializing pages</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.FlushEvent">
            <summary>The "event" to be waited on for flush completion by the initiator of an operation</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.IsSizeBeyondLimit">
            <summary>If set, this is a function to call to determine whether the object size tracker reports maximum memory size has been exceeded.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Initialize">
            <summary>Initialize fully derived allocator</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.WriteAsyncToDevice``1(System.Int64,System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.PageAsyncFlushResult{``0},Tsavorite.core.IDevice,Tsavorite.core.IDevice,System.Int64[],System.Int64)">
            <summary>Write async to device</summary>
            <typeparam name="TContext"></typeparam>
            <param name="startPage"></param>
            <param name="flushPage"></param>
            <param name="pageSize"></param>
            <param name="callback"></param>
            <param name="result"></param>
            <param name="device"></param>
            <param name="objectLogDevice"></param>
            <param name="localSegmentOffsets"></param>
            <param name="fuzzyStartLogicalAddress">Start address of fuzzy region, which contains old and new version records (we use this to selectively flush only old-version records during snapshot checkpoint)</param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncReadRecordObjectsToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.SectorAlignedMemory)">
            <summary>Read objects to memory (async)</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ReadAsync``1(System.UInt64,System.Int32,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.PageAsyncReadResult{``0},Tsavorite.core.IDevice,Tsavorite.core.IDevice)">
            <summary>Read page from device (async)</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.WriteAsync``1(System.Int64,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.PageAsyncFlushResult{``0})">
            <summary>Write page to device (async)</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushDeltaToDevice(System.Int64,System.Int64,System.Int64,System.Int64,Tsavorite.core.DeltaLog,System.Threading.SemaphoreSlim@,System.Int32)">
            <summary>Flush checkpoint Delta to the Device</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.DeleteFromMemory">
            <summary>Delete in-memory portion of the log</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Reset">
            <summary>Reset the hybrid log. WARNING: assumes that threads have drained out at this point.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.TruncateUntilAddress(System.Int64)">
            <summary>Wraps <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddress(System.Int64)"/> when an allocator potentially has to interact with multiple devices</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.TruncateUntilAddressBlocking(System.Int64)">
            <summary>Wraps <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddress(System.Int64)"/> when an allocator potentially has to interact with multiple devices</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.RemoveSegment(System.Int32)">
            <summary>Remove disk segment</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Dispose">
            <summary>Dispose allocator</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.#ctor(Tsavorite.core.LogSettings,`2,System.Func{System.Object,`3},System.Action{System.Int64,System.Int64},Tsavorite.core.LightEpoch,System.Action{Tsavorite.core.CommitInfo},Microsoft.Extensions.Logging.ILogger)">
            <summary>Instantiate base allocator implementation</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Initialize(System.Int64)">
            <summary>Initialize allocator</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.AllocatedPageCount">
            <summary>Number of pages in circular buffer that are allocated</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.MaxAllocatedPageCount">
            <summary>Max number of pages that have been allocated at any point in time</summary>
        </member>
        <member name="P:Tsavorite.core.AllocatorBase`4.MaxEmptyPageCount">
            <summary>Maximum possible number of empty pages in circular buffer</summary>
        </member>
        <member name="P:Tsavorite.core.AllocatorBase`4.MinEmptyPageCount">
            <summary>Minimum number of empty pages in circular buffer to be maintained to account for non-power-of-two size</summary>
        </member>
        <member name="P:Tsavorite.core.AllocatorBase`4.MaxMemorySizeBytes">
            <summary>Maximum memory size in bytes</summary>
        </member>
        <member name="P:Tsavorite.core.AllocatorBase`4.EmptyPageCount">
            <summary>How many pages do we leave empty in the in-memory buffer (between 0 and BufferSize-1)</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.IncrementAllocatedPageCount">
            <summary>Increments AllocatedPageCount. Updates MaxAllocatedPageCount if a higher number of pages have been allocated.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetSegmentSize">
            <summary>Segment size</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetTailAddress">
            <summary>Get tail address</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetPage(System.Int64)">
            <summary>Get page index from <paramref name="logicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetPageIndexForPage(System.Int64)">
            <summary>Get page index for page</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetPageIndexForAddress(System.Int64)">
            <summary>Get page index for address</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetCapacityNumPages">
            <summary>Get capacity (number of pages)</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetPageSize">
            <summary>Get page size</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetOffsetInPage(System.Int64)">
            <summary>Get offset in page</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.GetDeviceSectorSize">
            <summary>Get sector size for main hlog device</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ThrowTsavoriteException(System.String)">
            <summary>
            Throw Tsavorite exception with message. We use a method wrapper so that
            the caller method can execute inlined.
            </summary>
            <param name="message"></param>
            <exception cref="T:Tsavorite.core.TsavoriteException"></exception>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.NeedToShiftAddress(System.Int64,Tsavorite.core.PageOffset,System.Int32)">
            <summary>
            Whether we need to shift addresses when turning the page.
            </summary>
            <param name="pageIndex">The page we are turning to</param>
            <param name="localTailPageOffset">Local copy of PageOffset (includes the addition of numSlots)</param>
            <param name="numSlots">Size of new allocation</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.IssueShiftAddress(System.Int64)">
            <summary>
            Shift log addresses when turning the page.
            </summary>
            <param name="pageIndex">The page we are turning to</param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.TryAllocate(System.Int32)">
            <summary>Try allocate, no thread spinning allowed</summary>
            <param name="numSlots">Number of slots to allocate</param>
            <returns>The allocated logical address, or 0 in case of inability to allocate</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.TryAllocateRetryNow(System.Int32)">
            <summary>Try allocate, spin for RETRY_NOW (logicalAddress is less than 0) case</summary>
            <param name="numSlots">Number of slots to allocate</param>
            <returns>The allocated logical address, or 0 in case of inability to allocate</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.CannotAllocate(System.Int32)">
            <summary>
            If the page we are trying to allocate is past the last page with an unclosed address region, 
            then we can retry immediately because this is called after NeedToWait, so we know we've 
            completed the wait on flushEvent for the necessary pages to be flushed, and are waiting for
            OnPagesClosed to be completed.
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.NeedToWait(System.Int32)">
            <summary>
            If the page we are trying to allocate is past the last page with an unflushed address region, 
            we have to wait for the flushEvent.
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ShiftReadOnlyToTail(System.Int64@,System.Threading.SemaphoreSlim@)">
            <summary>Used by applications to make the current state of the database immutable quickly</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ShiftReadOnlyAddress(System.Int64,System.Boolean)">
            <summary>Used by applications to move read-only forward</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ShiftBeginAddress(System.Int64,System.Boolean,System.Boolean)">
            <summary>Shift begin address</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.EvictPage(System.Int64)">
            <summary>Invokes eviction observer if set and then frees the page.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.OnPagesMarkedReadOnly(System.Int64,System.Boolean)">
            <summary>
            Seal: make sure there are no longer any threads writing to the page
            Flush: send page to secondary store
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.OnPagesClosed(System.Int64)">
            <summary>Action to be performed for when all threads have agreed that a page range is closed.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.PageAlignedShiftReadOnlyAddress(System.Int64)">
            <summary>
            Called every time a new tail page is allocated. Here the read-only is shifted only to page boundaries 
            unlike ShiftReadOnlyToTail where shifting can happen to any fine-grained address.
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.PageAlignedShiftHeadAddress(System.Int64)">
            <summary>
            Called whenever a new tail page is allocated or when the user is checking for a failed memory allocation
            Tries to shift head address based on the head offset lag size.
            </summary>
            <param name="currentTailAddress"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ShiftHeadAddress(System.Int64)">
            <summary>
            Tries to shift head address to specified value
            </summary>
            <param name="desiredHeadAddress"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ShiftFlushedUntilAddress">
            <summary>
            Every async flush callback tries to update the flushed until address to the latest value possible
            Is there a better way to do this with enabling fine-grained addresses (not necessarily at page boundaries)?
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.notifyFlushedUntilAddress">
            <summary>Address for notification of flushed-until</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorBase`4.notifyFlushedUntilAddressSemaphore">
            <summary>Semaphore for notification of flushed-until</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.RecoveryReset(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>Reset for recovery</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncReadRecordToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>Invoked by users to obtain a record from disk. It uses sector aligned memory to read the record efficiently into memory.</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncReadRecordToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.SimpleReadContext@)">
            <summary>
            Read record to memory - simple read context version
            </summary>
            <param name="fromLogical"></param>
            <param name="numBytes"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncReadPagesFromDevice``1(System.Int64,System.Int32,System.Int64,Tsavorite.core.DeviceIOCompletionCallback,``0,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice)">
            <summary>Read pages from specified device</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncReadPagesFromDevice``1(System.Int64,System.Int32,System.Int64,Tsavorite.core.DeviceIOCompletionCallback,``0,System.Threading.CountdownEvent@,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice)">
            <summary>Read pages from specified device</summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushPages(System.Int64,System.Int64,System.Boolean)">
            <summary>
            Flush page range to disk
            Called when all threads have agreed that a page range is sealed.
            </summary>
            <param name="fromAddress"></param>
            <param name="untilAddress"></param>
            <param name="noFlush"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushPages``1(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,``0)">
            <summary>
            Flush pages asynchronously
            </summary>
            <typeparam name="TContext"></typeparam>
            <param name="flushPageStart"></param>
            <param name="numPages"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushPagesToDevice(System.Int64,System.Int64,System.Int64,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice,System.Threading.SemaphoreSlim@,System.Int32)">
            <summary>
            Flush pages from startPage (inclusive) to endPage (exclusive)
            to specified log device and obj device
            </summary>
            <param name="startPage"></param>
            <param name="endPage"></param>
            <param name="endLogicalAddress"></param>
            <param name="fuzzyStartLogicalAddress"></param>
            <param name="device"></param>
            <param name="objectLogDevice"></param>
            <param name="completedSemaphore"></param>
            <param name="throttleCheckpointFlushDelayMs"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushPageCallback(System.UInt32,System.UInt32,System.Object)">
            <summary>
            IOCompletion callback for page flush
            </summary>
            <param name="errorCode"></param>
            <param name="numBytes"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.AsyncFlushPageToDeviceCallback(System.UInt32,System.UInt32,System.Object)">
            <summary>
            IOCompletion callback for page flush
            </summary>
            <param name="errorCode"></param>
            <param name="numBytes"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Scan(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean)">
            <summary>
            Pull-based scan interface for HLOG; user calls GetNext() which advances through the address range.
            </summary>
            <returns>Pull Scan iterator instance</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.Scan``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},System.Int64,System.Int64,``0@,Tsavorite.core.ScanBufferingMode)">
            <summary>
            Push-based scan interface for HLOG, called from LogAccessor; scan the log given address range, calling <paramref name="scanFunctions"/> for each record.
            </summary>
            <returns>True if Scan completed; false if Scan ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.IterateKeyVersions``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},`0@,``0@)">
            <summary>
            Push-based iteration of key versions, calling <paramref name="scanFunctions"/> for each record.
            </summary>
            <returns>True if Scan completed; false if Scan ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.IterateKeyVersions``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},`0@,System.Int64,``0@)">
            <summary>
            Push-based iteration of key versions, calling <paramref name="scanFunctions"/> for each record.
            </summary>
            <returns>True if Scan completed; false if Scan ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.PushScanImpl``2(System.Int64,System.Int64,``0@,``1)">
            <summary>
            Implementation for push-scanning Tsavorite log
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.IterateKeyVersionsImpl``2(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},`0@,System.Int64,``0@,``1)">
            <summary>
            Implementation for push-iterating key versions
            </summary>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.ScanCursor``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},Tsavorite.core.ScanCursorState{`0,`1},System.Int64@,System.Int64,``0,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Push-based scan interface for HLOG with cursor, called from LogAccessor; scan the log from <paramref name="cursor"/> (which must be a valid address) and push up to <paramref name="count"/> records
            to the caller via <paramref name="scanFunctions"/> for each Key that is not found at a higher address.
            </summary>
            <returns>True if Scan completed and pushed <paramref name="count"/> records; false if Scan ended early due to finding less than <paramref name="count"/> records
            or one of the TScanIterator reader functions returning false</returns>
            <remarks>Currently we load an entire page, which while inefficient in performance, allows us to make the cursor safe (by ensuring we align to a valid record) if it is not
            the last one returned. We could optimize this to load only the subset of a page that is pointed to by the cursor and do GetRequiredRecordSize/RetrievedFullRecord as in
            AsyncGetFromDiskCallback. However, this would not validate the cursor and would therefore require maintaining a cursor history.</remarks>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.MemoryPageScan(System.Int64,System.Int64,System.IObserver{Tsavorite.core.ITsavoriteScanIterator{`0,`1}})">
            <summary>
            Scan page guaranteed to be in memory
            </summary>
            <param name="beginAddress">Begin address</param>
            <param name="endAddress">End address</param>
            <param name="observer">Observer of scan</param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.RestoreHybridLog(System.Int64,System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Restore log
            </summary>
            <param name="beginAddress"></param>
            <param name="headAddress"></param>
            <param name="fromAddress"></param>
            <param name="untilAddress"></param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
        </member>
        <member name="M:Tsavorite.core.AllocatorBase`4.RestoreHybridLogAsync(System.Int64,System.Int64,System.Int64,System.Int64,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Restore log
            </summary>
            <param name="beginAddress"></param>
            <param name="headAddress"></param>
            <param name="fromAddress"></param>
            <param name="untilAddress"></param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="T:Tsavorite.core.AllocatorSettings">
            <summary>
            This class is created by <see cref="T:Tsavorite.core.TsavoriteKV`4"/> to pass parameters to the allocator factory function.
            </summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorSettings.LogSettings">
            <summary>The Log settings, usually from <see cref="T:Tsavorite.core.KVSettings`2"/></summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorSettings.epoch">
            <summary>The epoch created for the <see cref="T:Tsavorite.core.TsavoriteKV`4"/></summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorSettings.logger">
            <summary>The logger to use, either from <see cref="T:Tsavorite.core.KVSettings`2"/> or created by <see cref="T:Tsavorite.core.TsavoriteKV`4"/></summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorSettings.evictCallback">
            <summary>The action to call on page eviction; used only for readcache</summary>
        </member>
        <member name="F:Tsavorite.core.AllocatorSettings.flushCallback">
            <summary>The action to execute on flush completion; used only for <see cref="T:Tsavorite.core.TsavoriteLog"/></summary>
        </member>
        <member name="T:Tsavorite.core.AsyncIOContext`2">
            <summary>
            Async IO context for PMM
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.id">
            <summary>
            Id
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.request_key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.key">
            <summary>
            Retrieved key
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.value">
            <summary>
            Retrieved value
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.logicalAddress">
            <summary>
            Logical address
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.minAddress">
            <summary>
            Minimum Logical address to resolve Key in
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.record">
            <summary>
            Record buffer
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.objBuffer">
            <summary>
            Object buffer
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.callbackQueue">
            <summary>
            Callback queue
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.asyncOperation">
            <summary>
            Async Operation ValueTask backer
            </summary>
        </member>
        <member name="F:Tsavorite.core.AsyncIOContext`2.completionEvent">
            <summary>
            Synchronous completion event
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncIOContext`2.IsDefault">
            <summary>
            Indicates whether this is a default instance with no pending operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncIOContext`2.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncIOContextCompletionEvent`2.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.AtomicOwner.Enqueue">
            <summary>
            Enqueue token
            true: success + caller is new owner
            false: success + someone else is owner
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AtomicOwner.Dequeue">
            <summary>
            Dequeue token (caller is/remains owner)
            true: successful dequeue
            false: failed dequeue
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AtomicOwner.Release">
            <summary>
            Release queue ownership
            true: successful release
            false: failed release
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.BlittableAllocator`3">
            <summary>
            Struct wrapper (for inlining) around the fixed-length Blittable allocator.
            </summary>
        </member>
        <member name="F:Tsavorite.core.BlittableAllocator`3._this">
            <summary>The wrapped class containing all data and most actual functionality. This must be the ONLY field in this structure so its size is sizeof(IntPtr).</summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetBase``1">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.BlittableAllocator`3.IsFixedLength">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.BlittableAllocator`3.HasObjectLog">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetStartLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetFirstValidLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetPhysicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetInfo(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetInfoFromBytePointer(System.Byte*)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetKey(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetValue(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetAndInitializeValue(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetRecordSize(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetRMWCopyDestinationRecordSize``2(`0@,``0@,`1@,Tsavorite.core.RecordInfo@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetTombstoneRecordSize(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetRequiredRecordSize(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetAverageRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetFixedRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetRMWInitialRecordSize``2(`0@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetUpsertRecordSize``2(`0@,`1@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetRecordSize(`0@,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetValueLength(`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.RetrievedFullRecord(System.Byte*,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.AllocatePage(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.IsAllocated(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.PopulatePage(System.Byte*,System.Int32,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.MarkPage(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.MarkPageAtomic(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.ClearPage(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.FreePage(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetContextRecordKey(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetContextRecordValue(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetKeyContainer(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetValueContainer(`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.GetSegmentOffsets">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.BlittableAllocator`3.OverflowPageCount">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocator`3.SerializeKey(`0@,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.Dispose">
            <summary>
            Dispose memory allocator
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.AllocatePage(System.Int32)">
            <summary>
            Allocate memory page, pinned in memory, and in sector aligned form, if possible
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.GetStartLogicalAddress(System.Int64)">
            <summary>
            Get start logical address
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.GetFirstValidLogicalAddress(System.Int64)">
            <summary>
            Get first valid logical address
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.DeleteFromMemory">
            <summary>
            Delete in-memory portion of the log
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.AsyncReadRecordObjectsToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.SectorAlignedMemory)">
            <summary>
            Invoked by users to obtain a record from disk. It uses sector aligned memory to read 
            the record efficiently into memory.
            </summary>
            <param name="fromLogical"></param>
            <param name="numBytes"></param>
            <param name="callback"></param>
            <param name="context"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.Scan(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean)">
            <summary>
            Iterator interface for pull-scanning Tsavorite log
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.Scan``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},System.Int64,System.Int64,``0@,Tsavorite.core.ScanBufferingMode)">
            <summary>
            Implementation for push-scanning Tsavorite log, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.ScanCursor``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},Tsavorite.core.ScanCursorState{`0,`1},System.Int64@,System.Int64,``0,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Implementation for push-scanning Tsavorite log with a cursor, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.IterateKeyVersions``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},`0@,System.Int64,``0@)">
            <summary>
            Implementation for push-iterating key versions, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.MemoryPageScan(System.Int64,System.Int64,System.IObserver{Tsavorite.core.ITsavoriteScanIterator{`0,`1}})">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.BlittableAllocatorImpl`3.AsyncReadPagesFromDeviceToFrame``1(System.Int64,System.Int32,System.Int64,Tsavorite.core.DeviceIOCompletionCallback,``0,Tsavorite.core.BlittableFrame,System.Threading.CountdownEvent@,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice,System.Threading.CancellationTokenSource)">
            <summary>
            Read pages from specified device
            </summary>
        </member>
        <member name="T:Tsavorite.core.BlittableFrame">
            <summary>
            A frame is an in-memory circular buffer of log pages
            </summary>
        </member>
        <member name="T:Tsavorite.core.BlittableScanIterator`3">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.#ctor(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},Tsavorite.core.BlittableAllocatorImpl{`0,`1,`2},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean,Tsavorite.core.LightEpoch,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor for use with head-to-tail scan
            </summary>
            <param name="store"></param>
            <param name="hlog">The fully derived log implementation</param>
            <param name="beginAddress"></param>
            <param name="endAddress"></param>
            <param name="scanBufferingMode"></param>
            <param name="includeClosedRecords"></param>
            <param name="epoch">Epoch to use for protection; may be null if <paramref name="forceInMemory"/> is true.</param>
            <param name="forceInMemory">Provided address range is known by caller to be in memory, even if less than HeadAddress</param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.#ctor(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.BlittableAllocator{`0,`1,`2}},Tsavorite.core.BlittableAllocatorImpl{`0,`1,`2},System.Int64,Tsavorite.core.LightEpoch,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor for use with tail-to-head push iteration of the passed key's record versions
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.GetKey">
            <summary>
            Get a reference to the current key
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.GetValue">
            <summary>
            Get a reference to the current value
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.SnapCursorToLogicalAddress(System.Int64@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.GetNext(Tsavorite.core.RecordInfo@)">
            <summary>
            Get next record in iterator
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.Tsavorite#core#IPushScanIterator{TKey}#BeginGetPrevInMemory(`0@,Tsavorite.core.RecordInfo@,System.Boolean@)">
            <summary>
            Get previous record and keep the epoch held while we call the user's scan functions
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.GetNext(Tsavorite.core.RecordInfo@,`0@,`1@)">
            <summary>
            Get next record in iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.BlittableScanIterator`3.Dispose">
            <summary>
            Dispose iterator
            </summary>
        </member>
        <member name="T:Tsavorite.core.GenericAllocator`3">
            <summary>
            Struct wrapper (for inlining) around the fixed-length Blittable allocator.
            </summary>
        </member>
        <member name="F:Tsavorite.core.GenericAllocator`3._this">
            <summary>The wrapped class containing all data and most actual functionality. This must be the ONLY field in this structure so its size is sizeof(IntPtr).</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetBase``1">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.GenericAllocator`3.IsFixedLength">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.GenericAllocator`3.HasObjectLog">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetStartLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetFirstValidLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetPhysicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetInfo(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetInfoFromBytePointer(System.Byte*)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetKey(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetValue(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetAndInitializeValue(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetRecordSize(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetRMWCopyDestinationRecordSize``2(`0@,``0@,`1@,Tsavorite.core.RecordInfo@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetTombstoneRecordSize(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetRequiredRecordSize(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetAverageRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetFixedRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetRMWInitialRecordSize``2(`0@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetUpsertRecordSize``2(`0@,`1@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetRecordSize(`0@,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetValueLength(`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.RetrievedFullRecord(System.Byte*,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.AllocatePage(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.IsAllocated(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.PopulatePage(System.Byte*,System.Int32,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.MarkPage(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.MarkPageAtomic(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.ClearPage(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.FreePage(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetContextRecordKey(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetContextRecordValue(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetKeyContainer(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetValueContainer(`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.GetSegmentOffsets">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.GenericAllocator`3.OverflowPageCount">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocator`3.SerializeKey(`0@,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.GetStartLogicalAddress(System.Int64)">
            <summary>Get start logical address</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.GetFirstValidLogicalAddress(System.Int64)">
            <summary>Get first valid logical address</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.Dispose">
            <summary>
            Dispose memory allocator
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.DeleteFromMemory">
            <summary>Delete in-memory portion of the log</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.AllocatePage(System.Int32)">
            <summary>Allocate memory page, pinned in memory, and in sector aligned form, if possible</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.AsyncFlushPartialObjectLogCallback``1(System.UInt32,System.UInt32,System.Object)">
            <summary>
            IOCompletion callback for page flush
            </summary>
            <param name="errorCode"></param>
            <param name="numBytes"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.AsyncReadRecordObjectsToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.SectorAlignedMemory)">
            <summary>
            Invoked by users to obtain a record from disk. It uses sector aligned memory to read 
            the record efficiently into memory.
            </summary>
            <param name="fromLogical"></param>
            <param name="numBytes"></param>
            <param name="callback"></param>
            <param name="context"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.AsyncReadPagesFromDeviceToFrame``1(System.Int64,System.Int32,System.Int64,Tsavorite.core.DeviceIOCompletionCallback,``0,Tsavorite.core.GenericFrame{`0,`1},System.Threading.CountdownEvent@,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice)">
            <summary>
            Read pages from specified device
            </summary>
            <typeparam name="TContext"></typeparam>
            <param name="readPageStart"></param>
            <param name="numPages"></param>
            <param name="untilAddress"></param>
            <param name="callback"></param>
            <param name="context"></param>
            <param name="frame"></param>
            <param name="completed"></param>
            <param name="devicePageOffset"></param>
            <param name="device"></param>
            <param name="objectLogDevice"></param>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.Deserialize(System.Byte*,System.Int64,System.Int64,Tsavorite.core.AllocatorRecord{`0,`1}[],System.IO.Stream,System.Boolean)">
            <summary>
            Deseialize part of page from stream
            </summary>
            <param name="raw"></param>
            <param name="ptr">From pointer</param>
            <param name="untilptr">Until pointer</param>
            <param name="src"></param>
            <param name="stream">Stream</param>
            <param name="doNotObserve">Whenther we lets observers see this deserialization</param>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.GetObjectInfo(System.Byte*,System.Int64@,System.Int64,System.Int32,System.Int64@,System.Int64@)">
            <summary>
            Get location and range of object log addresses for specified log page
            </summary>
            <param name="raw"></param>
            <param name="ptr"></param>
            <param name="untilptr"></param>
            <param name="objectBlockSize"></param>
            <param name="startptr"></param>
            <param name="size"></param>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.RetrievedFullRecord(System.Byte*,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>Retrieve objects from object log</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.KeyHasObjects">
            <summary>Whether KVS has keys to serialize/deserialize</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.ValueHasObjects">
            <summary>Whether KVS has values to serialize/deserialize</summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.Scan(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean)">
            <summary>
            Iterator interface for scanning Tsavorite log
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.Scan``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},System.Int64,System.Int64,``0@,Tsavorite.core.ScanBufferingMode)">
            <summary>
            Implementation for push-scanning Tsavorite log, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.ScanCursor``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},Tsavorite.core.ScanCursorState{`0,`1},System.Int64@,System.Int64,``0,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Implementation for push-scanning Tsavorite log with a cursor, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.IterateKeyVersions``1(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},`0@,System.Int64,``0@)">
            <summary>
            Implementation for push-iterating key versions, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.EvictPage(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.GenericAllocatorImpl`3.MemoryPageScan(System.Int64,System.Int64,System.IObserver{Tsavorite.core.ITsavoriteScanIterator{`0,`1}})">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.GenericFrame`2">
            <summary>
            A frame is an in-memory circular buffer of log pages
            </summary>
        </member>
        <member name="T:Tsavorite.core.GenericScanIterator`3">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.#ctor(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},Tsavorite.core.GenericAllocatorImpl{`0,`1,`2},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean,Tsavorite.core.LightEpoch,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.#ctor(Tsavorite.core.TsavoriteKV{`0,`1,`2,Tsavorite.core.GenericAllocator{`0,`1,`2}},Tsavorite.core.GenericAllocatorImpl{`0,`1,`2},System.Int64,Tsavorite.core.LightEpoch,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor for use with tail-to-head push iteration of the passed key's record versions
            </summary>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.GetKey">
            <summary>
            Gets reference to current key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.GetValue">
            <summary>
            Gets reference to current value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.SnapCursorToLogicalAddress(System.Int64@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.GetNext(Tsavorite.core.RecordInfo@)">
            <summary>
            Get next record in iterator
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.Tsavorite#core#IPushScanIterator{TKey}#BeginGetPrevInMemory(`0@,Tsavorite.core.RecordInfo@,System.Boolean@)">
            <summary>
            Get previous record and keep the epoch held while we call the user's scan functions
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.GetNext(Tsavorite.core.RecordInfo@,`0@,`1@)">
            <summary>
            Get next record using iterator
            </summary>
            <param name="recordInfo"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.GenericScanIterator`3.Dispose">
            <summary>
            Dispose iterator
            </summary>
        </member>
        <member name="T:Tsavorite.core.IAllocator`3">
            <summary>
            Interface for hybrid log memory allocator struct wrapper for inlining. This contains the performance-critical methods that must be inlined;
            abstract/virtual methods may be called via <see cref="T:Tsavorite.core.AllocatorBase`4"/>.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetBase``1">
            <summary>The base class instance of the allocator implementation</summary>
        </member>
        <member name="P:Tsavorite.core.IAllocator`3.IsFixedLength">
            <summary>Whether this allocator uses fixed-length records</summary>
        </member>
        <member name="P:Tsavorite.core.IAllocator`3.HasObjectLog">
            <summary>Whether this allocator uses a separate object log</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetAndInitializeValue(System.Int64,System.Int64)">
            <summary>Cast address range to <typeparamref name="TValue"/>. For <see cref="T:Tsavorite.core.SpanByte"/> this will also initialize the value to span the address range.</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetRMWCopyDestinationRecordSize``2(`0@,``0@,`1@,Tsavorite.core.RecordInfo@,``1)">
            <summary>Get copy destination size for RMW, taking Input into account</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetRMWInitialRecordSize``2(`0@,``0@,``1)">
            <summary>Get initial record size for RMW, given the <paramref name="key"/> and <paramref name="input"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetUpsertRecordSize``2(`0@,`1@,``0@,``1)">
            <summary>Get record size required for the given <paramref name="key"/>, <paramref name="value"/>, and <paramref name="input"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetRecordSize(`0@,`1@)">
            <summary>Get record size required for the given <paramref name="key"/> and <paramref name="value"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetTombstoneRecordSize(`0@)">
            <summary>Get the record size for a tombstoned record</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetValueLength(`1@)">
            <summary>Get the size of the given <paramref name="value"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.MarkPage(System.Int64,System.Int64)">
            <summary>Mark the page that contains <paramref name="logicalAddress"/> as dirty</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.MarkPageAtomic(System.Int64,System.Int64)">
            <summary>Mark the page that contains <paramref name="logicalAddress"/> as dirty atomically</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.GetSegmentOffsets">
            <summary>Get segment offsets</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocator`3.SerializeKey(`0@,System.Int64)">
            <summary>Serialize key to log</summary>
        </member>
        <member name="T:Tsavorite.core.IAllocatorCallbacks`3">
            <summary>
            Interface for hybrid log memory allocator struct wrapper callbacks for inlining performance-path callbacks from 
            <see cref="T:Tsavorite.core.AllocatorBase`4"/>
            to the fully derived allocator, including both record accessors and Scan calls.
            </summary>
            <remarks>This interface does not currently appear in type constraints, but the organization may prove useful.</remarks>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetStartLogicalAddress(System.Int64)">
            <summary>Get start logical address on <paramref name="page"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetFirstValidLogicalAddress(System.Int64)">
            <summary>Get first valid logical address on <paramref name="page"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetPhysicalAddress(System.Int64)">
            <summary>Get physical address from <paramref name="logicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetInfo(System.Int64)">
            <summary>Get <see cref="T:Tsavorite.core.RecordInfo"/> from <paramref name="physicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetInfoFromBytePointer(System.Byte*)">
            <summary>Get <see cref="T:Tsavorite.core.RecordInfo"/> from pinned memory</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetKey(System.Int64)">
            <summary>Get <typeparamref name="TKey"/> from <paramref name="physicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetValue(System.Int64)">
            <summary>Get <typeparamref name="TValue"/> from <paramref name="physicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetRecordSize(System.Int64)">
            <summary>Get the actual (used) and allocated record sizes at <paramref name="physicalAddress"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetRequiredRecordSize(System.Int64,System.Int32)">
            <summary>Get number of bytes required to read the full record that starts at <paramref name="physicalAddress"/> for <paramref name="availableBytes"/>.</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetAverageRecordSize">
            <summary>Get average record size</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.AllocatePage(System.Int32)">
            <summary>Allocate the page in the circular buffer slot at <paramref name="pageIndex"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.IsAllocated(System.Int32)">
            <summary>Whether the page at <paramref name="pageIndex"/> is allocated</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.PopulatePage(System.Byte*,System.Int32,System.Int64)">
            <summary>
            Populate the page at <paramref name="destinationPageIndex"/> from the <paramref name="src"/> pointer, which has <paramref name="required_bytes"/> bytes.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.ClearPage(System.Int64,System.Int32)">
            <summary>Free the page at <paramref name="pageIndex"/>, starting at <paramref name="offset"/></summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.FreePage(System.Int64)">
            <summary>Free the page at <paramref name="pageIndex"/></summary>
        </member>
        <member name="P:Tsavorite.core.IAllocatorCallbacks`3.OverflowPageCount">
            <summary>Number of extra overflow pages allocated</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetContextRecordKey(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>Retrieve key from IO context record</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetContextRecordValue(Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>Retrieve value from IO context record</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.RetrievedFullRecord(System.Byte*,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>Determine whether we IO has returned the full record</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetKeyContainer(`0@)">
            <summary>Get heap container for pending key</summary>
        </member>
        <member name="M:Tsavorite.core.IAllocatorCallbacks`3.GetValueContainer(`1@)">
            <summary>Get heap container for pending value</summary>
        </member>
        <member name="T:Tsavorite.core.CursorRecordResult">
            <summary>
            Result for records sent to the callback during ScanCursor.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CursorRecordResult.Accept">
            <summary>
            The record meets the callback's filter criteria for this scan (or there is no filter); increment the cursor counter.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CursorRecordResult.Skip">
            <summary>
            The record does not meet the callback's filter criteria for this scan; do not increment the cursor counter
            </summary>
        </member>
        <member name="F:Tsavorite.core.CursorRecordResult.EndBatch">
            <summary>
            End the current cursor batch (as if "count" had been met); return a valid cursor for the next ScanCursor call
            </summary>
        </member>
        <member name="F:Tsavorite.core.CursorRecordResult.RetryLastRecord">
            <summary>
            Retry the last record when returning a valid cursor
            </summary>
        </member>
        <member name="T:Tsavorite.core.IScanIteratorFunctions`2">
            <summary>
            Callback functions for log scan or key-version iteration
            </summary>
        </member>
        <member name="M:Tsavorite.core.IScanIteratorFunctions`2.OnStart(System.Int64,System.Int64)">
            <summary>Iteration is starting.</summary>
            <param name="beginAddress">Start address of the scan</param>
            <param name="endAddress">End address of the scan; if iterating key versions, this is <see cref="F:Tsavorite.core.Constants.kInvalidAddress"/></param>
            <returns>True to continue iteration, else false</returns>
        </member>
        <member name="M:Tsavorite.core.IScanIteratorFunctions`2.SingleReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <summary>Next record in iteration for a record not in mutable log memory.</summary>
            <param name="key">Reference to the current record's key</param>
            <param name="value">Reference to the current record's Value</param>
            <param name="recordMetadata">Record metadata, including <see cref="T:Tsavorite.core.RecordInfo"/> and the current record's logical address</param>
            <param name="numberOfRecords">The number of records accepted so far, not including the current one.</param>
            <param name="cursorRecordResult">Indicates whether the current record was accepted, or whether to end the current ScanCursor call.
                Ignored for non-cursor Scans; set to <see cref="F:Tsavorite.core.CursorRecordResult.Accept"/>.</param>
            <returns>True to continue iteration, else false</returns>
        </member>
        <member name="M:Tsavorite.core.IScanIteratorFunctions`2.ConcurrentReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <summary>Next record in iteration for a record in mutable log memory.</summary>
            <param name="key">Reference to the current record's key</param>
            <param name="value">Reference to the current record's Value</param>
            <param name="recordMetadata">Record metadata, including <see cref="T:Tsavorite.core.RecordInfo"/> and the current record's logical address</param>
            <param name="numberOfRecords">The number of records accepted so far, not including the current one.</param>
            <param name="cursorRecordResult">Indicates whether the current record was accepted, or whether to end the current ScanCursor call.
                Ignored for non-cursor Scans; set to <see cref="F:Tsavorite.core.CursorRecordResult.Accept"/>.</param>
            <returns>True to continue iteration, else false</returns>
        </member>
        <member name="M:Tsavorite.core.IScanIteratorFunctions`2.OnStop(System.Boolean,System.Int64)">
            <summary>Iteration is complete.</summary>
            <param name="completed">If true, the iteration completed; else scanFunctions.*Reader() returned false to stop the iteration.</param>
            <param name="numberOfRecords">The number of records returned before the iteration stopped.</param>
        </member>
        <member name="M:Tsavorite.core.IScanIteratorFunctions`2.OnException(System.Exception,System.Int64)">
            <summary>An exception was thrown on iteration (likely during <see name="SingleReader"/> or <see name="ConcurrentReader"/>.</summary>
            <param name="exception">The exception that was thrown.</param>
            <param name="numberOfRecords">The number of records returned, including the current one, before the exception.</param>
        </member>
        <member name="M:Tsavorite.core.IPushScanIterator`1.SnapCursorToLogicalAddress(System.Int64@)">
            <summary>
            When beginning a cursor scan, if it is not the last cursor returned, snap it to the preceding logical address boundary.
            </summary>
        </member>
        <member name="T:Tsavorite.core.IStreamingSnapshotIteratorFunctions`2">
            <summary>
            Callback functions for streaming snapshot iteration
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStreamingSnapshotIteratorFunctions`2.OnStart(System.Guid,System.Int64,System.Int64)">
            <summary>Iteration is starting.</summary>
            <param name="checkpointToken">Checkpoint token</param>
            <param name="currentVersion">Current version of database</param>
            <param name="nextVersion">Next version of database</param>
            <returns>True to continue iteration, else false</returns>
        </member>
        <member name="M:Tsavorite.core.IStreamingSnapshotIteratorFunctions`2.Reader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64)">
            <summary>Next record in the streaming snapshot.</summary>
            <param name="key">Reference to the current record's key</param>
            <param name="value">Reference to the current record's Value</param>
            <param name="recordMetadata">Record metadata, including <see cref="T:Tsavorite.core.RecordInfo"/> and the current record's logical address</param>
            <param name="numberOfRecords">The number of records returned so far, not including the current one.</param>
            <returns>True to continue iteration, else false</returns>
        </member>
        <member name="M:Tsavorite.core.IStreamingSnapshotIteratorFunctions`2.OnStop(System.Boolean,System.Int64)">
            <summary>Iteration is complete.</summary>
            <param name="completed">If true, the iteration completed; else OnStart() or Reader() returned false to stop the iteration.</param>
            <param name="numberOfRecords">The number of records returned before the iteration stopped.</param>
        </member>
        <member name="M:Tsavorite.core.IStreamingSnapshotIteratorFunctions`2.OnException(System.Exception,System.Int64)">
            <summary>An exception was thrown on iteration (likely during <see name="Reader"/>.</summary>
            <param name="exception">The exception that was thrown.</param>
            <param name="numberOfRecords">The number of records returned before the exception.</param>
        </member>
        <member name="T:Tsavorite.core.ScanBufferingMode">
            <summary>
            Scan buffering mode
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanBufferingMode.SinglePageBuffering">
            <summary>
            Buffer only current page being scanned
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanBufferingMode.DoublePageBuffering">
            <summary>
            Buffer current and next page in scan sequence
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanBufferingMode.NoBuffering">
            <summary>
            Do not buffer - with this mode, you can only scan records already in main memory
            </summary>
        </member>
        <member name="T:Tsavorite.core.ITsavoriteScanIterator`2">
            <summary>
            Scan iterator interface for Tsavorite log
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteScanIterator`2.GetKey">
            <summary>
            Gets reference to current key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteScanIterator`2.GetValue">
            <summary>
            Gets reference to current value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteScanIterator`2.GetNext(Tsavorite.core.RecordInfo@)">
            <summary>
            Get next record
            </summary>
            <param name="recordInfo"></param>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteScanIterator`2.GetNext(Tsavorite.core.RecordInfo@,`0@,`1@)">
            <summary>
            Get next record
            </summary>
            <param name="recordInfo"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteScanIterator`2.CurrentAddress">
            <summary>
            Current address
            </summary>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteScanIterator`2.NextAddress">
            <summary>
            Next address
            </summary>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteScanIterator`2.BeginAddress">
            <summary>
            The starting address of the scan
            </summary>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteScanIterator`2.EndAddress">
            <summary>
            The ending address of the scan
            </summary>
        </member>
        <member name="T:Tsavorite.core.MallocFixedPageSize`1">
            <summary>
            Memory allocator for objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Tsavorite.core.MallocFixedPageSize`1.NumAllocations">
            <summary>Number of allocations performed</summary>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new instance
            </summary>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.GetPhysicalAddress(System.Int64)">
            <summary>
            Get physical address -- for blittable objects only
            </summary>
            <param name="logicalAddress">The logicalAddress of the allocation. For BulkAllocate, this may be an address within the chunk size, to reference that particular record.</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Get(System.Int64)">
            <summary>
            Get object
            </summary>
            <param name="index">The index of the allocation. For BulkAllocate, this may be a value within the chunk size, to reference that particular record.</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Set(System.Int64,`0@)">
            <summary>
            Set object
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Free(System.Int64)">
            <summary>
            Free object
            </summary>
            <param name="pointer"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.BulkAllocate">
            <summary>
            Allocate a block of size RecordSize * kAllocateChunkSize. 
            </summary>
            <remarks>Warning: cannot mix 'n' match use of Allocate and BulkAllocate because there is no header indicating record size, so 
            the freeList does not distinguish them.</remarks>
            <returns>The logicalAddress (index) of the block</returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Allocate">
            <summary>
            Allocate a block of size RecordSize.
            </summary>
            <returns>The logicalAddress (index) of the block</returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.IsCheckpointCompleted">
            <summary>
            Is checkpoint complete
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.IsCheckpointCompletedAsync(System.Threading.CancellationToken)">
            <summary>
            Is checkpoint completed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.BeginCheckpoint(Tsavorite.core.IDevice,System.UInt64,System.UInt64@)">
            <summary>
            Public facing persistence API
            </summary>
            <param name="device"></param>
            <param name="offset"></param>
            <param name="numBytesWritten"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.BeginCheckpoint(Tsavorite.core.IDevice,System.UInt64,System.UInt64@,System.Boolean,Tsavorite.core.SkipReadCache,Tsavorite.core.LightEpoch)">
            <summary>
            Internal persistence API
            </summary>
            <param name="device"></param>
            <param name="offset"></param>
            <param name="numBytesWritten"></param>
            <param name="useReadCache"></param>
            <param name="skipReadCache"></param>
            <param name="epoch"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.GetMaxValidAddress">
            <summary>
            Max valid address
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.GetPageSize">
            <summary>
            Get page size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.Recover(Tsavorite.core.IDevice,System.UInt64,System.Int32,System.UInt64)">
            <summary>
            Recover
            </summary>
            <param name="device"></param>
            <param name="buckets"></param>
            <param name="numBytes"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.RecoverAsync(Tsavorite.core.IDevice,System.UInt64,System.Int32,System.UInt64,System.Threading.CancellationToken)">
            <summary>
            Recover
            </summary>
            <param name="device"></param>
            <param name="buckets"></param>
            <param name="numBytes"></param>
            <param name="cancellationToken"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Tsavorite.core.MallocFixedPageSize`1.IsRecoveryCompleted(System.Boolean)">
            <summary>
            Check if recovery complete
            </summary>
            <param name="waitUntilComplete"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.MemoryPageScanIterator`2">
            <summary>
            Lightweight iterator for memory page (copied to buffer). GetNext() can be used outside epoch protection and locking,
            but ctor must be called within epoch protection.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Tsavorite.core.MemoryPageScanIterator`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.PendingFlushList.RemoveNextAdjacent(System.Int64,Tsavorite.core.PageAsyncFlushResult{Tsavorite.core.Empty}@)">
            <summary>
            Remove item from flush list with from-address equal to the specified address
            </summary>
        </member>
        <member name="M:Tsavorite.core.PendingFlushList.RemovePreviousAdjacent(System.Int64,Tsavorite.core.PageAsyncFlushResult{Tsavorite.core.Empty}@)">
            <summary>
            Remove item from flush list with until-address equal to the specified address
            </summary>
        </member>
        <member name="T:Tsavorite.core.ScanIteratorBase">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.frameSize">
            <summary>
            Frame size
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.beginAddress">
            <summary>
            Begin address. Cannot be readonly due to SnapCursorToLogicalAddress
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.endAddress">
            <summary>
            End address
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.epoch">
            <summary>
            Epoch
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.currentAddress">
            <summary>
            Current and next address for iteration
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.nextAddress">
            <summary>
            Current and next address for iteration
            </summary>
        </member>
        <member name="P:Tsavorite.core.ScanIteratorBase.CurrentAddress">
            <summary>
            Current address
            </summary>
        </member>
        <member name="P:Tsavorite.core.ScanIteratorBase.NextAddress">
            <summary>
            Next address
            </summary>
        </member>
        <member name="P:Tsavorite.core.ScanIteratorBase.BeginAddress">
            <summary>
            The starting address of the scan
            </summary>
        </member>
        <member name="P:Tsavorite.core.ScanIteratorBase.EndAddress">
            <summary>
            The ending address of the scan
            </summary>
        </member>
        <member name="F:Tsavorite.core.ScanIteratorBase.logger">
            <summary>
            Logger instance
            </summary>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.#ctor(System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean,Tsavorite.core.LightEpoch,System.Int32,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
            <param name="beginAddress"></param>
            <param name="endAddress"></param>
            <param name="scanBufferingMode"></param>
            <param name="includeClosedRecords"></param>
            <param name="epoch"></param>
            <param name="logPageSizeBits"></param>
            <param name="initForReads"></param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.InitializeForReads">
            <summary>
            Initialize for reads
            </summary>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.BufferAndLoad(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Buffer and load
            </summary>
            <param name="currentAddress"></param>
            <param name="currentPage"></param>
            <param name="currentFrame"></param>
            <param name="headAddress"></param>
            <param name="endAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.NeedBufferAndLoad(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Whether we need to buffer new page from disk
            </summary>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.Dispose">
            <summary>
            Dispose iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.Reset">
            <summary>
            Reset iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.ScanIteratorBase.ToString">
            <inheritdoc/>
        </member>
        <member name="F:Tsavorite.core.SpanByteAllocator`1._this">
            <summary>The wrapped class containing all data and most actual functionality. This must be the ONLY field in this structure so its size is sizeof(IntPtr).</summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetBase``1">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.SpanByteAllocator`1.IsFixedLength">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.SpanByteAllocator`1.HasObjectLog">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetStartLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetFirstValidLogicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetPhysicalAddress(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetInfo(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetInfoFromBytePointer(System.Byte*)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetKey(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetValue(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetAndInitializeValue(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetRecordSize(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetRMWCopyDestinationRecordSize``2(Tsavorite.core.SpanByte@,``0@,Tsavorite.core.SpanByte@,Tsavorite.core.RecordInfo@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetTombstoneRecordSize(Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetRequiredRecordSize(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetAverageRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetFixedRecordSize">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetRMWInitialRecordSize``2(Tsavorite.core.SpanByte@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetUpsertRecordSize``2(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,``0@,``1)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetRecordSize(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetValueLength(Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.RetrievedFullRecord(System.Byte*,Tsavorite.core.AsyncIOContext{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.AllocatePage(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.IsAllocated(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.PopulatePage(System.Byte*,System.Int32,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.MarkPage(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.MarkPageAtomic(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.ClearPage(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.FreePage(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetContextRecordKey(Tsavorite.core.AsyncIOContext{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetContextRecordValue(Tsavorite.core.AsyncIOContext{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte}@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetKeyContainer(Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetValueContainer(Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.GetSegmentOffsets">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.SpanByteAllocator`1.OverflowPageCount">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocator`1.SerializeKey(Tsavorite.core.SpanByte@,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.Dispose">
            <summary>
            Dispose memory allocator
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.AllocatePage(System.Int32)">
            <summary>
            Allocate memory page, pinned in memory, and in sector aligned form, if possible
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.DeleteFromMemory">
            <summary>
            Delete in-memory portion of the log
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.AsyncReadRecordObjectsToMemory(System.Int64,System.Int32,Tsavorite.core.DeviceIOCompletionCallback,Tsavorite.core.AsyncIOContext{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte},Tsavorite.core.SectorAlignedMemory)">
            <summary>
            Invoked by users to obtain a record from disk. It uses sector aligned memory to read 
            the record efficiently into memory.
            </summary>
            <param name="fromLogical"></param>
            <param name="numBytes"></param>
            <param name="callback"></param>
            <param name="context"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.Scan(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean)">
            <summary>
            Iterator interface for pull-scanning Tsavorite log
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.Scan``1(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},System.Int64,System.Int64,``0@,Tsavorite.core.ScanBufferingMode)">
            <summary>
            Implementation for push-scanning Tsavorite log, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.ScanCursor``1(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},Tsavorite.core.ScanCursorState{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte},System.Int64@,System.Int64,``0,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Implementation for push-scanning Tsavorite log with a cursor, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.IterateKeyVersions``1(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},Tsavorite.core.SpanByte@,System.Int64,``0@)">
            <summary>
            Implementation for push-iterating key versions, called from LogAccessor
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.MemoryPageScan(System.Int64,System.Int64,System.IObserver{Tsavorite.core.ITsavoriteScanIterator{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte}})">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteAllocatorImpl`1.AsyncReadPagesFromDeviceToFrame``1(System.Int64,System.Int32,System.Int64,Tsavorite.core.DeviceIOCompletionCallback,``0,Tsavorite.core.BlittableFrame,System.Threading.CountdownEvent@,System.Int64,Tsavorite.core.IDevice,Tsavorite.core.IDevice)">
            <summary>
            Read pages from specified device
            </summary>
            <typeparam name="TContext"></typeparam>
            <param name="readPageStart"></param>
            <param name="numPages"></param>
            <param name="untilAddress"></param>
            <param name="callback"></param>
            <param name="context"></param>
            <param name="frame"></param>
            <param name="completed"></param>
            <param name="devicePageOffset"></param>
            <param name="device"></param>
            <param name="objectLogDevice"></param>
        </member>
        <member name="T:Tsavorite.core.SpanByteScanIterator`1">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.#ctor(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},Tsavorite.core.SpanByteAllocatorImpl{`0},System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean,Tsavorite.core.LightEpoch,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
            <param name="store"></param>
            <param name="hlog">The fully derived log implementation</param>
            <param name="beginAddress"></param>
            <param name="endAddress"></param>
            <param name="scanBufferingMode"></param>
            <param name="includeClosedRecords"></param>
            <param name="epoch">Epoch to use for protection; may be null if <paramref name="forceInMemory"/> is true.</param>
            <param name="forceInMemory">Provided address range is known by caller to be in memory, even if less than HeadAddress</param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.#ctor(Tsavorite.core.TsavoriteKV{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,`0,Tsavorite.core.SpanByteAllocator{`0}},Tsavorite.core.SpanByteAllocatorImpl{`0},System.Int64,Tsavorite.core.LightEpoch,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor for use with tail-to-head push iteration of the passed key's record versions
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.GetKey">
            <summary>
            Gets reference to current key
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.GetValue">
            <summary>
            Gets reference to current value
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.SnapCursorToLogicalAddress(System.Int64@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.GetNext(Tsavorite.core.RecordInfo@)">
            <summary>
            Get next record in iterator
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.Tsavorite#core#IPushScanIterator{Tsavorite#core#SpanByte}#BeginGetPrevInMemory(Tsavorite.core.SpanByte@,Tsavorite.core.RecordInfo@,System.Boolean@)">
            <summary>
            Get previous record and keep the epoch held while we call the user's scan functions
            </summary>
            <returns>True if record found, false if end of scan</returns>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.GetNext(Tsavorite.core.RecordInfo@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <summary>
            Get next record in iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.SpanByteScanIterator`1.Dispose">
            <summary>
            Dispose iterator
            </summary>
        </member>
        <member name="T:Tsavorite.core.WorkQueueFIFO`1">
            <summary>
            Shared work queue that ensures one worker at any given time. Uses FIFO ordering of work.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.WorkQueueFIFO`1.EnqueueAndTryWork(`0,System.Boolean)">
            <summary>
            Enqueue work item, take ownership of draining the work queue
            if needed
            </summary>
            <param name="work">Work to enqueue</param>
            <param name="asTask">Process work as separate task</param>
            <returns> whether the enqueue is successful. Enqueuing into a disposed WorkQueue will fail and the task will not be performed</returns>>
        </member>
        <member name="T:Tsavorite.core.WorkQueueLIFO`1">
            <summary>
            Shared work queue with a single work processor task loop. Uses LIFO ordering of work.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.WorkQueueLIFO`1.AddWorkItem(`0)">
            <summary>
            Add work item
            </summary>
            <param name="workItem">Work item</param>
            <returns>Whether the add is successful</returns>>
        </member>
        <member name="T:Tsavorite.core.TsavoriteKV`4">
            <summary>
            The Tsavorite key-value store
            </summary>
            <summary>
            Compaction methods
            </summary>
            <summary>
            The Tsavorite Key/Value store class
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ReadyToCompletePendingAsync``3(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.TsavoriteExecutionContext{``0,``1,``2},System.Threading.CancellationToken)">
            <summary>
            Check if at least one (sync) request is ready for CompletePending to operate on
            </summary>
            <param name="sessionCtx"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CompletePendingAsync``4(``3,System.Threading.CancellationToken,Tsavorite.core.CompletedOutputIterator{`0,`1,``0,``1,``2})">
            <summary>
            Complete outstanding pending operations that were issued synchronously
            Async operations (e.g., ReadAsync) need to be completed individually
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.NewSession``4(``3,Tsavorite.core.ReadCopyOptions)">
            <summary>
            Start a new client session with Tsavorite.
            </summary>
            <param name="functions">Callback functions</param>
            <param name="readCopyOptions"><see cref="F:Tsavorite.core.TsavoriteKV`4.ReadCopyOptions"/> for this session; override those specified at TsavoriteKV level, and may be overridden on individual Read operations</param>
            <returns>Session instance</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.DisposeClientSession(System.Int32)">
            <summary>
            Dispose session with Tsavorite
            </summary>
            <param name="sessionID"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.DumpRevivificationStats">
            <summary>
            Dumps the revivification stats to a string.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ResetRevivificationStats">
            <summary>
            Resets the revivification stats.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Compact``5(``3,``4,``0@,``1@,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="functions">Functions used to manage key-values during compaction</param>
            <param name="cf">User provided compaction functions (see <see cref="T:Tsavorite.core.ICompactionFunctions`2"/>).</param>
            <param name="input">Input for SingleWriter</param>
            <param name="output">Output from SingleWriter; it will be called all records that are moved, before Compact() returns, so the user must supply buffering or process each output completely</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase1Functions.SingleReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase1Functions.ConcurrentReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase1Functions.OnException(System.Exception,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase1Functions.OnStart(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase1Functions.OnStop(System.Boolean,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase2Functions.SingleReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase2Functions.ConcurrentReader(`0@,`1@,Tsavorite.core.RecordMetadata,System.Int64,Tsavorite.core.CursorRecordResult@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase2Functions.OnException(System.Exception,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase2Functions.OnStart(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ScanPhase2Functions.OnStop(System.Boolean,System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.RecoveredCommitCookie">
            <summary>
            User-specified commit cookie persisted with last recovered commit
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.SystemState">
            <summary>
            Get the current state machine state of the system
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.LastCheckpointedVersion">
            <summary>
            Version number of the last checkpointed state
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.IncrementalSnapshotTailAddress">
            <summary>
            Size (tail address) of current incremental snapshot delta log
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.CurrentVersion">
            <summary>
            Current version number of the store
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetLatestCheckpointTokens(System.Guid@,System.Guid@,System.Int64@)">
            <summary>
            GetLatestCheckpointTokens
            </summary>
            <param name="hlogToken"></param>
            <param name="indexToken"></param>
            <param name="storeVersion"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetLatestCheckpointVersion">
            <summary>
            Get HLog latest version
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetLogFileSize(System.Guid,System.Int64)">
            <summary>
            Get size of snapshot files for token
            </summary>
            <param name="token"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetIndexFileSize(System.Guid)">
            <summary>
            Get size of index file for token
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Reset">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.SetVersion(System.Int64)">
            <summary>
            Set store version directly. Useful if manually recovering by re-inserting data.
            Warning: use only when the system is not taking a checkpoint.
            </summary>
            <param name="version">Version to set the store to</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.RecoverToInitialPage(Tsavorite.core.IndexCheckpointInfo,Tsavorite.core.HybridLogCheckpointInfo,System.Int64@)">
            <summary>
            Compute recovery address and determine where to recover to
            </summary>
            <param name="recoveredICInfo">IndexCheckpointInfo</param>
            <param name="recoveredHLCInfo">HybridLogCheckpointInfo</param>
            <param name="recoverFromAddress">Address from which to perform recovery (undo v+1 records)</param>
            <returns>Whether we are recovering to the initial page</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.FreePagesBeyondUsableCapacity(System.Int64,System.Int32,System.Int32,System.Int32,Tsavorite.core.RecoveryStatus)">
            <summary>
            This method ensures that before 'pagesToRead' number of pages are read into memory, any previously allocated pages 
            that would cause total number of pages in memory to go beyond usableCapacity are freed. This is to ensure that 
            memory size constraint is maintained during recovery.
            Illustration with capacity 32, usableCapacity 20, pagesToRead 2:
                beg: startPage - 32
                end: startPage - 18
            We free these 14 pages, leaving 18 allocated, and then read 2, which fills up usableCapacity.
            The beg, end can only be zero on the first pass through the buffer, as the page number continuously increases 
            </summary>
        </member>
        <member name="T:Tsavorite.core.TsavoriteKV`4.AllocateOptions">
            <summary>Options for TryAllocateRecord.</summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteKV`4.AllocateOptions.Recycle">
            <summary>If true, use the non-revivification recycling of records that failed to CAS and are carried in PendingContext through RETRY.</summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteKV`4.AllocateOptions.ElideSourceRecord">
            <summary>If true, the source record is elidable so we can try to elide from the tag chain (and transfer it to the FreeList if we're doing Revivification).</summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ConditionalCopyToTail``4(``3,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,`0@,``0@,`1@,``1@,``2,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@,Tsavorite.core.WriteReason,System.Boolean,System.Int64)">
            <summary>
            Copy a record to the tail of the log after caller has verified it does not exist within a specified range.
            </summary>
            <param name="sessionFunctions">Callback functions.</param>
            <param name="pendingContext">pending context created when the operation goes pending.</param>
            <param name="key">key of the record.</param>
            <param name="input">input passed through.</param>
            <param name="value">the value to insert</param>
            <param name="output">Location to store output computed from input and value.</param>
            <param name="userContext">user context corresponding to operation used during completion callback.</param>
            <param name="stackCtx">Contains information about the call context, record metadata, and so on</param>
            <param name="writeReason">The reason the CopyToTail is being done</param>
            <param name="wantIO">Whether to do IO if the search must go below HeadAddress. ReadFromImmutable, for example,
                is just an optimization to avoid future IOs, so if we need an IO here we just defer them to the next Read().</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ContinuePendingRead``4(Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Continue a pending read operation. Computes 'output' from 'input' and value corresponding to 'key'
            obtained from disk. Optionally, it copies the value to tail to serve future read/write requests quickly.
            </summary>
            <param name="request">Async response from disk.</param>
            <param name="pendingContext">Pending context corresponding to operation.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type = "table" >
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The output has been computed and stored in 'output'.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ContinuePendingRMW``4(Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Continue a pending RMW operation with the record retrieved from disk.
            </summary>
            <param name="request">record read from the disk.</param>
            <param name="pendingContext">internal context for the pending RMW operation</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully updated(or inserted).</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>We need to issue an IO to continue.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ContinuePendingConditionalCopyToTail``4(Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Continue a pending CONDITIONAL_INSERT operation with the record retrieved from disk, checking whether a record for this key was
            added since we went pending; in that case this operation must be adjusted to use current data.
            </summary>
            <param name="request">record read from the disk.</param>
            <param name="pendingContext">internal context for the pending RMW operation</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully inserted, or was found above the specified address.</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>We need to issue an IO to continue.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ContinuePendingConditionalScanPush``4(Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Continue a pending CONDITIONAL_SCAN_PUSH operation with the record retrieved from disk, checking whether a record for this key was
            added since we went pending; in that case this operation "fails" as it finds the record.
            </summary>
            <param name="request">record read from the disk.</param>
            <param name="pendingContext">internal context for the pending RMW operation</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully inserted, or was found above the specified address.</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>We need to issue an IO to continue.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.HandleImmediateNonPendingRetryStatus``4(Tsavorite.core.OperationStatus,``3)">
            <summary>
            Handle retry for operations that will not go pending (e.g., InternalLock)
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.HandleOperationStatus``3(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.TsavoriteExecutionContext{``0,``1,``2},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,Tsavorite.core.OperationStatus)">
            <summary>
            Performs appropriate handling based on the internal failure status of the trial.
            </summary>
            <param name="sessionCtx">Thread (or session) context under which operation was tried to execute.</param>
            <param name="pendingContext">Internal context of the operation.</param>
            <param name="operationStatus">Internal status of the trial.</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.HandleOperationStatus``3(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.TsavoriteExecutionContext{``0,``1,``2},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,Tsavorite.core.OperationStatus,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>
            Performs appropriate handling based on the internal failure status of the trial.
            </summary>
            <param name="sessionCtx">Thread (or session) context under which operation was tried to execute.</param>
            <param name="pendingContext">Internal context of the operation.</param>
            <param name="operationStatus">Internal status of the trial.</param>
            <param name="request">IO request, if operation went pending</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.IsRecordVersionNew(System.Int64)">
            <summary>
            This is a wrapper for checking the record's version instead of just peeking at the latest record at the tail of the bucket.
            By calling with the address of the traced record, we can prevent a different key sharing the same bucket from deceiving 
            the operation to think that the version of the key has reached v+1 and thus to incorrectly update in place.
            </summary>
            <param name="logicalAddress">The logical address of the traced record for the key</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.IsEntryVersionNew(Tsavorite.core.HashBucketEntry@)">
            <summary>
            Check the version of the passed-in entry. 
            The semantics of this function are to check the tail of a bucket (indicated by entry), so we name it this way.
            </summary>
            <param name="entry">the last entry of a bucket</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalDelete``4(`0@,System.Int64,``2@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Delete operation. Replaces the value corresponding to 'key' with tombstone.
            If at head, tries to remove item from hash chain
            </summary>
            <param name="key">Key of the record to be deleted.</param>
            <param name="keyHash"></param>
            <param name="userContext">User context for the operation, in case it goes pending.</param>
            <param name="pendingContext">Pending context used internally to store the context of the operation.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully deleted</term>
                </item>
                <item>
                <term>RETRY_LATER</term>
                <term>Cannot  be processed immediately due to system state. Add to pending list and retry later</term>
                </item>
                <item>
                <term>CPR_SHIFT_DETECTED</term>
                <term>A shift in version has been detected. Synchronize immediately to avoid violating CPR consistency.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CreateNewRecordDelete``4(`0@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@,Tsavorite.core.RecordInfo@,Tsavorite.core.DeleteInfo@)">
            <summary>
            Create a new tombstoned record for Delete
            </summary>
            <param name="key">The record Key</param>
            <param name="pendingContext">Information about the operation context</param>
            <param name="sessionFunctions">The current session</param>
            <param name="stackCtx">Contains the <see cref="T:Tsavorite.core.HashEntryInfo"/> and <see cref="T:Tsavorite.core.RecordSource`4"/> structures for this operation,
                and allows passing back the newLogicalAddress for invalidation in the case of exceptions.</param>
            <param name="srcRecordInfo">If <paramref name="stackCtx"/>.<see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>,
                this is the <see cref="T:Tsavorite.core.RecordInfo"/> for <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/></param>
            <param name="deleteInfo">DeleteInfo</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalRead``4(`0@,System.Int64,``0@,``1@,``2,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Read operation. Computes the 'output' from 'input' and current value corresponding to 'key'.
            When the read operation goes pending, once the record is retrieved from disk, ContinuePendingRead completes the operation.
            </summary>
            <param name="key">Key of the record.</param>
            <param name="keyHash">Hashcode of <paramref name="key"/></param>
            <param name="input">Input required to compute output from value.</param>
            <param name="output">Location to store output computed from input and value.</param>
            <param name="userContext">User context for the operation, in case it goes pending.</param>
            <param name="pendingContext">Pending context used internally to store the context of the operation.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The output has been computed using current value of 'key' and 'input'; and stored in 'output'.</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>The record corresponding to 'key' is on disk and the operation.</term>
                </item>
                <item>
                <term>CPR_SHIFT_DETECTED</term>
                <term>A shift in version has been detected. Synchronize immediately to avoid violating CPR consistency.</term>
                </item>
                <item>
                <term>RETRY_LATER</term>
                <term>Refresh the epoch and retry.</term>
                </item>
                <item>
                <term>RETRY_NOW</term>
                <term>Retry without epoch refresh.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalReadAtAddress``4(System.Int64,`0@,``0@,``1@,Tsavorite.core.ReadOptions@,``2,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Read operation without a key. Computes the 'output' from 'input' and current value at 'address'.
            When the read operation goes pending, once the record is retrieved from disk, ContinuePendingRead completes the operation.
            </summary>
            <param name="readAtAddress">The logical address to read from</param>
            <param name="key">Key of the record.</param>
            <param name="input">Input required to compute output from value.</param>
            <param name="output">Location to store output computed from input and value.</param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext">User context for the operation, in case it goes pending.</param>
            <param name="pendingContext">Pending context used internally to store the context of the operation.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The output has been computed using current value of 'key' and 'input'; and stored in 'output'.</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>The record corresponding to 'key' is on disk and the operation.</term>
                </item>
                <item>
                <term>CPR_SHIFT_DETECTED</term>
                <term>A shift in version has been detected. Synchronize immediately to avoid violating CPR consistency.</term>
                </item>
                <item>
                <term>RETRY_LATER</term>
                <term>Refresh the epoch and retry.</term>
                </item>
                <item>
                <term>RETRY_NOW</term>
                <term>Retry without epoch refresh.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalRMW``4(`0@,System.Int64,``0@,``1@,``2@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Read-Modify-Write Operation. Updates value of 'key' using 'input' and current value.
            Pending operations are processed either using InternalRetryPendingRMW or 
            InternalContinuePendingRMW.
            </summary>
            <param name="key">key of the record.</param>
            <param name="keyHash">the hash of <parameref name="key"/></param>
            <param name="input">input used to update the value.</param>
            <param name="output">Location to store output computed from input and value.</param>
            <param name="userContext">user context corresponding to operation used during completion callback.</param>
            <param name="pendingContext">pending context created when the operation goes pending.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully updated (or inserted).</term>
                </item>
                <item>
                <term>RECORD_ON_DISK</term>
                <term>The record corresponding to 'key' is on disk. Issue async IO to retrieve record and retry later.</term>
                </item>
                <item>
                <term>RETRY_LATER</term>
                <term>Cannot  be processed immediately due to system state. Add to pending list and retry later.</term>
                </item>
                <item>
                <term>CPR_SHIFT_DETECTED</term>
                <term>A shift in version has been detected. Synchronize immediately to avoid violating CPR consistency.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CreateNewRecordRMW``4(`0@,``0@,`1@,``1@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@,Tsavorite.core.RecordInfo@,System.Boolean,Tsavorite.core.RMWInfo@)">
            <summary>
            Create a new record for RMW
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TSessionFunctionsWrapper"></typeparam>
            <param name="key">The record Key</param>
            <param name="input">Input to the operation</param>
            <param name="value">Old value</param>
            <param name="output">The result of ISessionFunctions.SingleWriter</param>
            <param name="pendingContext">Information about the operation context</param>
            <param name="sessionFunctions">The current session</param>
            <param name="stackCtx">Contains the <see cref="T:Tsavorite.core.HashEntryInfo"/> and <see cref="T:Tsavorite.core.RecordSource`4"/> structures for this operation,
                and allows passing back the newLogicalAddress for invalidation in the case of exceptions. If called from pending IO,
                this is populated from the data read from disk.</param>
            <param name="srcRecordInfo">If <paramref name="stackCtx"/>.<see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>,
                this is the <see cref="T:Tsavorite.core.RecordInfo"/> for <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/>. Otherwise, if called from pending IO,
                this is the <see cref="T:Tsavorite.core.RecordInfo"/> read from disk. If neither of these, it is a default <see cref="T:Tsavorite.core.RecordInfo"/>.</param>
            <param name="doingCU">Whether we are doing a CopyUpdate, either from in-memory or pending IO</param>
            <param name="rmwInfo">RMWInfo</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalUpsert``4(`0@,System.Int64,``0@,`1@,``1@,``2@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3)">
            <summary>
            Upsert operation. Replaces the value corresponding to 'key' with provided 'value', if one exists 
            else inserts a new record with 'key' and 'value'.
            </summary>
            <param name="key">key of the record.</param>
            <param name="keyHash"></param>
            <param name="input">input used to update the value.</param>
            <param name="value">value to be updated to (or inserted if key does not exist).</param>
            <param name="output">output where the result of the update can be placed</param>
            <param name="userContext">User context for the operation, in case it goes pending.</param>
            <param name="pendingContext">Pending context used internally to store the context of the operation.</param>
            <param name="sessionFunctions">Callback functions.</param>
            <returns>
            <list type="table">
                <listheader>
                <term>Value</term>
                <term>Description</term>
                </listheader>
                <item>
                <term>SUCCESS</term>
                <term>The value has been successfully replaced(or inserted)</term>
                </item>
                <item>
                <term>RETRY_LATER</term>
                <term>Cannot  be processed immediately due to system state. Add to pending list and retry later</term>
                </item>
                <item>
                <term>CPR_SHIFT_DETECTED</term>
                <term>A shift in version has been detected. Synchronize immediately to avoid violating CPR consistency.</term>
                </item>
            </list>
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CreateNewRecordUpsert``4(`0@,``0@,`1@,``1@,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,``3,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@,Tsavorite.core.RecordInfo@,Tsavorite.core.UpsertInfo@)">
            <summary>
            Create a new record for Upsert
            </summary>
            <param name="key">The record Key</param>
            <param name="input">Input to the operation</param>
            <param name="value">The value to insert</param>
            <param name="output">The result of ISessionFunctions.SingleWriter</param>
            <param name="pendingContext">Information about the operation context</param>
            <param name="sessionFunctions">The current session</param>
            <param name="stackCtx">Contains the <see cref="T:Tsavorite.core.HashEntryInfo"/> and <see cref="T:Tsavorite.core.RecordSource`4"/> structures for this operation,
                and allows passing back the newLogicalAddress for invalidation in the case of exceptions.</param>
            <param name="srcRecordInfo">If <paramref name="stackCtx"/>.<see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>,
                this is the <see cref="T:Tsavorite.core.RecordInfo"/> for <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/></param>
            <param name="upsertInfo">UpsertInfo</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalModifiedBitOperation(`0@,Tsavorite.core.RecordInfo@,System.Boolean)">
            <summary>
            if reset is true it simply resets the modified bit for the key
            if reset is false it only checks whether the key is modified or not
            </summary>
            <param name="key">key of the record.</param>
            <param name="modifiedInfo">RecordInfo of the key for checkModified.</param>
            <param name="reset">Operation Type, whether it is reset or check</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TryCopyToReadCache``4(``3,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,`0@,``0@,`1@,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@)">
            <summary>
            Copy a record from the disk to the read cache.
            </summary>
            <param name="pendingContext"></param>
            <param name="key"></param>
            <param name="input"></param>
            <param name="recordValue"></param>
            <param name="stackCtx">Contains the <see cref="T:Tsavorite.core.HashEntryInfo"/> and <see cref="T:Tsavorite.core.RecordSource`4"/> structures for this operation,
                and allows passing back the newLogicalAddress for invalidation in the case of exceptions.</param>
            <param name="sessionFunctions"></param>
            <returns>True if copied to readcache, else false; readcache is "best effort", and we don't fail the read process, or slow it down by retrying.
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TryCopyToTail``4(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,`0@,``0@,`1@,``1@,Tsavorite.core.OperationStackContext{`0,`1,`2,`3}@,Tsavorite.core.RecordInfo@,``3,Tsavorite.core.WriteReason)">
            <summary>
            Copy a record from the immutable region of the log, from the disk, or from ConditionalCopyToTail to the tail of the log (or splice into the log/readcache boundary).
            </summary>
            <param name="pendingContext"></param>
            <param name="key"></param>
            <param name="input"></param>
            <param name="value"></param>
            <param name="output"></param>
            <param name="stackCtx">Contains the <see cref="T:Tsavorite.core.HashEntryInfo"/> and <see cref="T:Tsavorite.core.RecordSource`4"/> structures for this operation,
                and allows passing back the newLogicalAddress for invalidation in the case of exceptions.</param>
            <param name="srcRecordInfo">if <paramref name="stackCtx"/>.<see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>, the recordInfo to close, if transferring.</param>
            <param name="sessionFunctions"></param>
            <param name="reason">The reason for this operation.</param>
            <returns>
                <list type="bullet">
                <item>RETRY_NOW: failed CAS, so no copy done. This routine deals entirely with new records, so will not encounter Sealed records</item>
                <item>SUCCESS: copy was done</item>
                </list>
            </returns>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.EntryCount">
            <summary>
            Number of active entries in hash index (does not correspond to total records, due to hash collisions)
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.MaxAllocatedPageCount">
            <summary>
            Maximum number of memory pages ever allocated
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.IndexSize">
            <summary>
            Size of index in #cache lines (64 bytes each)
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.OverflowBucketCount">
            <summary>
            Number of overflow buckets in use (64 bytes each)
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.OverflowBucketAllocations">
            <summary>Number of allocations performed</summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.Log">
            <summary>
            Hybrid log used by this Tsavorite instance
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteKV`4.ReadCache">
            <summary>
            Read cache used by this Tsavorite instance
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.PauseRevivification">
            <summary>
            Pause Revivification
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.ResumeRevivification">
            <summary>
            Resume Revivification
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.#ctor(Tsavorite.core.KVSettings{`0,`1},`2,System.Func{Tsavorite.core.AllocatorSettings,`2,`3})">
            <summary>
            Create TsavoriteKV instance
            </summary>
            <param name="kvSettings">Config settings</param>
            <param name="storeFunctions">Store-level user function implementations</param>
            <param name="allocatorFactory">Func to call to create the allocator(s, if doing readcache)</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetKeyHash(`0)">
            <summary>Get the hashcode for a key.</summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetKeyHash(`0@)">
            <summary>Get the hashcode for a key.</summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TryInitiateFullCheckpoint(System.Guid@,Tsavorite.core.CheckpointType,Tsavorite.core.IStreamingSnapshotIteratorFunctions{`0,`1},System.Threading.CancellationToken)">
            <summary>
            Initiate full checkpoint
            </summary>
            <param name="token">Checkpoint token</param>
            <param name="checkpointType">Checkpoint type</param>
            <param name="streamingSnapshotIteratorFunctions">Iterator for streaming snapshot records</param>
            <param name="cancellationToken">Caller's cancellation token</param>
            <returns>
            Whether we successfully initiated the checkpoint (initiation may
            fail if we are already taking a checkpoint or performing some other
            operation such as growing the index). Use CompleteCheckpointAsync to wait completion.
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TakeFullCheckpointAsync(Tsavorite.core.CheckpointType,System.Threading.CancellationToken,Tsavorite.core.IStreamingSnapshotIteratorFunctions{`0,`1})">
            <summary>
            Take full (index + log) checkpoint
            </summary>
            <param name="checkpointType">Checkpoint type</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="streamingSnapshotIteratorFunctions">Iterator for streaming snapshot records</param>
            <returns>
            (bool success, Guid token)
            success: Whether we successfully initiated the checkpoint (initiation may
            fail if we are already taking a checkpoint or performing some other
            operation such as growing the index).
            token: Token for taken checkpoint
            Await task to complete checkpoint, if initiated successfully
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TryInitiateIndexCheckpoint(System.Guid@,System.Threading.CancellationToken)">
            <summary>
            Initiate index-only checkpoint
            </summary>
            <param name="token">Checkpoint token</param>
            <returns>Whether we could initiate the checkpoint. Use CompleteCheckpointAsync to wait completion.</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TakeIndexCheckpointAsync(System.Threading.CancellationToken)">
            <summary>
            Take index-only checkpoint
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>
            (bool success, Guid token)
            success: Whether we successfully initiated the checkpoint (initiation may
            fail if we are already taking a checkpoint or performing some other
            operation such as growing the index).
            token: Token for taken checkpoint
            Await task to complete checkpoint, if initiated successfully
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TryInitiateHybridLogCheckpoint(System.Guid@,Tsavorite.core.CheckpointType,System.Boolean,Tsavorite.core.IStreamingSnapshotIteratorFunctions{`0,`1},System.Threading.CancellationToken)">
            <summary>
            Initiate log-only checkpoint
            </summary>
            <param name="token">Checkpoint token</param>
            <param name="checkpointType">Checkpoint type</param>
            <param name="tryIncremental">For snapshot, try to store as incremental delta over last snapshot</param>
            <returns>Whether we could initiate the checkpoint. Use CompleteCheckpointAsync to wait completion.</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CanTakeIncrementalCheckpoint(Tsavorite.core.CheckpointType,System.Guid@)">
            <summary>
            Whether we can take an incremental snapshot checkpoint given current state of the store
            </summary>
            <param name="checkpointType"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.TakeHybridLogCheckpointAsync(Tsavorite.core.CheckpointType,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Take log-only checkpoint
            </summary>
            <param name="checkpointType">Checkpoint type</param>
            <param name="tryIncremental">For snapshot, try to store as incremental delta over last snapshot</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>
            (bool success, Guid token)
            success: Whether we successfully initiated the checkpoint (initiation may
            fail if we are already taking a checkpoint or performing some other
            operation such as growing the index).
            token: Token for taken checkpoint
            Await task to complete checkpoint, if initiated successfully
            </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Recover(System.Int32,System.Boolean,System.Int64)">
            <summary>
            Recover from the latest valid checkpoint (blocking operation)
            </summary>
            <param name="numPagesToPreload">Number of pages to preload into memory (beyond what needs to be read for recovery)</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <param name="recoverTo"> specific version requested or -1 for latest version. Tsavorite will recover to the largest version number checkpointed that's smaller than the required version. </param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetRecoverVersion(System.Int64)">
            <summary>
            Get the version we would recover to if we were to request recovery the specified version
            </summary>
            <param name="recoverTo">Specified version</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.RecoverAsync(System.Int32,System.Boolean,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously recover from the latest valid checkpoint (blocking operation)
            </summary>
            <param name="numPagesToPreload">Number of pages to preload into memory (beyond what needs to be read for recovery)</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <param name="recoverTo"> specific version requested or -1 for latest version. Tsavorite will recover to the largest version number checkpointed that's smaller than the required version.</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Recover(System.Guid,System.Int32,System.Boolean)">
            <summary>
            Recover from specific token (blocking operation)
            </summary>
            <param name="fullCheckpointToken">Token</param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.RecoverAsync(System.Guid,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Asynchronously recover from specific token (blocking operation)
            </summary>
            <param name="fullCheckpointToken">Token</param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Recover(System.Guid,System.Guid,System.Int32,System.Boolean)">
            <summary>
            Recover from specific index and log token (blocking operation)
            </summary>
            <param name="indexCheckpointToken"></param>
            <param name="hybridLogCheckpointToken"></param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.RecoverAsync(System.Guid,System.Guid,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Asynchronously recover from specific index and log token (blocking operation)
            </summary>
            <param name="indexCheckpointToken"></param>
            <param name="hybridLogCheckpointToken"></param>
            <param name="numPagesToPreload">Number of pages to preload into memory after recovery</param>
            <param name="undoNextVersion">Whether records with versions beyond checkpoint version need to be undone (and invalidated on log)</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Version we actually recovered to</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.CompleteCheckpointAsync(System.Threading.CancellationToken)">
            <summary>
            Wait for ongoing checkpoint to complete
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GrowIndexAsync">
            <summary>
            Grow the hash index by a factor of two. Caller should take a full checkpoint after growth, for persistence.
            </summary>
            <returns>Whether the grow completed successfully</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Dispose">
            <summary>
            Dispose Tsavorite instance
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.GetEntryCount">
            <summary>
            Total number of valid entries in hash table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.DumpDistribution">
            <summary>
            Dumps the distribution of each non-empty bucket in the hash table.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Iterate``4(``3,System.Int64)">
            <summary>
            Pull iterator for all (distinct) live key-values stored in Tsavorite
            </summary>
            <param name="functions">Functions used to manage key-values during iteration</param>
            <param name="untilAddress">Report records until this address (tail by default)</param>
            <returns>Tsavorite iterator</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.Iterate``5(``3,``4@,System.Int64)">
            <summary>
            Push iteration of all (distinct) live key-values stored in Tsavorite
            </summary>
            <param name="functions">Functions used to manage key-values during iteration</param>
            <param name="scanFunctions">Functions receiving pushed records</param>
            <param name="untilAddress">Report records until this address (tail by default)</param>
            <returns>Tsavorite iterator</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteKV`4.InternalCompletePendingRequestFromContext``4(``3,Tsavorite.core.AsyncIOContext{`0,`1},Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@,Tsavorite.core.AsyncIOContext{`0,`1}@)">
            <summary>
            Caller is expected to dispose pendingContext after this method completes
            </summary>
        </member>
        <member name="T:Tsavorite.core.BasicContext`8">
            <summary>
            Basic Tsavorite Context implementation.
            </summary>
        </member>
        <member name="P:Tsavorite.core.BasicContext`8.IsNull">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.UnsafeResumeThread">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.UnsafeSuspendThread">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.BasicContext`8.Session">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.GetKeyHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.GetKeyHash(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.CompletePending(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.CompletePendingAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.CompletePendingWithOutputsAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ReadWithPrefetch``1(``0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,`2,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ReadAtAddress(System.Int64,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ReadAtAddress(System.Int64,`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`1@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`1@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0,`1,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0,`1,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0,`2,`1,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Upsert(`0,`2,`1,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,System.Int64,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0,`2,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0@,`2@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0,`2,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.RMW(`0,`2,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Delete(`0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Delete(`0@,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Delete(`0@,System.Int64,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Delete(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Delete(`0,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ResetModified(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ResetModified(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.IsModified(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.Refresh">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.CompactionCopyToTail(`0@,`2@,`1@,`3@,System.Int64,System.Int64)">
            <summary>
            Copy key and value to tail, succeed only if key is known to not exist in between expectedLogicalAddress and tail.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="value"></param>
            <param name="currentAddress">LogicalAddress of the record to be copied</param>
            <param name="untilAddress">Lower-bound address (addresses are searched from tail (high) to head (low); do not search for "future records" earlier than this)</param>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ConditionalScanPush(Tsavorite.core.ScanCursorState{`0,`1},Tsavorite.core.RecordInfo,`0@,`1@,System.Int64,System.Int64,System.Int64)">
            <summary>
            Push a scan record to client if key is known to not exist in between expectedLogicalAddress and tail.
            </summary>
            <param name="scanCursorState">Scan cursor tracking state, from the session on which this scan was initiated</param>
            <param name="recordInfo"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="currentAddress">LogicalAddress of the record to be copied</param>
            <param name="untilAddress">Lower-bound address (addresses are searched from tail (high) to head (low); do not search for "future records" earlier than this)</param>
        </member>
        <member name="M:Tsavorite.core.BasicContext`8.ContainsKeyInMemory(`0@,System.Int64@,System.Int64)">
            <summary>
            Checks whether specified record is present in memory (between max(fromAddress, HeadAddress) and tail), including tombstones.
            </summary>
            <param name="key">Key of the record.</param>
            <param name="logicalAddress">Logical address of record, if found</param>
            <param name="fromAddress">Look until this address; if less than HeadAddress, then HeadAddress is used</param>
            <returns>Status</returns>
        </member>
        <member name="T:Tsavorite.core.ClientSession`8">
            <summary>
            Thread-independent session interface to Tsavorite
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.ID">
            <summary>
            Get session ID
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.Version">
            <summary>
            Current version number of the session
            </summary>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Dispose">
            <summary>
            Dispose session
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.UnsafeContext">
            <summary>
            Return a new interface to Tsavorite operations that supports manual epoch control.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.LockableUnsafeContext">
            <summary>
            Return a new interface to Tsavorite operations that supports manual locking and epoch control.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.LockableContext">
            <summary>
            Return a session wrapper that supports manual locking.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ClientSession`8.BasicContext">
            <summary>
            Return a session wrapper struct that passes through to client session
            </summary>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.GetKeyHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.GetKeyHash(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Refresh``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.ResetModified``1(``0,`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompareKeyHashes``1(``0,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompareKeyHashes``1(``0@,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.SortKeyHashes``1(System.Span{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompletePending``1(``0,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompletePendingWithOutputs``1(``0,Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.UnsafeCompletePendingWithOutputs``1(``0,Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <summary>
            Synchronously complete outstanding pending synchronous operations, returning outputs for the completed operations.
            Assumes epoch protection is managed by user. Async operations must be completed individually.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompletePendingAsync``1(``0,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.CompletePendingWithOutputsAsync``1(``0,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.ReadyToCompletePendingAsync(System.Threading.CancellationToken)">
            <summary>
            Check if at least one synchronous request is ready for CompletePending to be called on
            Returns completed immediately if there are no outstanding synchronous requests
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.ResetModified``1(``0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.IsModified``1(``0,`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.IsModified``1(``0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.WaitForCommitAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Wait for commit of all operations completed until the current point in session.
            Does not itself issue checkpoint/commits.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Compact(System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="compactUntilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Compact(`2@,`3@,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="input">Input for SingleWriter</param>
            <param name="output">Output from SingleWriter; it will be called all records that are moved, before Compact() returns, so the user must supply buffering or process each output completely</param>
            <param name="compactUntilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Compact``1(System.Int64,Tsavorite.core.CompactionType,``0)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <param name="compactionFunctions">User provided compaction functions (see <see cref="T:Tsavorite.core.ICompactionFunctions`2"/>).</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Compact``1(`2@,`3@,System.Int64,Tsavorite.core.CompactionType,``0)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="input">Input for SingleWriter</param>
            <param name="output">Output from SingleWriter; it will be called all records that are moved, before Compact() returns, so the user must supply buffering or process each output completely</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <param name="compactionFunctions">User provided compaction functions (see <see cref="T:Tsavorite.core.ICompactionFunctions`2"/>).</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Iterate(System.Int64)">
            <summary>
            Pull iterator for all (distinct) live key-values stored in Tsavorite
            </summary>
            <param name="untilAddress">Report records until this address (tail by default)</param>
            <returns>Tsavorite iterator</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.Iterate``1(``0@,System.Int64)">
            <summary>
            Push iteration of all (distinct) live key-values stored in Tsavorite, using a temporary TsavoriteKV to ensure uniqueness
            </summary>
            <param name="scanFunctions">Functions receiving pushed records</param>
            <param name="untilAddress">Report records until this address (tail by default)</param>
            <returns>True if Iteration completed; false if Iteration ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.IterateLookup``1(``0@,System.Int64@,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Push iteration of all (distinct) live key-values stored in Tsavorite, using a lookup strategy to ensure uniqueness
            </summary>
            <param name="scanFunctions">Functions receiving pushed records</param>
            <param name="untilAddress">Report records until this address (tail by default)</param>
            <param name="cursor">Cursor to scan from</param>
            <param name="validateCursor">Cursor to scan from</param>
            <param name="maxAddress">Max address to search for keys when conditionally pushing</param>
            <param name="resetCursor">Whether to reset cursor at the end of the iteration</param>
            <param name="includeTombstones">Whether to include tombstoned record when iterating</param>
            <returns>True if Iteration completed; false if Iteration ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.ScanCursor``1(System.Int64@,System.Int64,``0,System.Int64,System.Boolean,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Push-scan the log from <paramref name="cursor"/> (which should be a valid address) and push up to <paramref name="count"/> records
            to the caller via <paramref name="scanFunctions"/> for each Key that is not found at a higher address.
            </summary>
            <param name="cursor">The cursor of the scan. If 0, start at BeginAddress, else this should be the value this was updated with on the previous call,
                which is the next address to return. If this is some other value, then for variable length records it must be validated by iterating from the 
                start of the page, and iteration will start from the first valid logical address &lt;= this value. This is expensive.</param>
            <param name="count">The number of records to push.</param>
            <param name="scanFunctions">Caller functions called to push records. For this variant of Scan, this is not a ref param, because it will likely be copied through
                the pending IO process.</param>
            <param name="endAddress">A specific end address; otherwise we scan until we hit the current TailAddress, which may yield duplicates in the event of RCUs.
                This may be set to the TailAddress at the start of the scan, which may lose records that are RCU'd during the scan (because they are moved above the starting
                TailAddress). A snapshot can be taken by calling ShiftReadOnlyToTail() and then using that TailAddress as endAddress and maxAddress.</param>
            <param name="validateCursor">If true, validate that the cursor is on a valid address boundary, and snap it to the highest lower address if it is not.</param>
            <param name="maxAddress">Maximum address for determining liveness, records after this address are not considered when checking validity.</param>
            <param name="resetCursor">Whether to set cursor to zero at the end of iteration.</param>
            <param name="includeTombstones">Whether to include tombstoned records while iterating.</param>
            <returns>True if Scan completed and pushed <paramref name="count"/> records and there may be more records; false if Scan ended early due to finding less than <paramref name="count"/> records
            or one of the TScanIterator reader functions returning false, or if we determined that there are no records remaining. In other words, if this returns true,
            there may be more records satisfying the iteration criteria beyond <paramref name="count"/>.</returns>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.UnsafeResumeThread``1(``0)">
            <summary>
            Resume session on current thread. IMPORTANT: Call SuspendThread before any async op.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.UnsafeSuspendThread">
            <summary>
            Suspend session on current thread
            </summary>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.MergeRevivificationStatsTo(Tsavorite.core.RevivificationStats@,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ClientSession`8.ResetRevivificationStats">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.ILockableContext`1">
            <summary>
            Lockable context functions. Useful when doing generic locking across diverse 
            <see cref="T:Tsavorite.core.LockableUnsafeContext`8"/> and 
            <see cref="T:Tsavorite.core.LockableContext`8"/> specializations.
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.BeginLockable">
            <summary>
            Begins a series of lock operations on possibly multiple keys; call before any locks are taken.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.LocksAcquired(System.Int64)">
            <summary>
            Call after all locks are acquired. Provide transaction version
            acquired from StateMachineDriver.AcquireTransactionVersion().
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.EndLockable">
            <summary>
            Ends a series of lock operations on possibly multiple keys; call after all locks are released.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.CompareKeyHashes``1(``0,``0)">
            <summary>
            Compare two structures that implement ILockableKey.
            </summary>
            <typeparam name="TLockableKey">The type of the app data struct or class containing key info</typeparam>
            <param name="key1">The first key to compare</param>
            <param name="key2">The first key to compare</param>
            <returns>The result of key1.CompareTo(key2)</returns>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.CompareKeyHashes``1(``0@,``0@)">
            <summary>
            Compare two structures that implement ILockableKey.
            </summary>
            <typeparam name="TLockableKey">The type of the app data struct or class containing key info</typeparam>
            <param name="key1">The first key to compare</param>
            <param name="key2">The first key to compare</param>
            <returns>The result of key1.CompareTo(key2)</returns>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})">
            <summary>
            Sort an array of app data structures (or classes) by lock code and lock type; these will be passed to Lockable*Session.Lock
            </summary>
            <typeparam name="TLockableKey">The type of the app data struct or class containing key info</typeparam>
            <param name="keys">The array of app key data </param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.Lock``1(System.ReadOnlySpan{``0})">
            <summary>
            Locks the keys identified in the passed array.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">keys to be locked, and whether that locking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryLock``1(System.ReadOnlySpan{``0})">
            <summary>
            Locks the keys identified in the passed array, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">keys to be locked, and whether that locking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan)">
            <summary>
            Locks the keys identified in the passed array, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">keys to be locked, and whether that locking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
            <param name="timeout">TimeSpan limiting the duration of the TryLock() call over all keys.</param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryLock``1(System.ReadOnlySpan{``0},System.Threading.CancellationToken)">
            <summary>
            Locks the keys identified in the passed array, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">keys to be locked, and whether that locking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
            <param name="cancellationToken">The cancellation token</param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Locks the keys identified in the passed array, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">keys to be locked, and whether that locking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
            <param name="timeout">TimeSpan limiting the duration of the TryLock() call over all keys.</param>
            <param name="cancellationToken">The cancellation token</param>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryPromoteLock``1(``0)">
            <summary>
            Tries to promote a shared lock the key to an exclusive lock, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="key">key whose lock is to be promoted.</param>
            <remarks>On success, the caller must update the ILockableKey.LockType so the unlock has the right type</remarks>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryPromoteLock``1(``0,System.Threading.CancellationToken)">
            <summary>
            Promotes a shared lock on the key to an exclusive lock, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="key">key whose lock is to be promoted.</param>
            <param name="cancellationToken">The cancellation token</param>
            <remarks>On success, the caller must update the ILockableKey.LockType so the unlock has the right type</remarks>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.TryPromoteLock``1(``0,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Promotes a shared lock on the key to an exclusive lock, with retry limits or cancellation.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="key">key whose lock is to be promoted.</param>
            <param name="timeout">TimeSpan limiting the duration of the TryPromoteLock() call.</param>
            <param name="cancellationToken">The cancellation token, if any</param>
            <remarks>On success, the caller must update the ILockableKey.LockType so the unlock has the right type</remarks>
        </member>
        <member name="M:Tsavorite.core.ILockableContext`1.Unlock``1(System.ReadOnlySpan{``0})">
            <summary>
            Unlocks the keys identified in the passed array.
            </summary>
            <typeparam name="TLockableKey"></typeparam>
            <param name="keys">key hashCodes to be unlocked, and whether that unlocking is shared or exclusive; must be sorted by <see cref="M:Tsavorite.core.ILockableContext`1.SortKeyHashes``1(System.Span{``0})"/>.</param>
        </member>
        <member name="T:Tsavorite.core.ITsavoriteContext`1">
            <summary>
            Interface for Key-only Tsavorite operations
            </summary>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`1.GetKeyHash(`0)">
            <summary>
            Obtain a code by which groups of keys will be sorted for manual locking, to avoid deadlocks.
            <param name="key">The key to obtain a code for</param>
            </summary>
            <returns>The hashcode of the key; created and returned by <see cref="M:Tsavorite.core.IKeyComparer`1.GetHashCode64(`0@)"/></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`1.GetKeyHash(`0@)">
            <summary>
            Obtain a code by which groups of keys will be sorted for manual locking, to avoid deadlocks.
            <param name="key">The key to obtain a code for</param>
            </summary>
            <returns>The hashcode of the key; created and returned by <see cref="M:Tsavorite.core.IKeyComparer`1.GetHashCode64(`0@)"/></returns>
        </member>
        <member name="T:Tsavorite.core.ITsavoriteContext`8">
            <summary>
            Interface for Tsavorite operations
            </summary>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteContext`8.IsNull">
            <summary>
            Indicates whether this context has been initialized.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ITsavoriteContext`8.Session">
            <summary>
            Obtain the underlying <see cref="T:Tsavorite.core.ClientSession`8"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.CompletePending(System.Boolean,System.Boolean)">
            <summary>
            Synchronously complete outstanding pending synchronous operations.
            Async operations must be completed individually.
            </summary>
            <param name="wait">Wait for all pending operations on session to complete</param>
            <param name="spinWaitForCommit">Spin-wait until ongoing commit/checkpoint, if any, completes</param>
            <returns>True if all pending operations have completed, false otherwise</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <summary>
            Synchronously complete outstanding pending synchronous operations, returning outputs for the completed operations.
            Async operations must be completed individually.
            </summary>
            <param name="completedOutputs">Outputs completed by this operation</param>
            <param name="wait">Wait for all pending operations on session to complete</param>
            <param name="spinWaitForCommit">Spin-wait until ongoing commit/checkpoint, if any, completes</param>
            <returns>True if all pending operations have completed, false otherwise</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.CompletePendingAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Complete all pending synchronous Tsavorite operations.
            Async operations must be completed individually.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.CompletePendingWithOutputsAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Complete all pending synchronous Tsavorite operations, returning outputs for the completed operations.
            Async operations must be completed individually.
            </summary>
            <returns>Outputs completed by this operation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0@,`2@,`3@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,`2,`3@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,`2,`3@,Tsavorite.core.ReadOptions@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0@,`3@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="output">The location to place the retrieved value</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key">The key to look up</param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,`3@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key"></param>
            <param name="output"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,`3@,Tsavorite.core.ReadOptions@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key"></param>
            <param name="output"></param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0,Tsavorite.core.ReadOptions@,`4)">
            <summary>
            Read operation
            </summary>
            <param name="key"></param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            Read operation that accepts a <paramref name="recordMetadata"/> ref argument to start the lookup at instead of starting at the hash table entry for <paramref name="key"/>,
                and is updated with the address and record header for the found record.
            </summary>
            <param name="key">The key to look up</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation</param>
            <param name="recordMetadata">On output, receives:
                    <list type="bullet">
                        <li>The address of the found record. This may be different from the <paramref name="recordMetadata.RecordInfo.PreviousAddress.RecordInfo.PreviousAddress"/> passed on the call, due to
                            tracing back over hash collisions until we arrive at the key match</li>
                        <li>A copy of the record's header in <paramref name="recordMetadata.RecordInfo.RecordInfo"/>; <paramref name="recordMetadata.RecordInfo.PreviousAddress.RecordInfo.PreviousAddress"/> can be passed
                            in a subsequent call, thereby enumerating all records in a key's hash chain.</li>
                    </list>
            </param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.ReadAtAddress(System.Int64,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            Read operation that accepts an address to lookup at, instead of a key.
            </summary>
            <param name="address">The logical address to read</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation, including the address to read at in StartAddress</param>
            <param name="recordMetadata">On output, receives metadata about the record</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation; this should store the key if it needs it</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.ReadAtAddress(System.Int64,`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            Read operation that accepts an address to lookup at, and a key to optimize locking.
            </summary>
            <param name="address">The logical address to read</param>
            <param name="key">The key of the record to read, to optimize locking</param>
            <param name="input">Input to help extract the retrieved value into <paramref name="output"/></param>
            <param name="output">The location to place the retrieved value</param>
            <param name="readOptions">Contains options controlling the Read operation, including the address to read at in StartAddress</param>
            <param name="recordMetadata">On output, receives metadata about the record</param>
            <param name="userContext">User application context passed in case the read goes pending due to IO</param>
            <returns><paramref name="output"/> is populated by the <see cref="T:Tsavorite.core.ISessionFunctions`3"/> implementation; this should store the key if it needs it</returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.ReadWithPrefetch``1(``0@,`4)">
            <summary>
            Read batch operation, which attempts to prefetch as an optimization.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`1@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="desiredValue"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`1@,Tsavorite.core.UpsertOptions@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="desiredValue"></param>
            <param name="upsertOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`2@,`1@,`3@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="upsertOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="recordMetadata"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="upsertOptions"></param>
            <param name="recordMetadata"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0,`1,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="desiredValue"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0,`1,Tsavorite.core.UpsertOptions@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="desiredValue"></param>
            <param name="upsertOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0,`2,`1,`3@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Upsert(`0,`2,`1,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <summary>
            Upsert operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="desiredValue"></param>
            <param name="output"></param>
            <param name="upsertOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,`3@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="rmwOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="recordMetadata"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="rmwOptions"></param>
            <param name="recordMetadata"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0,`2,`3@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0,`2,`3@,Tsavorite.core.RMWOptions@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="rmwOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0@,`2@,Tsavorite.core.RMWOptions@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="rmwOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0,`2,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.RMW(`0,`2,Tsavorite.core.RMWOptions@,`4)">
            <summary>
            RMW operation
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="rmwOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Delete(`0@,`4)">
            <summary>
            Delete operation
            </summary>
            <param name="key"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Delete(`0@,Tsavorite.core.DeleteOptions@,`4)">
            <summary>
            Delete operation
            </summary>
            <param name="key"></param>
            <param name="deleteOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Delete(`0,`4)">
            <summary>
            Delete operation
            </summary>
            <param name="key"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Delete(`0,Tsavorite.core.DeleteOptions@,`4)">
            <summary>
            Delete operation
            </summary>
            <param name="key"></param>
            <param name="deleteOptions"></param>
            <param name="userContext"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.ResetModified(`0@)">
            <summary>
            Reset the modified bit of a record (for in memory records)
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Tsavorite.core.ITsavoriteContext`8.Refresh">
            <summary>
            Refresh session epoch and handle checkpointing phases. Used only
            in case of thread-affinitized sessions (async support is disabled).
            </summary>
        </member>
        <member name="T:Tsavorite.core.IUnsafeContext">
            <summary>
            Manual epoch control functions. Useful when doing generic operations across diverse 
            <see cref="T:Tsavorite.core.LockableUnsafeContext`8"/> and
            <see cref="T:Tsavorite.core.UnsafeContext`8"/> specializations.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IUnsafeContext.BeginUnsafe">
            <summary>
            Resume session on current thread. IMPORTANT: Call <see cref="M:Tsavorite.core.IUnsafeContext.EndUnsafe"/> before any async op.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IUnsafeContext.EndUnsafe">
            <summary>
            Suspend session on current thread
            </summary>
        </member>
        <member name="T:Tsavorite.core.LockableContext`8">
            <summary>
            Tsavorite Context implementation that allows manual control of record locking and epoch management. For advanced use only.
            </summary>
        </member>
        <member name="P:Tsavorite.core.LockableContext`8.IsNull">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.BeginLockable">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.LocksAcquired(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.EndLockable">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompareKeyHashes``1(``0,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompareKeyHashes``1(``0@,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.SortKeyHashes``1(System.Span{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Lock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryLock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryLock``1(System.ReadOnlySpan{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryPromoteLock``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryPromoteLock``1(``0,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryPromoteLock``1(``0,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.TryPromoteLock``1(``0,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Unlock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.LockableContext`8.SessionID">
            <summary>
            The id of the current Tsavorite Session
            </summary>
        </member>
        <member name="P:Tsavorite.core.LockableContext`8.Session">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.GetKeyHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.GetKeyHash(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompletePending(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompletePendingAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.CompletePendingWithOutputsAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,`2,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.ReadWithPrefetch``1(``0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.ReadAtAddress(System.Int64,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.ReadAtAddress(System.Int64,`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`1@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`1@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0,`1,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0,`1,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0,`2,`1,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Upsert(`0,`2,`1,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,System.Int64,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0,`2,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0@,`2@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0,`2,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.RMW(`0,`2,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Delete(`0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Delete(`0@,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Delete(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Delete(`0,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.ResetModified(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.IsModified(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableContext`8.Refresh">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.LockableUnsafeContext`8">
            <summary>
            Tsavorite Context implementation that allows manual control of record locking and epoch management. For advanced use only.
            </summary>
        </member>
        <member name="P:Tsavorite.core.LockableUnsafeContext`8.IsNull">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.BeginUnsafe">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.EndUnsafe">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.BeginLockable">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.LocksAcquired(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.EndLockable">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompareKeyHashes``1(``0,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompareKeyHashes``1(``0@,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.SortKeyHashes``1(System.Span{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Lock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryLock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryLock``1(System.ReadOnlySpan{``0},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryLock``1(System.ReadOnlySpan{``0},System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryPromoteLock``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryPromoteLock``1(``0,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryPromoteLock``1(``0,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.TryPromoteLock``1(``0,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Unlock``1(System.ReadOnlySpan{``0})">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.LockableUnsafeContext`8.SessionID">
            <summary>
            The id of the current Tsavorite Session
            </summary>
        </member>
        <member name="P:Tsavorite.core.LockableUnsafeContext`8.Session">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.GetKeyHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.GetKeyHash(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompletePending(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompletePendingAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.CompletePendingWithOutputsAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,`2,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.ReadWithPrefetch``1(``0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.ReadAtAddress(System.Int64,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.ReadAtAddress(System.Int64,`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`1@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`1@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0,`1,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0,`1,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0,`2,`1,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Upsert(`0,`2,`1,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,System.Int64,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0,`2,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0@,`2@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0,`2,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.RMW(`0,`2,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Delete(`0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Delete(`0@,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Delete(`0@,System.Int64,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Delete(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Delete(`0,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.ResetModified(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.IsModified(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LockableUnsafeContext`8.Refresh">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsWrapper`9.ConvertOutputToHeap(`2@,`3@)">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.UnsafeContext`8">
            <summary>
            Tsavorite Operations implementation that allows manual control of record epoch management. For advanced use only.
            </summary>
        </member>
        <member name="P:Tsavorite.core.UnsafeContext`8.IsNull">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.BeginUnsafe">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.EndUnsafe">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.UnsafeContext`8.Session">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.GetKeyHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.GetKeyHash(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.CompletePending(System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.CompletePendingAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.CompletePendingWithOutputsAsync(System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,`2,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0@,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,`3@,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0,Tsavorite.core.ReadOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Read(`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.ReadWithPrefetch``1(``0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.ReadAtAddress(System.Int64,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.ReadAtAddress(System.Int64,`0@,`2@,`3@,Tsavorite.core.ReadOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`1@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`1@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,`2@,`1@,`3@,Tsavorite.core.UpsertOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0@,System.Int64,`2@,`1@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0,`1,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0,`1,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0,`2,`1,`3@,Tsavorite.core.UpsertOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Upsert(`0,`2,`1,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,`3@,Tsavorite.core.RMWOptions@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,System.Int64,`2@,`3@,Tsavorite.core.RecordMetadata@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0,`2,`3@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0,`2,`3@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0@,`2@,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0,`2,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.RMW(`0,`2,Tsavorite.core.RMWOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Delete(`0@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Delete(`0@,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Delete(`0@,System.Int64,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Delete(`0,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Delete(`0,Tsavorite.core.DeleteOptions@,`4)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.ResetModified(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.IsModified(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.UnsafeContext`8.Refresh">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.CompactionType">
            <summary>
            Type of log compaction
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompactionType.Scan">
            <summary>
            Scan from untilAddress to read-only address to check for record liveness checking
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompactionType.Lookup">
            <summary>
            Lookup each record in compaction range, for record liveness checking using hash chain
            </summary>
        </member>
        <member name="T:Tsavorite.core.ICompactionFunctions`2">
            <summary>
            Optional functions to be called during compaction.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Tsavorite.core.ICompactionFunctions`2.IsDeleted(`0@,`1@)">
            <summary>
            Checks if record in the Tsavorite log is logically deleted.
            If the record was deleted via <see cref="M:Tsavorite.core.BasicContext`8.Delete(`0@,`4)"/>
            then this function is not called for such a record.
            </summary>
            <remarks>
            <para>
            One possible scenario is if Tsavorite is used to store reference counted records.
            Once the record count reaches zero it can be considered to be no longer relevant and 
            compaction can skip the record.
            </para>
            </remarks>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LogCompactionFunctions`6.ConcurrentReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            No reads during compaction
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogCompactionFunctions`6.ConcurrentDeleter(`0@,`1@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            No ConcurrentDeleter needed for compaction
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogCompactionFunctions`6.ConcurrentWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            For compaction, we never perform concurrent writes as rolled over data defers to
            newly inserted data for the same key.
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogCompactionFunctions`6.SingleReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@)">
            <summary>
            No reads during compaction
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogCompactionFunctions`6.SingleWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <summary>
            Write compacted live value to store
            </summary>
        </member>
        <member name="T:Tsavorite.core.AsyncPool`1">
            <summary>
            Asynchronous pool of fixed pre-filled capacity
            Supports sync get (TryGet) for fast path
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.#ctor(System.Int32,System.Func{`0})">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
            <param name="creator"></param>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.Get(System.Threading.CancellationToken)">
            <summary>
            Get item synchronously
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.GetAsync(System.Threading.CancellationToken)">
            <summary>
            Get item asynchronously
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.TryGet(`0@)">
            <summary>
            Try get item (fast path)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.Return(`0)">
            <summary>
            Return item to pool
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncPool`1.GetOrAdd(System.Collections.Concurrent.ConcurrentQueue{`0},`0@)">
            <summary>
            Get item from queue, adding up to pool-size items if necessary
            </summary>
        </member>
        <member name="T:Tsavorite.core.Devices">
            <summary>
            Factory to create Tsavorite objects
            </summary>
        </member>
        <member name="F:Tsavorite.core.Devices.CAPACITY_UNSPECIFIED">
            <summary>
            This value is supplied for capacity when the device does not have a specified limit.
            </summary>
        </member>
        <member name="M:Tsavorite.core.Devices.CreateLogDevice(System.String,Tsavorite.core.DeviceType,System.Boolean,System.Boolean,System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create a storage device for the log
            </summary>
            <param name="logPath">Path to file that will store the log (empty for null device)</param>
            <param name="deviceType">Device type</param>
            <param name="preallocateFile">Whether we try to pre-allocate the file on creation</param>
            <param name="deleteOnClose">Delete files on close</param>
            <param name="capacity">The maximal number of bytes this storage device can accommodate, or CAPACITY_UNSPECIFIED if there is no such limit</param>
            <param name="recoverDevice">Whether to recover device metadata from existing files</param>
            <param name="useIoCompletionPort">Whether we use IO completion port with polling</param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="readOnly">Open file in readOnly mode</param>
            <param name="logger"></param>
            <returns>Device instance</returns>
        </member>
        <member name="M:Tsavorite.core.Devices.GetDefaultDeviceType">
            <summary>
            Get default device type for the current platform
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.DeviceType">
            <summary>
            Type of device
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.Default">
            <summary>
            Let the system choose the device type for the current platform. This is the default.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.Native">
            <summary>
            Use Native device if available for the current platform.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.RandomAccess">
            <summary>
            Use device based on .NET RandomAccess (this is the default on non-Windows).
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.FileStream">
            <summary>
            Use device based on .NET FileStream.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.AzureStorage">
            <summary>
            Use device based on Azure Storage. You need to provide the Azure Storage configuration separately.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceType.Null">
            <summary>
            Use null device.
            </summary>
        </member>
        <member name="T:Tsavorite.core.DeviceIOCompletionCallback">
            <summary>
            Delegate for callback on IO completion
            </summary>
            <param name="errorCode"></param>
            <param name="numBytes"></param>
            <param name="context"></param>
        </member>
        <member name="T:Tsavorite.core.IDevice">
            <summary>
            Interface for devices
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.SectorSize">
            <summary>
            Size of sector
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.FileName">
            <summary>
            Name of device
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.Capacity">
            <summary>
            Returns the maximum capacity of the storage device, in number of bytes. 
            If returned CAPACITY_UNSPECIFIED, the storage device has no specfied capacity limit. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.SegmentSize">
            <summary>
            A device breaks up each logical log into multiple self-contained segments that are of the same size.
            It is an atomic unit of data that cannot be partially present on a device (i.e. either the entire segment
            is present or no data from the segment is present). Examples of this include files or named blobs. This
            property returns the size of each segment.
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.StartSegment">
            <summary>
            The index of the first segment present on this device
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.EndSegment">
            <summary>
            The index of the last segment present on this device
            </summary>
        </member>
        <member name="P:Tsavorite.core.IDevice.ThrottleLimit">
            <summary>
            Throttle limit (max number of pending I/Os) for this device instance. Device needs
            to implement Throttle() in order to use this limit.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IDevice.Initialize(System.Int64,Tsavorite.core.LightEpoch,System.Boolean)">
            <summary>
            Initialize device. This function is used to pass optional information that may only be known after
            Tsavorite initialization (whose constructor takes in IDevice upfront). Implementation are free to ignore
            information if it does not need the supplied information. Segment size of -1 is used for object log.
            
            This is a bit of a hack. 
            </summary>
            <param name="segmentSize"></param>
            <param name="epoch">
            <param name="omitSegmentIdFromFilename"></param>
            The instance of the epoch protection framework to use, if needed
            </param>
        </member>
        <member name="M:Tsavorite.core.IDevice.TryComplete">
            <summary>
            Try complete async IO completions
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.IDevice.Throttle">
            <summary>
            Whether device should be throttled at this instant (i.e., caller should stop issuing new I/Os)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.IDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Write
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.IDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Read
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.IDevice.WriteAsync(System.IntPtr,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Write
            </summary>
            <param name="alignedSourceAddress"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.IDevice.ReadAsync(System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Read
            </summary>
            <param name="alignedSourceAddress"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="aligned_read_length"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.IDevice.TruncateUntilAddressAsync(System.Int64,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            Truncates the log until the given address. The truncated portion should no longer be accessed as the device is no longer responsible for 
            its maintenance, but physical deletion may not happen immediately.
            </summary>
            <param name="toAddress">upper bound of truncated address</param>
            <param name="callback">callback to invoke when truncation is complete</param>
            <param name="result">result to be passed to the callback</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.TruncateUntilAddress(System.Int64)">
            <summary>
            Truncates the log until the given address. The truncated portion should no longer be accessed as the device is no longer responsible for 
            its maintenance, but physical deletion may not happen immediately. This version of the function can block.
            </summary>
            <param name="toAddress">upper bound of truncated address</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.TruncateUntilSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            Truncates the log until the given segment. Physical deletion of the given segments are guaranteed to have happened when the callback is invoked.
            </summary>
            <param name="toSegment">the largest (in index) segment to truncate</param>
            <param name="callback">callback to invoke when truncation is complete</param>
            <param name="result">result to be passed to the callback</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.TruncateUntilSegment(System.Int32)">
            <summary>
            Truncates the log until the given segment. Physical deletion of the given segments are guaranteed to have happened when the function returns.
            This version of the function can block.
            </summary>
            <param name="toSegment">the largest (in index) segment to truncate</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            Removes a single segment from the device. This function should not normally be called.
            Instead, use <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddressAsync(System.Int64,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment">index of the segment to remov</param>
            <param name="callback">callback to invoke when removal is complete</param>
            <param name="result">result to be passed to the callback</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)">
            <summary>
            Removes a single segment from the device. This function should not normally be called.
            Instead, use <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddressAsync(System.Int64,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment">index of the segment to remov</param>
        </member>
        <member name="M:Tsavorite.core.IDevice.GetFileSize(System.Int32)">
            <summary>
            Get file size for given segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.IDevice.Reset">
            <summary>
            Reset the device (close and forget open handles)
            </summary>
        </member>
        <member name="T:Tsavorite.core.Device">
            <summary>
            Extension for backward compatibility
            </summary>
        </member>
        <member name="M:Tsavorite.core.Device.Close(Tsavorite.core.IDevice)">
            <summary>
            Close log - use IDevice.Dispose instead
            </summary>
            <param name="device"></param>
        </member>
        <member name="T:Tsavorite.core.LocalMemoryDevice">
            <summary>
            Local storage device
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.#ctor(System.Int64,System.Int64,System.Int32,System.Int32,System.UInt32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">The maximum number of bytes this storage device can accommondate, or CAPACITY_UNSPECIFIED if there is no such limit </param>
            <param name="sz_segment">The size of each segment</param>
            <param name="parallelism">Number of IO processing threads</param>
            <param name="latencyMs">Induced callback latency in ms (for testing purposes)</param>
            <param name="sector_size">Sector size for device (default 64)</param>
            <param name="fileName">Virtual path for the device</param>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.LocalMemoryDevice.Dispose">
            <summary>
            Close device
            </summary>
        </member>
        <member name="T:Tsavorite.core.LocalStorageDevice">
            <summary>
            Local storage device
            </summary>
        </member>
        <member name="F:Tsavorite.core.LocalStorageDevice.UsePrivileges">
            <summary>
            Whether we use process and volume privilege calls to set file size in Windows.
            Speeds up disk writes, but may have scalability issues on cloud VMs if many devices
            are concurrently created.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LocalStorageDevice.NumCompletionThreads">
            <summary>
            Number of IO completion threads dedicated to this instance. Used only
            if useIoCompletionPort is set to true.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LocalStorageDevice.numPending">
            <summary>
            Number of pending reads on device
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="filename">File name (or prefix) with path</param>
            <param name="preallocateFile"></param>
            <param name="deleteOnClose"></param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="capacity">The maximum number of bytes this storage device can accommodate, or CAPACITY_UNSPECIFIED if there is no such limit </param>
            <param name="recoverDevice">Whether to recover device metadata from existing files</param>
            <param name="useIoCompletionPort">Whether we use IO completion port with polling</param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.Throttle">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Boolean,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Int32,Microsoft.Win32.SafeHandles.SafeFileHandle}},System.Boolean,System.Boolean)">
            <summary>
            Constructor with more options for derived classes
            </summary>
            <param name="filename">File name (or prefix) with path</param>
            <param name="preallocateFile"></param>
            <param name="deleteOnClose"></param>
            <param name="disableFileBuffering"></param>
            <param name="capacity">The maximum number of bytes this storage device can accommodate, or CAPACITY_UNSPECIFIED if there is no such limit </param>
            <param name="recoverDevice">Whether to recover device metadata from existing files</param>
            <param name="initialLogFileHandles">Optional set of preloaded safe file handles, which can speed up hydration of preexisting log file handles</param>
            <param name="useIoCompletionPort">Whether we use IO completion port with polling</param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.Reset">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Async read
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.Dispose">
            <summary>
            Close device
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.TryComplete">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.GetFileSize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.CreateHandle(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.String,System.IntPtr,System.Boolean,System.Boolean)">
            <summary>
            Creates a SafeFileHandle for the specified segment. This can be used by derived classes to prepopulate logHandles in the constructor.
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.GetSegmentName(System.Int32)">
             <summary>
            
             </summary>
             <param name="segmentId"></param>
             <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.GetOrAddHandle(System.Int32)">
            <summary>
            
            </summary>
            <param name="_segmentId"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LocalStorageDevice.SetFileSize(System.String,Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64)">
            Sets file size to the specified value.
            Does not reset file seek pointer to original location.
        </member>
        <member name="T:Tsavorite.core.ManagedLocalStorageDevice">
            <summary>
            Managed device using .NET streams
            </summary>
        </member>
        <member name="F:Tsavorite.core.ManagedLocalStorageDevice.numPending">
            <summary>
            Number of pending reads on device
            </summary>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="filename">File name (or prefix) with path</param>
            <param name="preallocateFile"></param>
            <param name="deleteOnClose"></param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="capacity">The maximal number of bytes this storage device can accommondate, or CAPACITY_UNSPECIFIED if there is no such limit</param>
            <param name="recoverDevice">Whether to recover device metadata from existing files</param>
            <param name="osReadBuffering">Enable OS read buffering</param>
            <param name="readOnly">Open file in readOnly mode</param>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.Reset">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.Throttle">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Read async
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.GetFileSize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.Dispose">
            <summary>
            Close device
            </summary>
        </member>
        <member name="M:Tsavorite.core.ManagedLocalStorageDevice.SetFileSize(System.IO.Stream,System.Int64)">
            <summary>
            Sets file size to the specified value.
            Does not reset file seek pointer to original location.
            </summary>
            <param name="logHandle"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.NativeStorageDevice">
            <summary>
            Native version of local storage device
            </summary>
        </member>
        <member name="F:Tsavorite.core.NativeStorageDevice.numPending">
            <summary>
            Number of pending reads on device
            </summary>
        </member>
        <member name="T:Tsavorite.core.NativeStorageDevice.AsyncIOCallback">
            <summary>
            Async callback delegate
            </summary>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.Throttle">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.#ctor(System.String,System.Boolean,System.Boolean,System.Int64,System.Int32,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor with more options for derived classes
            </summary>
            <param name="filename">File name (or prefix) with path</param>
            <param name="deleteOnClose"></param>
            <param name="disableFileBuffering"></param>
            <param name="capacity">The maximum number of bytes this storage device can accommodate, or CAPACITY_UNSPECIFIED if there is no such limit </param>
            <param name="numCompletionThreads">Number of IO completion threads</param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.Initialize(System.Int64,Tsavorite.core.LightEpoch,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.Reset">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.Dispose">
            <summary>
            Close device
            </summary>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.TryComplete">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.GetFileSize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.NativeStorageDevice.GetSegmentName(System.Int32)">
             <summary>
            
             </summary>
             <param name="segmentId"></param>
             <returns></returns>
        </member>
        <member name="T:Tsavorite.core.NullDevice">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tsavorite.core.NullDevice.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tsavorite.core.NullDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="segmentId"></param>
            <param name="alignedSourceAddress"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="aligned_read_length"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.NullDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="alignedSourceAddress"></param>
            <param name="segmentId"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.NullDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.NullDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.NullDevice.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.RandomAccessLocalStorageDevice">
            <summary>
            Managed device using .NET streams
            </summary>
        </member>
        <member name="F:Tsavorite.core.RandomAccessLocalStorageDevice.numPending">
            <summary>
            Number of pending reads on device
            </summary>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="filename">File name (or prefix) with path</param>
            <param name="preallocateFile"></param>
            <param name="deleteOnClose"></param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="capacity">The maximal number of bytes this storage device can accommodate, or CAPACITY_UNSPECIFIED if there is no such limit</param>
            <param name="recoverDevice">Whether to recover device metadata from existing files</param>
            <param name="osReadBuffering">Enable OS read buffering</param>
            <param name="readOnly">Open file in readOnly mode</param>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.Reset">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.Throttle">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Read async
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.GetFileSize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.Dispose">
            <summary>
            Close device
            </summary>
        </member>
        <member name="M:Tsavorite.core.RandomAccessLocalStorageDevice.SetFileSize(System.IO.Stream,System.Int64)">
            <summary>
            Sets file size to the specified value.
            Does not reset file seek pointer to original location.
            </summary>
            <param name="logHandle"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.IPartitionScheme">
            <summary>
            Interface that encapsulates a sharding strategy that is used by <see cref="T:Tsavorite.core.ShardedStorageDevice"/>. This
            allows users to customize their sharding behaviors. Some default implementations are supplied for common
            partitioning schemes.
            </summary>
        </member>
        <member name="P:Tsavorite.core.IPartitionScheme.Devices">
            <summary>
            A list of <see cref="T:Tsavorite.core.IDevice"/> that represents the shards. Indexes into this list will be
            used as unique identifiers for the shards.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IPartitionScheme.MapRange(System.Int64,System.Int64,System.Int32@,System.Int64@,System.Int64@)">
            <summary>
            Maps a range in the unified logical address space into a contiguous physical chunk on a shard's address space.
            Because the given range may be sharded across multiple devices, only the largest contiguous chunk starting from
            start address but smaller than end address is returned in shard, shardStartAddress, and shardEndAddress.
            </summary>
            <param name="startAddress">start address of the range to map in the logical address space</param>
            <param name="endAddress">end address of the range to map in the logical address space</param>
            <param name="shard"> the shard (potentially part of) the given range resides in, given as index into <see cref="P:Tsavorite.core.IPartitionScheme.Devices"/></param>
            <param name="shardStartAddress"> start address translated into physical start address on the returned shard </param>
            <param name="shardEndAddress">
            physical address of the end of the part of the range on the returned shard. This is not necessarily a translation of the end address
            given, as the tail of the range maybe on (a) different device(s).
            </param>
            <returns>
            the logical address translated from the returned shardEndAddress. If this is not equal to the given end address, the caller is
            expected to repeatedly call this method using the returned value as the new startAddress until the entire original range is
            covered.
            </returns>
        </member>
        <member name="M:Tsavorite.core.IPartitionScheme.MapSectorSize(System.Int64,System.Int32)">
            <summary>
            Maps the sector size of a composed device into sector sizes for each shard
            </summary>
            <param name="sectorSize">sector size of the composed device</param>
            <param name="shard">the shard</param>
            <returns>sector size on shard</returns>
        </member>
        <member name="T:Tsavorite.core.UniformPartitionScheme">
            <summary>
            Uniformly shards data across given devices.
            </summary>
        </member>
        <member name="M:Tsavorite.core.UniformPartitionScheme.#ctor(System.Int64,System.Collections.Generic.IList{Tsavorite.core.IDevice})">
            <summary>
            Constructs a UniformPartitionScheme to shard data uniformly across given devices. Suppose we have 3 devices and the following logical write:
            [chunk 1][chunk 2][chunk 3][chunk 4]...
            chunk 1 is written on device 0, 2 on device 1, 3 on device 2, 4 on device 0, etc.
            </summary>
            <param name="chunkSize">size of each chunk</param>
            <param name="devices">the devices to compose from</param>
        </member>
        <member name="M:Tsavorite.core.UniformPartitionScheme.#ctor(System.Int64,Tsavorite.core.IDevice[])">
            <summary>
            vararg version of <see cref="M:Tsavorite.core.UniformPartitionScheme.#ctor(System.Int64,System.Collections.Generic.IList{Tsavorite.core.IDevice})"/>
            </summary>
            <param name="chunkSize"></param>
            <param name="devices"></param>
        </member>
        <member name="M:Tsavorite.core.UniformPartitionScheme.MapRange(System.Int64,System.Int64,System.Int32@,System.Int64@,System.Int64@)">
            <summary>
            <see cref="M:Tsavorite.core.IPartitionScheme.MapRange(System.Int64,System.Int64,System.Int32@,System.Int64@,System.Int64@)"/>
            </summary>
            <param name="startAddress"></param>
            <param name="endAddress"></param>
            <param name="shard"></param>
            <param name="shardStartAddress"></param>
            <param name="shardEndAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.UniformPartitionScheme.MapSectorSize(System.Int64,System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IPartitionScheme.MapSectorSize(System.Int64,System.Int32)"/>
            </summary>
            <param name="sectorSize"></param>
            <param name="shard"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.ShardedStorageDevice">
            <summary>
            A <see cref="T:Tsavorite.core.ShardedStorageDevice"/> logically composes multiple <see cref="T:Tsavorite.core.IDevice"/> into a single storage device
            by sharding writes into different devices according to a supplied <see cref="T:Tsavorite.core.IPartitionScheme"/>. The goal is to be
            able to issue large reads and writes in parallel into multiple devices and improve throughput. Beware that this
            code does not contain error detection or correction mechanism to cope with increased failure from more devices.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.#ctor(Tsavorite.core.IPartitionScheme)">
            <summary>
            Constructs a new ShardedStorageDevice with the given partition scheme
            </summary>
            <param name="partitions"> The parition scheme to use </param>
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.Initialize(System.Int64,Tsavorite.core.LightEpoch,System.Boolean)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.Initialize(System.Int64,Tsavorite.core.LightEpoch,System.Boolean)"/>
            </summary>
            <param name="segmentSize"></param>
            <param name="epoch"></param>
            <param name="omitSegmentIdFromFilename"></param>
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)"/>
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.ShardedStorageDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)"/>
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="T:Tsavorite.core.StorageDeviceBase">
            <summary>
            
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.SectorSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.FileName">
            <summary>
            
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.Capacity">
            <summary>
            <see cref="P:Tsavorite.core.IDevice.Capacity"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.StartSegment">
            <summary>
            <see cref="P:Tsavorite.core.IDevice.StartSegment"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.EndSegment">
            <summary>
            <see cref="P:Tsavorite.core.IDevice.EndSegment"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.SegmentSize">
            <summary>
            <see cref="P:Tsavorite.core.IDevice.SegmentSize"/>
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.segmentSize">
            <summary>
            Segment size
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.segmentSizeBits">
            <summary>
            Segment size in bits
            </summary>
        </member>
        <member name="P:Tsavorite.core.StorageDeviceBase.ThrottleLimit">
            <summary>
            Throttle limit (max number of pending I/Os) for this device instance
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.epoch">
            <summary>
            Instance of the epoch protection framework in the current system.
            A device may have internal in-memory data structure that requires epoch protection under concurrent access.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.startSegment">
            <summary>
            start and end segment corresponding to <see cref="P:Tsavorite.core.StorageDeviceBase.StartSegment"/> and <see cref="P:Tsavorite.core.StorageDeviceBase.EndSegment"/>. Subclasses are
            allowed to modify these as needed.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.endSegment">
            <summary>
            start and end segment corresponding to <see cref="P:Tsavorite.core.StorageDeviceBase.StartSegment"/> and <see cref="P:Tsavorite.core.StorageDeviceBase.EndSegment"/>. Subclasses are
            allowed to modify these as needed.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StorageDeviceBase.OmitSegmentIdFromFileName">
            <summary>
            If true, skip adding the segmentId to the filename.
            </summary>
            <remarks>If true, SegmentSize must be -1</remarks>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.#ctor(System.String,System.UInt32,System.Int64,System.Boolean)">
            <summary>
            Initializes a new StorageDeviceBase
            </summary>
            <param name="filename">Name of the file to use</param>
            <param name="sectorSize">The smallest unit of write of the underlying storage device (e.g. 512 bytes for a disk) </param>
            <param name="capacity">The maximal number of bytes this storage device can accommodate, or CAPAPCITY_UNSPECIFIED if there is no such limit </param>
            <param name="readOnly">Open file in readOnly mode </param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.Initialize(System.Int64,Tsavorite.core.LightEpoch,System.Boolean)">
            <summary>
            Initialize device
            </summary>
            <param name="segmentSize"></param>
            <param name="epoch"></param>
            <param name="omitSegmentIdFromFilename"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.GetSegmentFilename(System.String,System.Int32)">
            <summary>
            Create a filename that may or may not include the segmentId
            </summary>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.GetSegmentFilename(System.String,System.Int32,System.Boolean)">
            <summary>
            Create a filename that may or may not include the segmentId
            </summary>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.Throttle">
            <summary>
            Whether device should be throttled
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.WriteAsync(System.IntPtr,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Write operation
            </summary>
            <param name="alignedSourceAddress"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.ReadAsync(System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            Read operation
            </summary>
            <param name="alignedSourceAddress"></param>
            <param name="alignedDestinationAddress"></param>
            <param name="aligned_read_length"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.RemoveSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.RemoveSegment(System.Int32)"/>
            By default the implementation calls into <see cref="M:Tsavorite.core.StorageDeviceBase.RemoveSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.TruncateUntilSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.TruncateUntilSegmentAsync(System.Int32,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="toSegment"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.TruncateUntilSegment(System.Int32)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.TruncateUntilSegment(System.Int32)"/>
            </summary>
            <param name="toSegment"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.TruncateUntilAddressAsync(System.Int64,System.AsyncCallback,System.IAsyncResult)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddressAsync(System.Int64,System.AsyncCallback,System.IAsyncResult)"/>
            </summary>
            <param name="toAddress"></param>
            <param name="callback"></param>
            <param name="result"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.TruncateUntilAddress(System.Int64)">
            <summary>
            <see cref="M:Tsavorite.core.IDevice.TruncateUntilAddress(System.Int64)"/>
            </summary>
            <param name="toAddress"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="sourceAddress"></param>
            <param name="segmentId"></param>
            <param name="destinationAddress"></param>
            <param name="numBytesToWrite"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.ReadAsync(System.Int32,System.UInt64,System.IntPtr,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)">
            <summary>
            
            </summary>
            <param name="segmentId"></param>
            <param name="sourceAddress"></param>
            <param name="destinationAddress"></param>
            <param name="readLength"></param>
            <param name="callback"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.HandleCapacity(System.Int32)">
            <summary>
            Handle space utilization of limited capacity devices by invoking segment truncation if necessary
            </summary>
            <param name="segment">Segment being written to</param>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.TryComplete">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.GetFileSize(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StorageDeviceBase.Reset">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.TieredStorageDevice">
            <summary>
            A <see cref="T:Tsavorite.core.TieredStorageDevice"/> logically composes multiple <see cref="T:Tsavorite.core.IDevice"/> into a single storage device. It is assumed
            that some <see cref="T:Tsavorite.core.IDevice"/> are used as caches while there is one that is considered the commit point, i.e. when a write is completed
            on the device, it is considered persistent. Reads are served from the closest device with available data. Writes are issued in parallel to
            all devices 
            </summary>
        </member>
        <member name="M:Tsavorite.core.TieredStorageDevice.#ctor(System.Int32,System.Collections.Generic.IList{Tsavorite.core.IDevice})">
            <summary>
            Constructs a new TieredStorageDevice composed of the given devices.
            </summary>
            <param name="commitPoint">
            The index of an <see cref="T:Tsavorite.core.IDevice">IDevice</see> in <see cref="F:Tsavorite.core.TieredStorageDevice.devices"/>. When a write has been completed on the device,
            the write is considered persistent. It is guaranteed that the callback in <see cref="M:Tsavorite.core.TieredStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)"/>
            will not be called until the write is completed on the commit point device.
            </param>
            <param name="devices">
            List of devices to be used. The list should be given in order of hot to cold. Read is served from the
            device with smallest index in the list that has the requested data
            </param>
        </member>
        <member name="M:Tsavorite.core.TieredStorageDevice.#ctor(System.Int32,Tsavorite.core.IDevice[])">
            <summary>
            Constructs a new TieredStorageDevice composed of the given devices.
            </summary>
            <param name="commitPoint">
            The index of an <see cref="T:Tsavorite.core.IDevice">IDevice</see> in <see cref="F:Tsavorite.core.TieredStorageDevice.devices">devices</see>. When a write has been completed on the device,
            the write is considered persistent. It is guaranteed that the callback in <see cref="M:Tsavorite.core.TieredStorageDevice.WriteAsync(System.IntPtr,System.Int32,System.UInt64,System.UInt32,Tsavorite.core.DeviceIOCompletionCallback,System.Object)"/>
            will not be called until the write is completed on commit point device and all previous tiers.
            </param>
            <param name="devices">
            List of devices to be used. The list should be given in order of hot to cold. Read is served from the
            device with smallest index in the list that has the requested data
            </param>
        </member>
        <member name="T:Tsavorite.core.LightEpoch">
            <summary>
            Epoch protection
            </summary>
        </member>
        <member name="T:Tsavorite.core.LightEpoch.Metadata">
            <summary>
            Store thread-static metadata separately from the LightEpoch class because LightEpoch has a static ctor,
            and this inhibits optimization of the .NET helper function that determines the base address of the static variables.
            This is expensive as it goes through multiple lookups, so lift these into a class that does not have a static ctor.
            TODO: This should be fixed in .NET 8; verify this and remove the Metadata class code when we no longer support pre-NET.8.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Metadata.threadId">
            <summary>
            Managed thread id of this thread
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Metadata.startOffset1">
            <summary>
            Start offset to reserve entry in the epoch table
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Metadata.startOffset2">
            <summary>
            Alternate start offset to reserve entry in the epoch table (to reduce probing if <see cref="F:Tsavorite.core.LightEpoch.Metadata.startOffset1"/> slot is already filled)
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Metadata.threadEntryIndex">
            <summary>
            A thread's entry in the epoch table.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Metadata.threadEntryIndexCount">
            <summary>
            Number of instances using this entry
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.kCacheLineBytes">
            <summary>
            Size of cache line in bytes
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.kInvalidIndex">
            <summary>
            Default invalid index entry.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.kTableSize">
            <summary>
            Default number of entries in the entries table
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.kDrainListSize">
            <summary>
            Default drainlist size
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.tableRaw">
            <summary>
            Thread protection status entries.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.drainCount">
            <summary>
            List of action, epoch pairs containing actions to be performed when an epoch becomes safe to reclaim.
            Marked volatile to ensure latest value is seen by the last suspended thread.
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.CurrentEpoch">
            <summary>
            Global current epoch value
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.SafeToReclaimEpoch">
            <summary>
            Cached value of latest epoch that is safe to reclaim
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.#cctor">
            <summary>
            Static constructor to setup shared cache-aligned space
            to store per-entry count of instances using that entry
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.#ctor">
            <summary>
            Instantiate the epoch table
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Dispose">
            <summary>
            Clean up epoch table
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ThisInstanceProtected">
            <summary>
            Check whether current epoch instance is protected on this thread
            </summary>
            <returns>Result of the check</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ReleaseIfHeld">
            <summary>
            Release epoch if held
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ProtectAndDrain">
            <summary>
            Enter the thread into the protected code region
            </summary>
            <returns>Current epoch</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Suspend">
            <summary>
            Thread suspends its epoch entry
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Resume">
            <summary>
            Thread resumes its epoch entry
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.BumpCurrentEpoch">
            <summary>
            Increment global current epoch
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.BumpCurrentEpoch(System.Action)">
            <summary>
            Increment current epoch and associate trigger action
            with the prior epoch
            </summary>
            <param name="onDrain">Trigger action</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ComputeNewSafeToReclaimEpoch">
            <summary>
            Looks at all threads and return the latest safe epoch
            </summary>
            <returns>Safe epoch</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ComputeNewSafeToReclaimEpoch(System.Int64)">
            <summary>
            Looks at all threads and return the latest safe epoch
            </summary>
            <param name="currentEpoch">Current epoch</param>
            <returns>Safe epoch</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.SuspendDrain">
            <summary>
            Take care of pending drains after epoch suspend
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Drain(System.Int64)">
            <summary>
            Check and invoke trigger actions that are ready
            </summary>
            <param name="nextEpoch">Next epoch</param>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Acquire">
            <summary>
            Thread acquires its epoch entry
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.Release">
            <summary>
            Thread releases its epoch entry
            </summary>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ReserveEntry">
            <summary>
            Reserve entry for thread. This method relies on the fact that no
            thread will ever have ID 0.
            </summary>
            <returns>Reserved entry</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ReserveEntryForThread">
            <summary>
            Allocate a new entry in epoch table. This is called 
            once for a thread.
            </summary>
            <returns>Reserved entry</returns>
        </member>
        <member name="M:Tsavorite.core.LightEpoch.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.LightEpoch.Entry">
            <summary>
            Epoch table entry (cache line size).
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Entry.localCurrentEpoch">
            <summary>
            Thread-local value of epoch
            </summary>
        </member>
        <member name="F:Tsavorite.core.LightEpoch.Entry.threadId">
            <summary>
            ID of thread associated with this entry.
            </summary>
        </member>
        <member name="T:Tsavorite.core.LightEpoch.EpochActionPair">
            <summary>
            Pair of epoch and action to be executed
            </summary>
        </member>
        <member name="T:Tsavorite.core.FoldOverSMTask`4">
            <summary>
            A FoldOver checkpoint persists a version by setting the read-only marker past the last entry of that
            version on the log and waiting until it is flushed to disk. It is simple and fast, but can result
            in garbage entries on the log, and a slower recovery of performance.
            </summary>
        </member>
        <member name="M:Tsavorite.core.FoldOverSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.FullCheckpointSM">
            <summary>
            The state machine orchestrates a full checkpoint
            </summary>
        </member>
        <member name="M:Tsavorite.core.FullCheckpointSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Construct a new FullCheckpointStateMachine to use the given set of checkpoint tasks.
            </summary>
            <param name="tasks">Tasks</param>
        </member>
        <member name="M:Tsavorite.core.FullCheckpointSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.HybridLogCheckpointSM">
            <summary>
            Hybrid log checkpoint state machine.
            </summary>
        </member>
        <member name="M:Tsavorite.core.HybridLogCheckpointSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Construct a new HybridLogCheckpointStateMachine with the given tasks. Does not load any tasks by default.
            </summary>
            <param name="tasks">The tasks to load onto the state machine</param>
        </member>
        <member name="M:Tsavorite.core.HybridLogCheckpointSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.HybridLogCheckpointSMTask`4">
            <summary>
            This task is the base class for a checkpoint "backend", which decides how a captured version is
            persisted on disk.
            </summary>
        </member>
        <member name="M:Tsavorite.core.HybridLogCheckpointSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.HybridLogCheckpointSMTask`4.GlobalAfterEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IncrementalSnapshotCheckpointSMTask`4">
            <summary>
            A Incremental Snapshot makes a copy of only changes that have happened since the last full Snapshot. It is
            slower and more complex than a foldover, but more space-efficient on the log, and retains in-place
            update performance as it does not advance the readonly marker unnecessarily.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IncrementalSnapshotCheckpointSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IndexCheckpointSM">
            <summary>
            This state machine performs an index checkpoint
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexCheckpointSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Create a new IndexSnapshotStateMachine
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexCheckpointSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IndexCheckpointSMTask`4">
            <summary>
            This task performs an index checkpoint.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexCheckpointSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.IndexCheckpointSMTask`4.GlobalAfterEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IndexResizeSM">
            <summary>
            Resizes the index
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexResizeSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Constructs a new IndexResizeStateMachine
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexResizeSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IndexResizeSMTask`4">
            <summary>
            Resizes an index
            </summary>
        </member>
        <member name="M:Tsavorite.core.IndexResizeSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.IndexResizeSMTask`4.GlobalAfterEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IStateMachine">
            <summary>
            State machine API
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStateMachine.NextState(Tsavorite.core.SystemState)">
            <summary>
            Returns the next state given the current state
            </summary>
            <param name="currentState">Current state</param>
            <returns>Next state</returns>
        </member>
        <member name="T:Tsavorite.core.IStateMachineCallback">
            <summary>
            Encapsulates custom logic to be executed as part of Tsavorite's state machine logic
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStateMachineCallback.BeforeEnteringState(Tsavorite.core.SystemState)">
            <summary>
            Invoked immediately before every state transition.
            </summary>
        </member>
        <member name="T:Tsavorite.core.IStateMachineTask">
            <summary>
            Interface for tasks that are executed as part of the state machine
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStateMachineTask.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <summary>
            Called before we move to nextState. All participant threads will be in previousState.
            </summary>
            <param name="nextState"></param>
            <param name="stateMachineDriver"></param>
        </member>
        <member name="M:Tsavorite.core.IStateMachineTask.GlobalAfterEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <summary>
            Called after we move to nextState. All participant threads will be in nextState.
            </summary>
            <param name="nextState"></param>
            <param name="stateMachineDriver"></param>
        </member>
        <member name="T:Tsavorite.core.SnapshotCheckpointSMTask`4">
            <summary>
            A Snapshot persists a version by making a copy for every entry of that version separate from the log. It is
            slower and more complex than a foldover, but more space-efficient on the log, and retains in-place
            update performance as it does not advance the readonly marker unnecessarily.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SnapshotCheckpointSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.StateMachineBase">
            <summary>
            Abstract base class for IStateMachine that implements that state machine logic
            with IStateMachineTasks
            </summary>
        </member>
        <member name="M:Tsavorite.core.StateMachineBase.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Construct a new SynchronizationStateMachine with the given tasks. The order of tasks given is the
            order they are executed on each state machine.
            </summary>
            <param name="tasks">The ISynchronizationTasks to run on the state machine</param>
        </member>
        <member name="M:Tsavorite.core.StateMachineBase.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.StateMachineBase.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.StateMachineBase.GlobalAfterEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.StateMachineDriver">
            <summary>
            Driver for the state machine. This class is responsible for executing the state machine.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.AcquireTransactionVersion">
            <summary>
            Acquire a transaction version - this should be called before
            BeginLockable is called for all sessions in the transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.VerifyTransactionVersion(System.Int64)">
            <summary>
            Verify transaction version - this should be called after
            all locks have been acquired for the transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.EndTransaction(System.Int64)">
            <summary>
            End transaction running in specified version. Should be called
            after EndLockable() is called for all relevant sessions.
            </summary>
            <param name="txnVersion">Transaction version</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.UnsafeRegisterCallback(Tsavorite.core.IStateMachineCallback)">
            <summary>
            Registers the given callback to be invoked for every state machine transition. Not safe to call with
            concurrent Tsavorite operations. Excessive synchronization or expensive computation in the callback 
            may slow or halt state machine execution. For advanced users only.
            </summary>
            <param name="callback"> callback to register </param>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.GlobalStateMachineStep(Tsavorite.core.SystemState)">
            <summary>
            Steps the global state machine. This will change the current global system state and perform some actions
            as prescribed by the current state machine. This function has no effect if the current state is not
            the given expected state.
            </summary>
            <param name="expectedState">expected current global state</param>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.WaitForStateChange(Tsavorite.core.SystemState)">
            <summary>
            Wait for the state machine to change state out of currentState.
            </summary>
            <param name="currentState"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.StateMachineDriver.WaitForCompletion(Tsavorite.core.SystemState)">
            <summary>
            Wait for all thread participants to complete currentState.
            </summary>
            <param name="currentState"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.Phase">
            <summary>
            The current phase of a state-machine operation such as a checkpoint
            </summary>
        </member>
        <member name="F:Tsavorite.core.Phase.IN_PROGRESS">
            <summary>In-progress phase, entering (v+1) version</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.WAIT_INDEX_CHECKPOINT">
            <summary>Wait for an index checkpoint flush to finish</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.WAIT_FLUSH">
            <summary>Wait for hybrid log flush to complete</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.PERSISTENCE_CALLBACK">
            <summary>After flush has completed, write metadata to persistent storage and issue user callbacks</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.REST">
            <summary>The default phase; no state-machine operation is operating</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.PREPARE">
            <summary>Prepare for a checkpoint, still in (v) version</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.PREPARE_GROW">
            <summary>Prepare to resize the index</summary>
        </member>
        <member name="F:Tsavorite.core.Phase.IN_PROGRESS_GROW">
            <summary>Index resizing is in progress</summary>
        </member>
        <member name="T:Tsavorite.core.SystemState">
            <summary>
            The current state of a state-machine operation such as a checkpoint.
            </summary>
        </member>
        <member name="F:Tsavorite.core.SystemState.Word">
            <summary>
            The word containing information in bitfields
            </summary>
        </member>
        <member name="P:Tsavorite.core.SystemState.Phase">
            <summary>
            The current <see cref="P:Tsavorite.core.SystemState.Phase"/> of the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.SystemState.Version">
            <summary>
            The version of the database when this operation is complete
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.Copy(Tsavorite.core.SystemState@)">
            <summary>
            Copy the <paramref name="other"/> <see cref="T:Tsavorite.core.SystemState"/> into this <see cref="T:Tsavorite.core.SystemState"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.Make(Tsavorite.core.Phase,System.Int64)">
            <summary>
            Create a <see cref="T:Tsavorite.core.SystemState"/> with the specified values
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.Equal(Tsavorite.core.SystemState,Tsavorite.core.SystemState)">
            <summary>
            Compare two <see cref="T:Tsavorite.core.SystemState"/>s for equality
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SystemState.Equals(System.Object)">
            <summary>
            Compare the current <see cref="T:Tsavorite.core.SystemState"/> to <paramref name="obj"/> for equality if obj is also a <see cref="T:Tsavorite.core.SystemState"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SystemState.Equals(Tsavorite.core.SystemState)">
            <summary>
            Compare the current <see cref="T:Tsavorite.core.SystemState"/> to <paramref name="other"/> for equality
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.op_Equality(Tsavorite.core.SystemState,Tsavorite.core.SystemState)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Tsavorite.core.SystemState.op_Inequality(Tsavorite.core.SystemState,Tsavorite.core.SystemState)">
            <summary>
            Not Equals
            </summary>
        </member>
        <member name="T:Tsavorite.core.StreamingSnapshotCheckpointSM">
            <summary>
            StreamingSnapshot checkpoint state machine.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StreamingSnapshotCheckpointSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Construct a new StreamingSnapshotCheckpointStateMachine.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StreamingSnapshotCheckpointSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.StreamingSnapshotCheckpointSMTask`4">
            <summary>
            A Streaming Snapshot persists a version by yielding a stream of key-value pairs that correspond to
            a consistent snapshot of the database, for the old version (v). Unlike Snapshot, StreamingSnapshot
            is designed to not require tail growth even during the WAIT_FLUSH phase of checkpointing. Further,
            it does not require a snapshot of the index. Recovery is achieved by replaying the yielded log 
            of key-value pairs and inserting each record into an empty database.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StreamingSnapshotCheckpointSMTask`4.GlobalBeforeEnteringState(Tsavorite.core.SystemState,Tsavorite.core.StateMachineDriver)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.VersionChangeSM">
            <summary>
            A VersionChangeStateMachine orchestrates to capture a version, but does not flush to disk.
            </summary>
        </member>
        <member name="M:Tsavorite.core.VersionChangeSM.#ctor(Tsavorite.core.IStateMachineTask[])">
            <summary>
            Construct a new VersionChangeStateMachine with the given tasks. Does not load any tasks by default.
            </summary>
            <param name="tasks">The tasks to load onto the state machine</param>
        </member>
        <member name="M:Tsavorite.core.VersionChangeSM.NextState(Tsavorite.core.SystemState)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.DefaultCheckpointNamingScheme">
            <summary>
            Default checkpoint naming scheme used by Tsavorite
            </summary>
        </member>
        <member name="P:Tsavorite.core.DefaultCheckpointNamingScheme.BaseName">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.#ctor(System.String)">
            <summary>
            Create instance of default naming scheme
            </summary>
            <param name="baseName">Overall location specifier (e.g., local path or cloud container name)</param>
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.LogCheckpointBase(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.LogCheckpointMetadata(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.LogSnapshot(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.ObjectLogSnapshot(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.DeltaLog(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.IndexCheckpointBase(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.IndexCheckpointMetadata(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.HashTable(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.TsavoriteLogCommitMetadata(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.Token(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultCheckpointNamingScheme.CommitNumber(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="P:Tsavorite.core.DefaultCheckpointNamingScheme.IndexCheckpointBasePath">
            <inheritdoc />
        </member>
        <member name="P:Tsavorite.core.DefaultCheckpointNamingScheme.LogCheckpointBasePath">
            <inheritdoc />
        </member>
        <member name="P:Tsavorite.core.DefaultCheckpointNamingScheme.TsavoriteLogCommitBasePath">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.DeviceLogCommitCheckpointManager">
            <summary>
            Log commit manager for a generic IDevice
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceLogCommitCheckpointManager.deviceFactory">
            <summary>
            deviceFactory
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceLogCommitCheckpointManager.checkpointNamingScheme">
            <summary>
            checkpointNamingScheme
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceLogCommitCheckpointManager.indexTokenHistory">
            <summary>
            Track historical commits for automatic purging
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeviceLogCommitCheckpointManager.logTokenHistory">
            <summary>
            Track historical commits for automatic purging
            </summary>
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.#ctor(Tsavorite.core.INamedDeviceFactoryCreator,Tsavorite.core.ICheckpointNamingScheme,System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new instance of log commit manager
            </summary>
            <param name="deviceFactoryCreator">Factory for getting devices</param>
            <param name="checkpointNamingScheme">Checkpoint naming helper</param>
            <param name="removeOutdated">Remote older Tsavorite log commits</param>
            <param name="fastCommitThrottleFreq">FastCommit throttle frequency - use only in FastCommit mode</param>
            <param name="logger">Remote older Tsavorite log commits</param>
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.PurgeAll">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.Purge(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.Commit(System.Int64,System.Int64,System.Byte[],System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.ListCommits">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.RemoveCommit(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.RemoveAllCommits">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetCommitMetadata(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetCookie">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CommitIndexCheckpoint(System.Guid,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CleanupIndexCheckpoint(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetIndexCheckpointTokens">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetIndexCheckpointMetadata(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CommitLogCheckpointMetadata(System.Guid,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CleanupLogCheckpoint(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CommitLogIncrementalCheckpoint(System.Guid,System.Byte[],Tsavorite.core.DeltaLog)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CleanupLogIncrementalCheckpoint(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetLogCheckpointTokens">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetLogCheckpointMetadata(System.Guid,Tsavorite.core.DeltaLog,System.Boolean,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetIndexDevice(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetSnapshotLogDevice(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetSnapshotObjectLogDevice(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.GetDeltaLogDevice(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.InitializeIndexCheckpoint(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.InitializeLogCheckpoint(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.OnRecovery(System.Guid,System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.OnRecovery(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.ReadInto(Tsavorite.core.IDevice,System.UInt64,System.Byte[]@,System.Int32)">
            <summary>
            Note: will read potentially more data (based on sector alignment)
            </summary>
            <param name="device"></param>
            <param name="address"></param>
            <param name="buffer"></param>
            <param name="size"></param>
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.WriteInto(Tsavorite.core.IDevice,System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Note: pads the bytes with zeros to achieve sector alignment
            </summary>
            <param name="device"></param>
            <param name="address"></param>
            <param name="buffer"></param>
            <param name="size"></param>
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CheckpointVersionShiftStart(System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeviceLogCommitCheckpointManager.CheckpointVersionShiftEnd(System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.ICheckpointNamingScheme">
            <summary>
            Interface to provide paths and names for all checkpoint-related files
            </summary>
        </member>
        <member name="P:Tsavorite.core.ICheckpointNamingScheme.BaseName">
            <summary>
            Base (or container) name for all checkpoint files
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.HashTable(System.Guid)">
            <summary>
            Hash table (including overflow buckets)
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.IndexCheckpointBase(System.Guid)">
            <summary>
            Index checkpoint base location (directory)
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.IndexCheckpointMetadata(System.Guid)">
            <summary>
            Index checkpoint metadata
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.LogCheckpointBase(System.Guid)">
            <summary>
            Hybrid log checkpoint base location (directory)
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.LogCheckpointMetadata(System.Guid)">
            <summary>
            Hybrid log checkpoint metadata
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.LogSnapshot(System.Guid)">
            <summary>
            Hybrid log snapshot
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.ObjectLogSnapshot(System.Guid)">
            <summary>
            Object log snapshot
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.DeltaLog(System.Guid)">
            <summary>
            Delta log
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.TsavoriteLogCommitMetadata(System.Int64)">
            <summary>
            TsavoriteLog commit metadata
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.Token(Tsavorite.core.FileDescriptor)">
            <summary>
            Token associated with given file descriptor
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointNamingScheme.CommitNumber(Tsavorite.core.FileDescriptor)">
            <summary>
            Commit number associated with given file descriptor
            </summary>
        </member>
        <member name="P:Tsavorite.core.ICheckpointNamingScheme.IndexCheckpointBasePath">
            <summary>
            Get base path holding index checkpoints
            </summary>
        </member>
        <member name="P:Tsavorite.core.ICheckpointNamingScheme.LogCheckpointBasePath">
            <summary>
            Get base path holding log checkpoints
            </summary>
        </member>
        <member name="P:Tsavorite.core.ICheckpointNamingScheme.TsavoriteLogCommitBasePath">
            <summary>
            Get base path holding TsavoriteLog commits
            </summary>
        </member>
        <member name="T:Tsavorite.core.INamedDeviceFactory">
            <summary>
            Factory for getting IDevice instances for checkpointing. The factory is specific to a particular base path or container.
            </summary>
        </member>
        <member name="M:Tsavorite.core.INamedDeviceFactory.Get(Tsavorite.core.FileDescriptor)">
            <summary>
            Get IDevice instance for given file info
            </summary>
            <param name="fileInfo">File info</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.INamedDeviceFactory.Delete(Tsavorite.core.FileDescriptor)">
            <summary>
            Delete IDevice for given file info
            </summary>
            <param name="fileInfo">File info</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.INamedDeviceFactory.ListContents(System.String)">
            <summary>
            List path contents, in order of preference
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.INamedDeviceFactoryCreator">
            <summary>
            Factory creator for getting IDevice instances for checkpointing
            </summary>
        </member>
        <member name="M:Tsavorite.core.INamedDeviceFactoryCreator.Create(System.String)">
            <summary>
            Create factory for creating IDevice instances, for the given base name or container
            </summary>
            <param name="baseName">Base name or container</param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.LocalStorageNamedDeviceFactory">
            <summary>
            Local storage device factory
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalStorageNamedDeviceFactory.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Nullable{System.Int32},Tsavorite.core.DeviceType,System.Boolean,System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create instance of factory
            </summary>
            <param name="preallocateFile">Whether files should be preallocated</param>
            <param name="deleteOnClose">Whether file should be deleted on close</param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="throttleLimit">Throttle limit (max number of pending I/Os) for this device instance</param>
            <param name="deviceType">Device type to use</param>
            <param name="readOnly">Whether files are opened as readonly</param>
            <param name="baseName">Base name</param>
            <param name="logger">Logger</param>
        </member>
        <member name="M:Tsavorite.core.LocalStorageNamedDeviceFactory.Get(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.LocalStorageNamedDeviceFactory.ListContents(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.LocalStorageNamedDeviceFactory.Delete(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.LocalStorageNamedDeviceFactoryCreator">
            <summary>
            Local storage named device factory creator
            </summary>
        </member>
        <member name="M:Tsavorite.core.LocalStorageNamedDeviceFactoryCreator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Nullable{System.Int32},Tsavorite.core.DeviceType,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create instance of factory
            </summary>
            <param name="preallocateFile">Whether files should be preallocated</param>
            <param name="deleteOnClose">Whether file should be deleted on close</param>
            <param name="disableFileBuffering">Whether file buffering (during write) is disabled (default of true requires aligned writes)</param>
            <param name="throttleLimit">Throttle limit (max number of pending I/Os) for this device instance</param>
            <param name="deviceType">Device type</param>
            <param name="readOnly">Whether files are opened as readonly</param>
            <param name="logger">Logger</param>
        </member>
        <member name="T:Tsavorite.core.NullNamedDeviceFactory">
            <summary>
            Null device factory
            </summary>
        </member>
        <member name="M:Tsavorite.core.NullNamedDeviceFactory.#ctor">
            <summary>
            Create instance of factory
            </summary>
        </member>
        <member name="M:Tsavorite.core.NullNamedDeviceFactory.Delete(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NullNamedDeviceFactory.Get(Tsavorite.core.FileDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NullNamedDeviceFactory.Initialize(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.NullNamedDeviceFactory.ListContents(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.NullNamedDeviceFactoryCreator">
            <summary>
            Creator of factory for getting null device instances
            </summary>
        </member>
        <member name="T:Tsavorite.core.HybridLogRecoveryInfo">
            <summary>
            Recovery info for hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.hybridLogRecoveryVersion">
            <summary>
            HybridLogRecoveryVersion 
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.guid">
            <summary>
            Guid
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.useSnapshotFile">
            <summary>
            Use snapshot file
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.version">
            <summary>
            Version
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.nextVersion">
            <summary>
            Next Version
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.flushedLogicalAddress">
            <summary>
            Flushed logical address; indicates the latest immutable address on the main Tsavorite log at checkpoint commit time.
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.snapshotStartFlushedLogicalAddress">
            <summary>
            Flushed logical address at snapshot start; indicates device offset for snapshot file
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.startLogicalAddress">
            <summary>
            Start logical address
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.finalLogicalAddress">
            <summary>
            Final logical address
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.snapshotFinalLogicalAddress">
            <summary>
            Snapshot end logical address: snapshot is [startLogicalAddress, snapshotFinalLogicalAddress)
            Note that finalLogicalAddress may be higher due to delta records
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.headAddress">
            <summary>
            Head address
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.beginAddress">
            <summary>
            Begin address
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.placeholder">
            <summary>
            Placeholder to avoid checkpoint format change
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.objectLogSegmentOffsets">
            <summary>
            Object log segment offsets
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.deltaTailAddress">
            <summary>
            Tail address of delta file: -1 indicates this is not a delta checkpoint metadata
            At recovery, this value denotes the delta tail address excluding the metadata record for the checkpoint
            because we create the metadata before writing to the delta file.
            </summary>
        </member>
        <member name="F:Tsavorite.core.HybridLogRecoveryInfo.cookie">
            <summary>
            User cookie
            </summary>
        </member>
        <member name="P:Tsavorite.core.HybridLogRecoveryInfo.Deserialized">
            <summary>
            If struct deserialized succesfully
            </summary>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.Initialize(System.Guid,System.Int64)">
            <summary>
            Initialize
            </summary>
            <param name="token"></param>
            <param name="_version"></param>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.Initialize(System.IO.StreamReader)">
            <summary>
            Initialize from stream
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.Recover(System.Guid,Tsavorite.core.ICheckpointManager,Tsavorite.core.DeltaLog,System.Boolean,System.Int64)">
            <summary>
             Recover info from token
            </summary>
            <param name="token"></param>
            <param name="checkpointManager"></param>
            <param name="deltaLog"></param>
            <param name = "scanDelta">
            whether to scan the delta log to obtain the latest info contained in an incremental snapshot checkpoint.
            If false, this will recover the base snapshot info but avoid potentially expensive scans.
            </param>
            <param name="recoverTo"> specific version to recover to, if using delta log</param>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.Recover(System.Guid,Tsavorite.core.ICheckpointManager,System.Byte[]@,Tsavorite.core.DeltaLog,System.Boolean,System.Int64)">
            <summary>
             Recover info from token
            </summary>
            <param name="token"></param>
            <param name="checkpointManager"></param>
            <param name="deltaLog"></param>
            <param name="commitCookie"> Any user-specified commit cookie written as part of the checkpoint </param>
            <param name = "scanDelta">
            whether to scan the delta log to obtain the latest info contained in an incremental snapshot checkpoint.
            If false, this will recover the base snapshot info but avoid potentially expensive scans.
            </param>
            <param name="recoverTo"> specific version to recover to, if using delta log</param>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.ToByteArray">
            <summary>
            Write info to byte array
            </summary>
        </member>
        <member name="M:Tsavorite.core.HybridLogRecoveryInfo.DebugPrint(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Print checkpoint info for debugging purposes
            </summary>
        </member>
        <member name="T:Tsavorite.core.AddressInfo">
            <summary>
            AddressInfo struct
            </summary>
        </member>
        <member name="T:Tsavorite.core.CheckpointType">
            <summary>
            Checkpoint type
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointType.Snapshot">
            <summary>
            Take separate snapshot of in-memory portion of log (default)
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointType.FoldOver">
            <summary>
            Flush current log (move read-only to tail)
            (enables incremental checkpointing, but log grows faster)
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointType.StreamingSnapshot">
            <summary>
            Yield a stream of key-value records in version (v), that can be used to rebuild the store
            </summary>
        </member>
        <member name="T:Tsavorite.core.CheckpointSettings">
            <summary>
            Checkpoint-related settings
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointSettings.CheckpointManager">
            <summary>
            Checkpoint manager
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointSettings.CheckpointDir">
            <summary>
            Use specified directory for storing and retrieving checkpoints
            using local storage device.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointSettings.RemoveOutdated">
            <summary>
            Whether Tsavorite should remove outdated checkpoints automatically
            </summary>
        </member>
        <member name="F:Tsavorite.core.CheckpointSettings.ThrottleCheckpointFlushDelayMs">
            <summary>
            Whether we should throttle the disk IO for checkpoints (one write at a time, wait between each write) and issue IO from separate task (-1 = throttling disabled)
            </summary>
        </member>
        <member name="T:Tsavorite.core.CompletedOutputIterator`5">
            <summary>
            A list of <see cref="T:Tsavorite.core.CompletedOutputIterator`5"/> for completed outputs from a pending operation.
            </summary>
            <remarks>The session holds this list and returns an enumeration to the caller of an appropriate CompletePending overload. The session will handle
            disposing and clearing this list, but it is best if the caller calls Dispose() after processing the results, so the key, input, and heap containers
            are released as soon as possible.</remarks>
        </member>
        <member name="M:Tsavorite.core.CompletedOutputIterator`5.Next">
            <summary>
            Advance the iterator to the next element.
            </summary>
            <returns>False if this advances past the last element of the array, else true</returns>
        </member>
        <member name="P:Tsavorite.core.CompletedOutputIterator`5.Current">
            <summary>
            Returns a reference to the current element of the enumeration.
            </summary>
            <returns>A reference to the current element of the enumeration</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if there is no current element, either because Next() has not been called or it has advanced
                past the last element of the array
            </exception>
        </member>
        <member name="M:Tsavorite.core.CompletedOutputIterator`5.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.CompletedOutput`5">
            <summary>
            Structure to hold a key and its output for a pending operation.
            </summary>
            <remarks>The session holds a list of these that it returns to the caller of an appropriate CompletePending overload. The session will handle disposing
            and clearing, and will manage Dispose(), but it is best if the caller calls Dispose() after processing the results, so the key, input, and heap containers
            are released as soon as possible.</remarks>
        </member>
        <member name="P:Tsavorite.core.CompletedOutput`5.Key">
            <summary>
            The key for this pending operation.
            </summary>
        </member>
        <member name="P:Tsavorite.core.CompletedOutput`5.Input">
            <summary>
            The input for this pending operation.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompletedOutput`5.Output">
            <summary>
            The output for this pending operation. It is the caller's responsibility to dispose this if necessary; <see cref="M:Tsavorite.core.CompletedOutput`5.Dispose"/> will not try to dispose this member.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompletedOutput`5.Context">
            <summary>
            The context for this pending operation.
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompletedOutput`5.RecordMetadata">
            <summary>
            The record metadata for this operation
            </summary>
        </member>
        <member name="F:Tsavorite.core.CompletedOutput`5.Status">
            <summary>
            The status of the operation
            </summary>
        </member>
        <member name="T:Tsavorite.core.ConcurrentCounter">
            <summary>Represents a concurrent counter that is partitioned for performance.</summary>
        </member>
        <member name="M:Tsavorite.core.ConcurrentCounter.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Tsavorite.core.ConcurrentCounter"/> struct.</summary>
        </member>
        <member name="M:Tsavorite.core.ConcurrentCounter.Increment(System.Int64)">
            <summary>Increments the counter by the specified value.</summary>
            <param name="incrValue">The value to increment the counter by.</param>
        </member>
        <member name="P:Tsavorite.core.ConcurrentCounter.Total">
            <summary>Gets the total value of the counter.</summary>
        </member>
        <member name="T:Tsavorite.core.IHeapContainer`1">
            <summary>
            Heap container to store keys and values when they go pending
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.IHeapContainer`1.Get">
            <summary>
            Get a reference to the contained object
            </summary>
        </member>
        <member name="T:Tsavorite.core.StandardHeapContainer`1">
            <summary>
            Heap container for standard C# objects (non-variable-length)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Tsavorite.core.KVSettings`2">
            <summary>
            Configuration settings for hybrid log. Use Utility.ParseSize to specify sizes in familiar string notation (e.g., "4k" and "4 MB").
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.IndexSize">
            <summary>
            Size of main hash index, in bytes. Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.LogDevice">
            <summary>
            Device used for main hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ObjectLogDevice">
            <summary>
            Device used for serialized heap objects in hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.PageSize">
            <summary>
            Size of a page, in bytes
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.SegmentSize">
            <summary>
            Size of a segment (group of pages), in bytes. Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.MemorySize">
            <summary>
            Total size of in-memory part of log, in bytes. Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.MinEmptyPageCount">
            <summary>
            Controls how many pages should be empty to account for non-power-of-two-sized log
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.MutableFraction">
            <summary>
            Fraction of log marked as mutable (in-place updates). Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ReadCopyOptions">
            <summary>
            Control Read operations. These flags may be overridden by flags specified on session.NewSession or on the individual Read() operations
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.PreallocateLog">
            <summary>
            Whether to preallocate the entire log (pages) in memory
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ReadCacheEnabled">
            <summary>
            Whether read cache is enabled
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ReadCachePageSize">
            <summary>
            Size of a read cache page, in bytes. Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ReadCacheMemorySize">
            <summary>
            Total size of read cache, in bytes. Rounds down to power of 2.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ReadCacheSecondChanceFraction">
            <summary>
            Fraction of log head (in memory) used for second chance 
            copy to tail. This is (1 - MutableFraction) for the 
            underlying log.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.CheckpointManager">
            <summary>
            Checkpoint manager
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.CheckpointDir">
            <summary>
            Use specified directory for storing and retrieving checkpoints
            using local storage device.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.RemoveOutdatedCheckpoints">
            <summary>
            Whether Tsavorite should remove outdated checkpoints automatically
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.TryRecoverLatest">
            <summary>
            Try to recover from latest checkpoint, if available
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.ThrottleCheckpointFlushDelayMs">
            <summary>
            Whether we should throttle the disk IO for checkpoints (one write at a time, wait between each write) and issue IO from separate task (-1 = throttling disabled)
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.RevivificationSettings">
            <summary>
            Settings for recycling deleted records on the log.
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.Epoch">
            <summary>
            Epoch instance used by the store
            </summary>
        </member>
        <member name="F:Tsavorite.core.KVSettings`2.StateMachineDriver">
            <summary>
            State machine driver for the store
            </summary>
        </member>
        <member name="M:Tsavorite.core.KVSettings`2.#ctor">
            <summary>
            Create default configuration settings for TsavoriteKV. You need to create and specify LogDevice 
            explicitly with this API.
            Use Utility.ParseSize to specify sizes in familiar string notation (e.g., "4k" and "4 MB").
            Default index size is 64MB.
            </summary>
        </member>
        <member name="M:Tsavorite.core.KVSettings`2.#ctor(System.String,System.Boolean,Microsoft.Extensions.Logging.ILoggerFactory,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create default configuration backed by local storage at given base directory.
            Use Utility.ParseSize to specify sizes in familiar string notation (e.g., "4k" and "4 MB").
            Default index size is 64MB.
            </summary>
            <param name="baseDir">Base directory (without trailing path separator)</param>
            <param name="deleteDirOnDispose">Whether to delete base directory on dispose. This option prevents later recovery.</param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.KVSettings`2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.KVSettings`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.LogSettings">
            <summary>
            Configuration settings for hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMinPageSizeBits">
            <summary>Minimum number of bits for a page size</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMaxPageSizeBits">
            <summary>Maximum number of bits for a page size</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMinSegmentSizeBits">
            <summary>Minimum number of bits for a segment (segments consist of one or more pages)</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMaxSegmentSizeBits">
            <summary>Maximum number of bits for a page size (segments consist of one or more pages)</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMinMemorySizeBits">
            <summary>Minimum number of bits for the size of the in-memory portion of the log</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.kMaxMemorySizeBits">
            <summary>Maximum number of bits for the size of the in-memory portion of the log</summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.LogDevice">
            <summary>
            Device used for main hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.ObjectLogDevice">
            <summary>
            Device used for serialized heap objects in hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.PageSizeBits">
            <summary>
            Size of a segment (group of pages), in bits
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.SegmentSizeBits">
            <summary>
            Size of a segment (group of pages), in bits
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.MemorySizeBits">
            <summary>
            Total size of in-memory part of log, in bits
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.MinEmptyPageCount">
            <summary>
            Controls how many pages should be empty to account for non-power-of-two-sized log
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.MutableFraction">
            <summary>
            Fraction of log marked as mutable (in-place updates)
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.ReadCopyOptions">
            <summary>
            Control Read copy operations. These values may be overridden by flags specified on session.NewSession or on the individual Read() operations
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.ReadCacheSettings">
            <summary>
            Settings for optional read cache
            Overrides the "copy reads to tail" setting
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogSettings.PreallocateLog">
            <summary>
            Whether to preallocate the entire log (pages) in memory
            </summary>
        </member>
        <member name="T:Tsavorite.core.ILogSizeCalculator`2">
            <summary>Interface for calculating the size of the log</summary>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
        </member>
        <member name="M:Tsavorite.core.ILogSizeCalculator`2.CalculateRecordSize(Tsavorite.core.RecordInfo,`0,`1)">
            <summary>Calculates the size of a log record</summary>
            <param name="recordInfo">Information about the record</param>
            <param name="key">The key</param>
            <param name="value">The value</param>
            <returns>The size of the record</returns>
        </member>
        <member name="T:Tsavorite.core.LogSizeTracker`5">
            <summary>Tracks and controls size of log</summary>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
            <typeparam name="TStoreFunctions"></typeparam>
            <typeparam name="TAllocator"></typeparam>
            <typeparam name="TLogSizeCalculator">Type of the log size calculator</typeparam>
        </member>
        <member name="F:Tsavorite.core.LogSizeTracker`5.Stopped">
            <summary>Indicates whether resizer task has been stopped</summary>
        </member>
        <member name="P:Tsavorite.core.LogSizeTracker`5.TotalSizeBytes">
            <summary>Total size occupied by log, including heap</summary>
        </member>
        <member name="P:Tsavorite.core.LogSizeTracker`5.LogHeapSizeBytes">
            <summary>Size of log heap memory</summary>
        </member>
        <member name="P:Tsavorite.core.LogSizeTracker`5.TargetSize">
            <summary>Target size for the hybrid log memory utilization</summary>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.#ctor(Tsavorite.core.LogAccessor{`0,`1,`2,`3},`4,System.Int64,System.Int64,Microsoft.Extensions.Logging.ILogger)">
            <summary>Creates a new log size tracker</summary>
            <param name="logAccessor">Hybrid log accessor</param>
            <param name="logSizeCalculator">Size calculator</param>
            <param name="targetSize">Target size for the hybrid log memory utilization</param>
            <param name="delta">Delta from target size to maintain memory utilization</param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.Start(System.Threading.CancellationToken)">
            <summary>
            Starts the log size tracker
            NOTE: Not thread safe to start multiple times
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.UpdateTargetSize(System.Int64,System.Int64)">
            <summary>
            Update target size for the hybrid log memory utilization
            </summary>
            <param name="targetSize">The target size</param>
            <param name="delta">Delta from the target size</param>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.OnCompleted">
            <summary>Callback on allocator completion</summary>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.OnError(System.Exception)">
            <summary>Callback on allocator error</summary>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.OnNext(Tsavorite.core.ITsavoriteScanIterator{`0,`1})">
            <summary>Callback on allocator evicting a page to disk</summary>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.IncrementSize(System.Int64)">
            <summary>Adds size to the tracked total count</summary>
            <param name="size">Size to add</param>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.ResizerTask(System.Threading.CancellationToken)">
            <summary>
            Performs resizing by waiting for an event that is signaled whenever memory utilization changes.
            This is invoked on the threadpool to avoid blocking calling threads during the resize operation.
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogSizeTracker`5.ResizeIfNeeded(System.Threading.CancellationToken)">
            <summary>
            Adjusts the log size to maintain its size within the range of +/- delta of the target size.
            It does so by adjusting the number of empty pages in the underlying log. Also, it does this by
            incrementing/decrementing the empty page count by 1 at a time to avoid large jumps in memory utilization.
            </summary>
        </member>
        <member name="T:Tsavorite.core.ReadCopyFrom">
            <summary>
            Identifies which log regions records will be copied from to <see cref="T:Tsavorite.core.ReadCopyTo"/>. This specification is
            evaluated in hierarchical order, from that on the TsavoriteKV ctor, which may be overridden by those in 
            <see cref="T:Tsavorite.core.ClientSession`8"/>.NewSession(), which may be overridden
            by those at the individual Read() level.
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyFrom.Inherit">
            <summary>'default' value; inherit settings from the previous hierarchy level(s).</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyFrom.None">
            <summary>Do not copy.</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyFrom.Device">
            <summary>From larger-than-memory device (e.g. disk storage).</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyFrom.AllImmutable">
            <summary>From <see cref="F:Tsavorite.core.ReadCopyFrom.Device"/> or from the immutable region of the log.</summary>
        </member>
        <member name="T:Tsavorite.core.ReadCopyTo">
            <summary>
            Identifies the destination of records copied from <see cref="T:Tsavorite.core.ReadCopyFrom"/>.
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyTo.Inherit">
            <summary>'default' value; inherit settings from the previous hierarchy level(s).</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyTo.None">
            <summary>Do not copy.</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyTo.MainLog">
            <summary>Copy to the tail of the main log (or splice into the readcache/mainlog boundary, if readcache records are present).</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyTo.ReadCache">
            <summary>Copy to the readcache. This requires that <see cref="T:Tsavorite.core.ReadCacheSettings"/> be supplied to the TsavoriteKV ctor.</summary>
        </member>
        <member name="T:Tsavorite.core.ReadCopyOptions">
            <summary>
            Options for automatically copying immutable records on Read().
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyOptions.CopyFrom">
            <summary>Which immutable regions to copy records from.</summary>
        </member>
        <member name="F:Tsavorite.core.ReadCopyOptions.CopyTo">
            <summary>The destination for copies records.</summary>
        </member>
        <member name="M:Tsavorite.core.ReadCopyOptions.#ctor(Tsavorite.core.ReadCopyFrom,Tsavorite.core.ReadCopyTo)">
            <summary>Constructor.</summary>
        </member>
        <member name="P:Tsavorite.core.ReadCopyOptions.None">
            <summary>A default instance that does no copying.</summary>
        </member>
        <member name="M:Tsavorite.core.ReadCopyOptions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.ReadOptions">
            <summary>
            Options for the Read() operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadOptions.CopyOptions">
            <summary>
            Options for automatically copying immutable records on Read().
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadOptions.KeyHash">
            <summary>
            The hashcode of the key for this operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.ReadOptions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.RMWOptions">
            <summary>
            Options for the Read() operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWOptions.KeyHash">
            <summary>
            The hashcode of the key for this operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.RMWOptions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.UpsertOptions">
            <summary>
            Options for the Read() operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertOptions.KeyHash">
            <summary>
            The hashcode of the key for this operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.UpsertOptions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.DeleteOptions">
            <summary>
            Options for the Read() operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteOptions.KeyHash">
            <summary>
            The hashcode of the key for this operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.DeleteOptions.ToString">
            <inheritdoc/>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.SUCCESS">
            <summary>
            Operation completed successfully, and a record with the specified key was found.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.NOTFOUND">
            <summary>
            Operation completed successfully, and a record with the specified key was not found; the operation may have created a new one.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.CANCELED">
            <summary>
            Operation was canceled by the client.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.MAX_MAP_TO_COMPLETED_STATUSCODE">
            <summary>
            The maximum range that directly maps to the <see cref="T:Tsavorite.core.StatusCode"/> enumeration; the operation completed. 
            This is an internal code to reserve ranges in the <see cref="T:Tsavorite.core.OperationStatus"/> enumeration.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.RETRY_NOW">
            <summary>
            Retry operation immediately, within the current epoch. This is only used in situations where another thread does not need to do another operation 
            to bring things into a consistent state.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.RETRY_LATER">
            <summary>
            Retry operation immediately, after refreshing the epoch. This is used in situations where another thread may have done an operation that requires it
            to do a subsequent operation to bring things into a consistent state; that subsequent operation may require <see cref="M:Tsavorite.core.LightEpoch.BumpCurrentEpoch"/>.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.RECORD_ON_DISK">
            <summary>
            I/O has been enqueued and the caller must go through <see cref="M:Tsavorite.core.ITsavoriteContext`8.CompletePending(System.Boolean,System.Boolean)"/> or
            <see cref="M:Tsavorite.core.ITsavoriteContext`8.CompletePendingWithOutputs(Tsavorite.core.CompletedOutputIterator{`0,`1,`2,`3,`4}@,System.Boolean,System.Boolean)"/>,
            or one of the Async forms.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.CPR_SHIFT_DETECTED">
            <summary>
            A checkpoint is in progress so the operation must be retried internally after refreshing the epoch and updating the session context version.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.ALLOCATE_FAILED">
            <summary>
            Allocation failed, due to a need to flush pages. Clients do not see this status directly; they see <see cref="P:Tsavorite.core.Status.IsPending"/>.
            <list type="bullet">
              <item>For Sync operations we retry this as part of <see cref="M:Tsavorite.core.TsavoriteKV`4.HandleImmediateRetryStatus``4(Tsavorite.core.OperationStatus,``3,Tsavorite.core.TsavoriteKV{`0,`1,`2,`3}.PendingContext{``0,``1,``2}@)"/>.</item>
              <item>For Async operations we retry this as part of the ".Complete(...)" or ".CompleteAsync(...)" operation on the appropriate "*AsyncResult{}" object.</item>
            </list>
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStatus.BASIC_MASK">
            <summary>
            An internal code to reserve ranges in the <see cref="T:Tsavorite.core.OperationStatus"/> enumeration.
            </summary>
        </member>
        <member name="T:Tsavorite.core.ReadCacheSettings">
            <summary>
            Configuration settings for hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCacheSettings.PageSizeBits">
            <summary>
            Size of a segment (group of pages), in bits
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCacheSettings.MemorySizeBits">
            <summary>
            Total size of in-memory part of log, in bits
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadCacheSettings.SecondChanceFraction">
            <summary>
            Fraction of log head (in memory) used for second chance 
            copy to tail. This is (1 - MutableFraction) for the 
            underlying log
            </summary>
        </member>
        <member name="M:Tsavorite.core.RecordInfo.TrySeal(System.Boolean)">
            <summary>
            Seal this record (currently only called to prepare it for inline revivification).
            </summary>
        </member>
        <member name="M:Tsavorite.core.RecordInfo.TryResetModifiedAtomic">
            <summary>
            Try to reset the modified bit of the RecordInfo
            </summary>
            <returns>Whether the modified bit was reset successfully</returns>
        </member>
        <member name="T:Tsavorite.core.RecordMetadata">
            <summary>
            A structure carrying metadata about a record in the log.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordMetadata.RecordInfo">
            <summary>
            The <see cref="F:Tsavorite.core.RecordMetadata.RecordInfo"/> header of the record.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordMetadata.Address">
            <summary>
            The logical address of the record.
            </summary>
        </member>
        <member name="M:Tsavorite.core.RecordMetadata.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.SingleWaiterAutoResetEvent">
            <summary>
            Represents a synchronization event that, when signaled, resets automatically after releasing a single waiter.
            This type supports concurrent signallers but only a single waiter.
            Based on https://github.com/dotnet/orleans/blob/main/src/Orleans.Runtime/Versions/SingleWaiterAutoResetEvent.cs
            </summary>
        </member>
        <member name="M:Tsavorite.core.SingleWaiterAutoResetEvent.Signal">
            <summary>
            Signal the waiter.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SingleWaiterAutoResetEvent.WaitAsync">
            <summary>
            Wait for the event to be signaled.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SingleWaiterAutoResetEvent.ResetStatus">
            <summary>
            Called when a waiter handles the event signal.
            </summary>
        </member>
        <member name="T:Tsavorite.core.UpsertAction">
            <summary>
            What actions to take following the RMW ISessionFunctions method call, such as cancellation or record expiration.
            </summary>
        </member>
        <member name="F:Tsavorite.core.UpsertAction.Default">
            <summary>
            Execute the default action for the method 'false' return.
            </summary>
        </member>
        <member name="F:Tsavorite.core.UpsertAction.CancelOperation">
            <summary>
            Stop the operation immediately and return.
            </summary>
        </member>
        <member name="T:Tsavorite.core.UpsertInfo">
            <summary>
            Information passed to <see cref="T:Tsavorite.core.ISessionFunctions`5"/> record-update callbacks. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.Version">
            <summary>
            The Tsavorite execution context version of the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.Address">
            <summary>
            The logical address of the record being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.KeyHash">
            <summary>
            Hash code of key being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.SessionID">
            <summary>
            The ID of session context executing the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.RecordInfo">
            <summary>
            The header of the record.
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.UsedValueLength">
            <summary>
            The length of data in the value that is in use. Incoming, it is set by Tsavorite.
            If an application wants to allow data to shrink and then grow again within the same record, it must set this to the correct length on output. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.FullValueLength">
            <summary>
            The allocated length of the record value.
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.Action">
            <summary>
            What actions Tsavorite should perform on a false return from the ISessionFunctions method
            </summary>
        </member>
        <member name="P:Tsavorite.core.UpsertInfo.UserData">
            <summary>
            User-defined byte of data associated with the operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.UpsertInfo.#ctor(Tsavorite.core.RMWInfo@)">
            <summary>
            Utility ctor
            </summary>
        </member>
        <member name="M:Tsavorite.core.UpsertInfo.ClearExtraValueLength``1(Tsavorite.core.RecordInfo@,``0@,System.Int32)">
            <summary>
            Retrieve the extra value length from the record, if present, and then clear it to ensure consistent log scan during in-place update.
            </summary>
            <param name="recordValue">Reference to the record value</param>
            <param name="usedValueLength">The currently-used length of the record value</param>
            <param name="recordInfo">The record header</param>
            <typeparam name="TValue">The type of the value</typeparam>
        </member>
        <member name="M:Tsavorite.core.UpsertInfo.SetUsedValueLength``1(Tsavorite.core.RecordInfo@,``0@,System.Int32)">
            <summary>
            Set the extra value length, if any, into the record past the used value length.
            </summary>
            <param name="recordInfo">The record header</param>
            <param name="recordValue">Reference to the record value</param>
            <param name="usedValueLength">The currently-used length of the record value</param>
            <typeparam name="TValue">The type of the value</typeparam>
        </member>
        <member name="T:Tsavorite.core.RMWAction">
            <summary>
            What actions to take following the RMW ISessionFunctions method call, such as cancellation or record expiration.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RMWAction.Default">
            <summary>
            Execute the default action for the method 'false' return.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RMWAction.ExpireAndResume">
            <summary>
            Expire the record, including continuing actions to reinsert a new record with initial state.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RMWAction.ExpireAndStop">
            <summary>
            Expire the record, and do not attempt to insert a new record with initial state.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RMWAction.CancelOperation">
            <summary>
            Stop the operation immediately and return.
            </summary>
        </member>
        <member name="T:Tsavorite.core.RMWInfo">
            <summary>
            Information passed to <see cref="T:Tsavorite.core.ISessionFunctions`5"/> record-update callbacks. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.Version">
            <summary>
            The Tsavorite execution context version of the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.Address">
            <summary>
            The logical address of the record being operated on. For CopyUpdater, this is the source address,
            or <see cref="F:Tsavorite.core.Constants.kInvalidAddress"/> if the source is the read cache.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.KeyHash">
            <summary>
            Hash code of key being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.SessionID">
            <summary>
            The ID of session context executing the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.RecordInfo">
            <summary>
            The header of the record.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.UsedValueLength">
            <summary>
            The length of data in the value that is in use. Incoming, it is set by Tsavorite.
            If an application wants to allow data to shrink and then grow again within the same record, it must set this to the correct length on output. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.FullValueLength">
            <summary>
            The allocated length of the record value.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.PreserveCopyUpdaterSourceRecord">
            <summary>
            If set true by CopyUpdater, the source record for the RCU will not be elided from the tag chain even if this is otherwise possible.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.IsFromPending">
            <summary>
            Whether the call is from sync or async (pending) path
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.Action">
            <summary>
            What actions Tsavorite should perform on a false return from the ISessionFunctions method
            </summary>
        </member>
        <member name="P:Tsavorite.core.RMWInfo.UserData">
            <summary>
            User-defined byte of data associated with the operation
            </summary>
        </member>
        <member name="M:Tsavorite.core.RMWInfo.ClearExtraValueLength``1(Tsavorite.core.RecordInfo@,``0@,System.Int32)">
            <summary>
            Retrieve the extra value length from the record, if present, and then clear it to ensure consistent log scan during in-place update.
            </summary>
            <param name="recordInfo">Reference to the record header</param>
            <param name="recordValue">Reference to the record value</param>
            <param name="usedValueLength">The currently-used length of the record value</param>
            <typeparam name="TValue">The type of the value</typeparam>
        </member>
        <member name="M:Tsavorite.core.RMWInfo.SetUsedValueLength``1(Tsavorite.core.RecordInfo@,``0@,System.Int32)">
            <summary>
            Set the extra value length, if any, into the record past the used value length.
            </summary>
            <param name="recordInfo">Reference to the record header</param>
            <param name="recordValue">Reference to the record value</param>
            <param name="usedValueLength">The currently-used length of the record value</param>
            <typeparam name="TValue">The type of the value</typeparam>
        </member>
        <member name="T:Tsavorite.core.DeleteAction">
            <summary>
            What actions to take following the RMW ISessionFunctions method call, such as cancellation or record expiration.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeleteAction.Default">
            <summary>
            Execute the default action for the method 'false' return.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeleteAction.CancelOperation">
            <summary>
            Stop the operation immediately and return.
            </summary>
        </member>
        <member name="T:Tsavorite.core.DeleteInfo">
            <summary>
            Information passed to <see cref="T:Tsavorite.core.ISessionFunctions`5"/> record-update callbacks. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.Version">
            <summary>
            The Tsavorite execution context version of the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.Address">
            <summary>
            The logical address of the record being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.KeyHash">
            <summary>
            Hash code of key being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.SessionID">
            <summary>
            The ID of session context executing the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.RecordInfo">
            <summary>
            The header of the record.
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.UsedValueLength">
            <summary>
            The length of data in the value that is in use. Incoming, it is set by Tsavorite to the result.
            If an application wants to allow data to shrink and then grow again within the same record, it must set this to the correct length on output. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.FullValueLength">
            <summary>
            The allocated length of the record value.
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.Action">
            <summary>
            What actions Tsavorite should perform on a false return from the ISessionFunctions method
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeleteInfo.UserData">
            <summary>
            User-defined byte of data associated with the operation
            </summary>
        </member>
        <member name="T:Tsavorite.core.ReadAction">
            <summary>
            What actions to take following the RMW ISessionFunctions method call, such as cancellation or record expiration.
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadAction.Default">
            <summary>
            Execute the default action for the method 'false' return.
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadAction.Expire">
            <summary>
            Expire the record. No subsequent actions are available for Read.
            </summary>
        </member>
        <member name="F:Tsavorite.core.ReadAction.CancelOperation">
            <summary>
            Stop the operation immediately and return.
            </summary>
        </member>
        <member name="T:Tsavorite.core.ReadInfo">
            <summary>
            Information passed to <see cref="T:Tsavorite.core.ISessionFunctions`5"/> record-read callbacks. 
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadInfo.Version">
            <summary>
            The Tsavorite execution context version of the operation
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadInfo.Address">
            <summary>
            The logical address of the record being operated on
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadInfo.RecordInfo">
            <summary>
            The header of the record.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadInfo.IsFromPending">
            <summary>
            Whether the call is from sync or async (pending) path
            </summary>
        </member>
        <member name="P:Tsavorite.core.ReadInfo.Action">
            <summary>
            What actions Tsavorite should perform on a false return from the ISessionFunctions method
            </summary>
        </member>
        <member name="T:Tsavorite.core.DataContractObjectSerializer`1">
            <summary>
            Serializer (for class types) based on DataContract
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.DataContractObjectSerializer`1.Deserialize(`0@)">
            <summary>
            Deserialize
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Tsavorite.core.DataContractObjectSerializer`1.Serialize(`0@)">
            <summary>
            Serialize
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:Tsavorite.core.IKeyComparer`1">
            <summary>
            Defines methods to support the comparison of Tsavorite keys for equality.
            </summary>
            <typeparam name="T">The type of keys to compare.</typeparam>
            <remarks>This comparer differs from the built-in <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> in that it implements a 64-bit hash code</remarks>
        </member>
        <member name="M:Tsavorite.core.IKeyComparer`1.GetHashCode64(`0@)">
            <summary>
            Get 64-bit hash code
            </summary>
        </member>
        <member name="M:Tsavorite.core.IKeyComparer`1.Equals(`0@,`0@)">
            <summary>
            Equality comparison
            </summary>
            <param name="k1">Left side</param>
            <param name="k2">Right side</param>
        </member>
        <member name="T:Tsavorite.core.IObjectSerializer`1">
            <summary>
            Object serializer interface
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.BeginSerialize(System.IO.Stream)">
            <summary>
            Begin serialization to given stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.Serialize(`0@)">
            <summary>
            Serialize object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.EndSerialize">
            <summary>
            End serialization to given stream
            </summary>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.BeginDeserialize(System.IO.Stream)">
            <summary>
            Begin deserialization from given stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.Deserialize(`0@)">
            <summary>
            Deserialize object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Tsavorite.core.IObjectSerializer`1.EndDeserialize">
            <summary>
            End deserialization from given stream
            </summary>
        </member>
        <member name="T:Tsavorite.core.BinaryObjectSerializer`1">
            <summary>
            Serializer base class for binary reader and writer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.BeginDeserialize(System.IO.Stream)">
            <summary>Begin deserialization</summary>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.Deserialize(`0@)">
            <summary>Deserialize</summary>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.EndDeserialize">
            <summary>End deserialize</summary>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.BeginSerialize(System.IO.Stream)">
            <summary>Begin serialize</summary>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.Serialize(`0@)">
            <summary>Serialize</summary>
        </member>
        <member name="M:Tsavorite.core.BinaryObjectSerializer`1.EndSerialize">
            <summary>End serialize</summary>
        </member>
        <member name="T:Tsavorite.core.IReadArgBatch`3">
            <summary>
            Batch of arguments to a read operation, including key, input and output
            </summary>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TInput">Type of input</typeparam>
            <typeparam name="TOutput">Type of output</typeparam>
        </member>
        <member name="P:Tsavorite.core.IReadArgBatch`3.Count">
            <summary>
            Count of keys/args/outputs.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadArgBatch`3.GetKey(System.Int32,`0@)">
            <summary>
            Get <paramref name="i"/>th key.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadArgBatch`3.GetInput(System.Int32,`1@)">
            <summary>
            Get <paramref name="i"/>th input.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadArgBatch`3.GetOutput(System.Int32,`2@)">
            <summary>
            Get <paramref name="i"/>th output.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadArgBatch`3.SetOutput(System.Int32,`2)">
            <summary>
            Set <paramref name="i"/>th output.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadArgBatch`3.SetStatus(System.Int32,Tsavorite.core.Status)">
            <summary>
            Set <paramref name="i"/>th status.
            </summary>
        </member>
        <member name="T:Tsavorite.core.ISessionFunctions`5">
            <summary>
            Callback functions to Tsavorite
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.SingleReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@)">
            <summary>
            Non-concurrent reader. 
            </summary>
            <param name="key">The key for the record to be read</param>
            <param name="input">The user input for computing <paramref name="dst"/> from <paramref name="value"/></param>
            <param name="value">The value for the record being read</param>
            <param name="dst">The location where <paramref name="value"/> is to be copied</param>
            <param name="readInfo">Information about this read operation and its context</param>
            <returns>True if the value was available, else false (e.g. the value was expired)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.ConcurrentReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Concurrent reader
            </summary>
            <param name="key">The key for the record to be read</param>
            <param name="input">The user input for computing <paramref name="dst"/> from <paramref name="value"/></param>
            <param name="value">The value for the record being read</param>
            <param name="dst">The location where <paramref name="value"/> is to be copied</param>
            <param name="readInfo">Information about this read operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the value was available, else false (e.g. the value was expired)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.ReadCompletionCallback(`0@,`2@,`3@,`4,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <summary>
            Read completion
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input that was used in the read operation</param>
            <param name="output">The result of the read operation; if this is a struct, then it will be a temporary and should be copied to <paramref name="ctx"/></param>
            <param name="ctx">The application context passed through the pending operation</param>
            <param name="status">The result of the pending operation</param>
            <param name="recordMetadata">Metadata for the record; may be used to obtain <see cref="F:Tsavorite.core.RecordMetadata.RecordInfo"/>.PreviousAddress when doing iterative reads</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.SingleWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <summary>
            Non-concurrent writer; called on an Upsert that does not find the key so does an insert or finds the key's record in the immutable region so does a read/copy/update (RCU).
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing <paramref name="dst"/></param>
            <param name="src">The previous value to be copied/updated</param>
            <param name="dst">The destination to be updated; because this is an copy to a new location, there is no previous value there.</param>
            <param name="output">The location where the result of the update may be placed</param>
            <param name="upsertInfo">Information about this update operation and its context</param>
            <param name="reason">The operation for which this write is being done</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the write was performed, else false (e.g. cancellation)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostSingleWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason)">
            <summary>
            Called after SingleWriter when a record containing an upsert of a new key has been successfully inserted at the tail of the log.
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input that was used to compute <paramref name="dst"/></param>
            <param name="src">The previous value to be copied/updated</param>
            <param name="dst">The destination to be updated; because this is an copy to a new location, there is no previous value there.</param>
            <param name="output">The location where the result of the update may be placed</param>
            <param name="upsertInfo">Information about this update operation and its context</param>
            <param name="reason">The operation for which this write is being done</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.ConcurrentWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Concurrent writer; called on an Upsert that finds the record in the mutable range.
            </summary>
            <param name="key">The key for the record to be written</param>
            <param name="input">The user input to be used for computing <paramref name="dst"/></param>
            <param name="src">The value to be copied to <paramref name="dst"/></param>
            <param name="dst">The location where <paramref name="src"/> is to be copied; because this method is called only for in-place updates, there is a previous value there.</param>
            <param name="output">The location where the result of the update may be placed</param>
            <param name="upsertInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the value was written, else false</returns>
            <remarks>If the value is shrunk in-place, the caller must first zero the data that is no longer used, to ensure log-scan correctness.</remarks>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostUpsertOperation``1(`0@,`2@,`1@,Tsavorite.core.UpsertInfo@,``0)">
            <summary>
            Called after the Upsert operation, but before we unlock the record (if it was ephemerally locked).
            </summary>
            <typeparam name="TEpochAccessor"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="src"></param>
            <param name="upsertInfo"></param>
            <param name="epoch"></param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.NeedInitialUpdate(`0@,`2@,`3@,Tsavorite.core.RMWInfo@)">
            <summary>
            Whether we need to invoke initial-update for RMW
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing the updated value</param>
            <param name="output">The location where the result of the <paramref name="input"/> operation is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.InitialUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Initial update for RMW (insert at the tail of the log).
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing the updated <paramref name="value"/></param>
            <param name="value">The destination to be updated; because this is an insert, there is no previous value there.</param>
            <param name="output">The location where the result of the <paramref name="input"/> operation on <paramref name="value"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the write was performed, else false (e.g. cancellation)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostInitialUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <summary>
            Called after a record containing an initial update for RMW has been successfully inserted at the tail of the log.
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing the updated <paramref name="value"/></param>
            <param name="value">The destination to be updated; because this is an insert, there is no previous value there.</param>
            <param name="output">The location where the result of the <paramref name="input"/> operation on <paramref name="value"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.NeedCopyUpdate(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <summary>
            Whether we need to invoke copy-update for RMW
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing the updated value</param>
            <param name="oldValue">The existing value that would be copied.</param>
            <param name="output">The location where the result of the <paramref name="input"/> operation on <paramref name="oldValue"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.CopyUpdater(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Copy-update for RMW (RCU (Read-Copy-Update) to the tail of the log)
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing <paramref name="newValue"/> from <paramref name="oldValue"/></param>
            <param name="oldValue">The previous value to be copied/updated</param>
            <param name="newValue">The destination to be updated; because this is an copy to a new location, there is no previous value there.</param>
            <param name="output">The location where <paramref name="newValue"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the write was performed, else false (e.g. cancellation)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostCopyUpdater(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <summary>
            Called after a record containing an RCU (Read-Copy-Update) for RMW has been successfully inserted at the tail of the log.
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing <paramref name="newValue"/> from <paramref name="oldValue"/></param>
            <param name="oldValue">The previous value to be copied/updated; may also be disposed here if appropriate</param>
            <param name="newValue">The destination to be updated; because this is an copy to a new location, there is no previous value there.</param>
            <param name="output">The location where <paramref name="newValue"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
            <returns>This is the only Post* method that returns non-void. The bool functions the same as CopyUpdater; this is because we do not want to modify
            objects in-memory until we know the "insert at tail" is successful. Therefore, we allow a false return as a signal to inspect <paramref name="rmwInfo.Action.Action"/>
            and handle <see cref="F:Tsavorite.core.RMWAction.ExpireAndStop"/>.</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.InPlaceUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            In-place update for RMW
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input to be used for computing the updated <paramref name="value"/></param>
            <param name="value">The destination to be updated; because this is an in-place update, there is a previous value there.</param>
            <param name="output">The location where the result of the <paramref name="input"/> operation on <paramref name="value"/> is to be copied</param>
            <param name="rmwInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <returns>True if the value was successfully updated, else false (e.g. the value was expired)</returns>
            <remarks>If the value is shrunk in-place, the caller must first zero the data that is no longer used, to ensure log-scan correctness.</remarks>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.GetRMWModifiedValueLength(`1@,`2@)">
            <summary>
            Length of resulting value object when performing RMW modification of value using given input
            </summary>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.GetRMWInitialValueLength(`2@)">
            <summary>
            Initial expected length of value object when populated by RMW using given input
            </summary>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.GetUpsertValueLength(`1@,`2@)">
            <summary>
            Length of resulting value object when performing Upsert of value using given input
            </summary>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostRMWOperation``1(`0@,`2@,Tsavorite.core.RMWInfo@,``0)">
            <summary>
            Called after the RMW operation, but before we unlock the record (if it was ephemerally locked).
            </summary>
            <typeparam name="TEpochAccessor"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="rmwInfo"></param>
            <param name="epoch"></param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.RMWCompletionCallback(`0@,`2@,`3@,`4,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <summary>
            RMW completion
            </summary>
            <param name="key">The key for this record</param>
            <param name="input">The user input that was used to perform the modification</param>
            <param name="output">The result of the RMW operation; if this is a struct, then it will be a temporary and should be copied to <paramref name="ctx"/></param>
            <param name="ctx">The application context passed through the pending operation</param>
            <param name="status">The result of the pending operation</param>
            <param name="recordMetadata">The metadata of the modified or inserted record</param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.SingleDeleter(`0@,`1@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Single deleter; called on a Delete that does not find the record in the mutable range and so inserts a new record.
            </summary>
            <param name="key">The key for the record to be deleted</param>
            <param name="value">The value for the record being deleted; because this method is called only for in-place updates, there is a previous value there. Usually this is ignored or assigned 'default'.</param>
            <param name="deleteInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <remarks>For Object Value types, Dispose() can be called here. If recordInfo.Invalid is true, this is called after the record was allocated and populated, but could not be appended at the end of the log.</remarks>
            <returns>True if the deleted record should be added, else false (e.g. cancellation)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostSingleDeleter(`0@,Tsavorite.core.DeleteInfo@)">
            <summary>
            Called after a record marking a Delete (with Tombstone set) has been successfully inserted at the tail of the log.
            </summary>
            <param name="key">The key for the record that was deleted</param>
            <param name="deleteInfo">Information about this update operation and its context</param>
            <remarks>This does not have the address of the record that contains the value at 'key'; Delete does not retrieve records below HeadAddress, so
                the last record we have in the 'key' chain may belong to 'key' or may be a collision.</remarks>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.ConcurrentDeleter(`0@,`1@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Concurrent deleter; called on a Delete that finds the record in the mutable range.
            </summary>
            <param name="key">The key for the record to be deleted</param>
            <param name="value">The value for the record being deleted; because this method is called only for in-place updates, there is a previous value there. Usually this is ignored or assigned 'default'.</param>
            <param name="deleteInfo">Information about this update operation and its context</param>
            <param name="recordInfo">A reference to the RecordInfo for the record; used for variable-length record length modification</param>
            <remarks>For Object Value types, Dispose() can be called here. If recordInfo.Invalid is true, this is called after the record was allocated and populated, but could not be appended at the end of the log.</remarks>
            <returns>True if the value was successfully deleted, else false (e.g. the record was sealed)</returns>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.PostDeleteOperation``1(`0@,Tsavorite.core.DeleteInfo@,``0)">
            <summary>
            Called after the Delete operation, but before we unlock the record (if it was ephemerally locked).
            </summary>
            <typeparam name="TEpochAccessor"></typeparam>
            <param name="key"></param>
            <param name="deleteInfo"></param>
            <param name="epoch"></param>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctions`5.ConvertOutputToHeap(`2@,`3@)">
            <summary>
            Called by Tsavorite when the operation goes pending, so the app can signal to itself that any pinned
            buffer in the Output is no longer valid and a heap-based buffer must be created.
            </summary>
            <param name="output"></param>
        </member>
        <member name="T:Tsavorite.core.ISessionFunctions`2">
            <summary>
            Callback functions to Tsavorite (two-param version)
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Tsavorite.core.ISessionFunctions`3">
            <summary>
            Callback functions to Tsavorite (two-param version with context)
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="T:Tsavorite.core.ISessionFunctionsWrapper`7">
            <summary>
            Provides thread management and all callbacks. A wrapper for IFunctions and additional methods called by TsavoriteImpl; the wrapped
            IFunctions methods provide additional parameters to support the wrapper functionality, then call through to the user implementations. 
            </summary>
        </member>
        <member name="M:Tsavorite.core.ISessionFunctionsWrapper`7.ConvertOutputToHeap(`2@,`3@)">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.ISessionLocker`4">
            <summary>
            Provides thread management and all callbacks. A wrapper for ISessionFunctions and additional methods called by TsavoriteImpl; the wrapped
            ISessionFunctions methods provide additional parameters to support the wrapper functionality, then call through to the user implementations. 
            </summary>
        </member>
        <member name="T:Tsavorite.core.BasicSessionLocker`4">
            <summary>
            Basic (non-lockable) sessions must do transient locking.
            </summary>
            <remarks>
            This struct contains no data fields; SessionFunctionsWrapper redirects with its ClientSession.
            </remarks>
        </member>
        <member name="T:Tsavorite.core.LockableSessionLocker`4">
            <summary>
            Lockable sessions are manual locking and thus must have already locked the record prior to an operation on it, so assert that.
            </summary>
        </member>
        <member name="T:Tsavorite.core.StringKeyComparer">
            <summary>
            Deterministic equality comparer for strings
            </summary>
        </member>
        <member name="F:Tsavorite.core.StringKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.StringKeyComparer.Equals(System.String@,System.String@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.StringKeyComparer.GetHashCode64(System.String@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.LongKeyComparer">
            <summary>
            Deterministic equality comparer for longs
            </summary>
        </member>
        <member name="F:Tsavorite.core.LongKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.LongKeyComparer.Equals(System.Int64@,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.LongKeyComparer.GetHashCode64(System.Int64@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.IntKeyComparer">
            <summary>
            Deterministic equality comparer for longs
            </summary>
        </member>
        <member name="F:Tsavorite.core.IntKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.IntKeyComparer.Equals(System.Int32@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.IntKeyComparer.GetHashCode64(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.GuidKeyComparer">
            <summary>
            Deterministic equality comparer for longs
            </summary>
        </member>
        <member name="F:Tsavorite.core.GuidKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.GuidKeyComparer.Equals(System.Guid@,System.Guid@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.GuidKeyComparer.GetHashCode64(System.Guid@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.ByteArrayKeyComparer">
            <summary>
            Deterministic equality comparer for byte[]
            </summary>
        </member>
        <member name="F:Tsavorite.core.ByteArrayKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.ByteArrayKeyComparer.Equals(System.Byte[]@,System.Byte[]@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.ByteArrayKeyComparer.GetHashCode64(System.Byte[]@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.EmptyKeyComparer">
            <summary>
            No-op equality comparer for Empty (used by TsavoriteLog)
            </summary>
        </member>
        <member name="F:Tsavorite.core.EmptyKeyComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.EmptyKeyComparer.Equals(Tsavorite.core.Empty@,Tsavorite.core.Empty@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.EmptyKeyComparer.GetHashCode64(Tsavorite.core.Empty@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.DefaultKeyComparer`1">
            <summary>
            Low-performance Tsavorite equality comparer wrapper around EqualityComparer.Default
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Tsavorite.core.DefaultKeyComparer`1.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.DefaultKeyComparer`1.Equals(`0@,`0@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DefaultKeyComparer`1.GetHashCode64(`0@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.SessionFunctionsBase`5">
            <summary>
            Default empty functions base class to make it easy for users to provide their own implementation of ISessionFunctions
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.ConcurrentReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.SingleReader(`0@,`2@,`1@,`3@,Tsavorite.core.ReadInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.ConcurrentWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.SingleWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostSingleWriter(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostUpsertOperation``1(`0@,`2@,`1@,Tsavorite.core.UpsertInfo@,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.InitialUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostInitialUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.NeedInitialUpdate(`0@,`2@,`3@,Tsavorite.core.RMWInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.NeedCopyUpdate(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.CopyUpdater(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostCopyUpdater(`0@,`2@,`1@,`1@,`3@,Tsavorite.core.RMWInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.InPlaceUpdater(`0@,`2@,`1@,`3@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.SingleDeleter(`0@,`1@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostDeleteOperation``1(`0@,Tsavorite.core.DeleteInfo@,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.PostRMWOperation``1(`0@,`2@,Tsavorite.core.RMWInfo@,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.RMWCompletionCallback(`0@,`2@,`3@,`4,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.GetRMWModifiedValueLength(`1@,`2@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.GetRMWInitialValueLength(`2@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.GetUpsertValueLength(`1@,`2@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SessionFunctionsBase`5.ConvertOutputToHeap(`2@,`3@)">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.SimpleSessionFunctions`3">
            <summary>
            Default empty functions base class to make it easy for users to provide their own implementation of FunctionsBase
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:Tsavorite.core.SimpleSessionFunctions`3.ConcurrentReader(`0@,`1@,`1@,`1@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SimpleSessionFunctions`3.SingleReader(`0@,`1@,`1@,`1@,Tsavorite.core.ReadInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SimpleSessionFunctions`3.InitialUpdater(`0@,`1@,`1@,`1@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SimpleSessionFunctions`3.CopyUpdater(`0@,`1@,`1@,`1@,`1@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SimpleSessionFunctions`3.InPlaceUpdater(`0@,`1@,`1@,`1@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.TryAddFunctions`3">
            <summary>
            Functions that make RMW behave as an atomic TryAdd operation, where Input is the value being added.
            Return Status.NotFound => TryAdd succeededed (item added).
            Return Status.Found => TryAdd failed (item not added, key was already present).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:Tsavorite.core.TryAddFunctions`3.InPlaceUpdater(`0@,`1@,`1@,`1@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TryAddFunctions`3.NeedCopyUpdate(`0@,`1@,`1@,`1@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.TryAddFunctions`2">
            <summary>
            Functions that make RMW behave as an atomic TryAdd operation, where Input is the value being added.
            Return Status.NotFound => TryAdd succeededed (item added)
            Return Status.Found => TryAdd failed (item not added, key was already present)
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Tsavorite.core.LinkedCheckpointInfo">
            <summary>
            Linked list (chain) of checkpoint info
            </summary>
        </member>
        <member name="F:Tsavorite.core.LinkedCheckpointInfo.NextTask">
            <summary>
            Next task in checkpoint chain
            </summary>
        </member>
        <member name="T:Tsavorite.core.DeltaLogEntryType">
            <summary>
            The type of a record in the delta (incremental) log
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeltaLogEntryType.DELTA">
            <summary>
            The entry is a delta record
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeltaLogEntryType.CHECKPOINT_METADATA">
            <summary>
            The entry is checkpoint metadata
            </summary>
        </member>
        <member name="T:Tsavorite.core.DeltaLog">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="F:Tsavorite.core.DeltaLog.HeaderSize">
            <summary>
            Header size
            </summary>
        </member>
        <member name="P:Tsavorite.core.DeltaLog.TailAddress">
            <summary>
            Tail address
            </summary>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.#ctor(Tsavorite.core.IDevice,System.Int32,System.Int64,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.InitializeForReads">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.DeltaLog.Dispose">
            <summary>
            Dispose the iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.GetNext(System.Int64@,System.Int32@,Tsavorite.core.DeltaLogEntryType@)">
            <summary>
            Get next entry
            </summary>
            <param name="physicalAddress"></param>
            <param name="entryLength"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.InitializeForWrites(Tsavorite.core.SectorAlignedBufferPool)">
            <summary>
            Initialize for writes
            </summary>
            <param name="memory"></param>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.Allocate(System.Int32@,System.Int64@)">
            <summary>
            Returns allocated region on delta log to write to
            </summary>
            <param name="maxEntryLength">Max usable size of allocated region</param>
            <param name="physicalAddress">Address for caller to write to</param>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.Seal(System.Int32,Tsavorite.core.DeltaLogEntryType)">
            <summary>
            Seal allocated region for given size, write header, move tail address
            </summary>
            <param name="entryLength">Entry length</param>
            <param name="type">Optional record type</param>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.FlushAsync">
            <summary>
            Flush
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.DeltaLog.AsyncFlushPageToDeviceCallback(System.UInt32,System.UInt32,System.Object)">
            <summary>
            IOCompletion callback for page flush
            </summary>
            <param name="errorCode"></param>
            <param name="numBytes"></param>
            <param name="context"></param>
        </member>
        <member name="T:Tsavorite.core.FileDescriptor">
            <summary>
            Complete specification of file with path, for local and cloud files
            </summary>
        </member>
        <member name="F:Tsavorite.core.FileDescriptor.directoryName">
            <summary>
            Relative directory name or path
            </summary>
        </member>
        <member name="F:Tsavorite.core.FileDescriptor.fileName">
            <summary>
            Actual file or blob name
            </summary>
        </member>
        <member name="M:Tsavorite.core.FileDescriptor.#ctor(System.String,System.String)">
            <summary>
            Create FileInfo instance
            </summary>
            <param name="directoryName"></param>
            <param name="fileName"></param>
        </member>
        <member name="T:Tsavorite.core.ICheckpointManager">
            <summary>
            Interface for users to control creation and retrieval of checkpoint-related data
            Tsavorite calls this interface during checkpoint/recovery in this sequence:
            
            Checkpoint:
              InitializeIndexCheckpoint (for index checkpoints) -> 
              GetIndexDevice (for index checkpoints) ->
              InitializeLogCheckpoint (for log checkpoints) ->
              GetSnapshotLogDevice (for log checkpoints in snapshot mode) ->
              GetSnapshotObjectLogDevice (for log checkpoints in snapshot mode with objects) ->
              CommitLogCheckpoint (for log checkpoints) ->
              CommitIndexCheckpoint (for index checkpoints) ->
            
            Recovery:
              GetIndexCommitMetadata ->
              GetLogCommitMetadata ->
              GetIndexDevice ->
              GetSnapshotLogDevice (for recovery in snapshot mode) ->
              GetSnapshotObjectLogDevice (for recovery in snapshot mode with objects)
            
            Provided devices will be closed directly by Tsavorite when done.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetCookie">
            <summary>
            Get current cookie
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.InitializeIndexCheckpoint(System.Guid)">
            <summary>
            Initialize index checkpoint
            </summary>
            <param name="indexToken"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.InitializeLogCheckpoint(System.Guid)">
            <summary>
            Initialize log checkpoint (snapshot and fold-over)
            </summary>
            <param name="logToken"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CommitIndexCheckpoint(System.Guid,System.Byte[])">
            <summary>
            Commit index checkpoint
            </summary>
            <param name="indexToken"></param>
            <param name="commitMetadata"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CleanupIndexCheckpoint(System.Guid)">
            <summary>
            Cleanup index checkpoint
            </summary>
            <param name="indexToken"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CommitLogCheckpointMetadata(System.Guid,System.Byte[])">
            <summary>
            Commit log checkpoint (snapshot and fold-over)
            </summary>
            <param name="logToken"></param>
            <param name="commitMetadata"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CleanupLogCheckpoint(System.Guid)">
            <summary>
            Cleanup log checkpoint
            </summary>
            <param name="logToken"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CheckpointVersionShiftStart(System.Int64,System.Int64,System.Boolean)">
            <summary>
            Callback to indicate start of version shift during checkpoint
            </summary>
            <param name="oldVersion"></param>
            <param name="newVersion"></param>
            <param name="isStreaming"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CheckpointVersionShiftEnd(System.Int64,System.Int64,System.Boolean)">
            <summary>
            Callback to indicate end of version shift during checkpoint
            </summary>
            <param name="oldVersion"></param>
            <param name="newVersion"></param>
            <param name="isStreaming"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CommitLogIncrementalCheckpoint(System.Guid,System.Byte[],Tsavorite.core.DeltaLog)">
            <summary>
            Commit log incremental checkpoint (incremental snapshot)
            </summary>
            <param name="logToken"></param>
            <param name="commitMetadata"></param>
            <param name="deltaLog"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.CleanupLogIncrementalCheckpoint(System.Guid)">
            <summary>
            Cleanup log incremental checkpoint (incremental snapshot)
            </summary>
            <param name="logToken"></param>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetIndexCheckpointMetadata(System.Guid)">
            <summary>
            Retrieve commit metadata for specified index checkpoint
            </summary>
            <param name="indexToken">Token</param>
            <returns>Metadata, or null if invalid</returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetLogCheckpointMetadata(System.Guid,Tsavorite.core.DeltaLog,System.Boolean,System.Int64)">
            <summary>
            Retrieve commit metadata for specified log checkpoint
            </summary>
            <param name="logToken">Token</param>
            <param name="deltaLog">Delta log</param>
            <param name="scanDelta"> whether or not to scan through the delta log to acquire latest entry. make sure the delta log points to the tail address immediately following the returned metadata.</param>
            <param name="recoverTo"> version upper bound to scan for in the delta log. Function will return the largest version metadata no greater than the given version.</param>
            <returns>Metadata, or null if invalid</returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetIndexCheckpointTokens">
            <summary>
            Get list of index checkpoint tokens, in order of usage preference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetLogCheckpointTokens">
            <summary>
            Get list of log checkpoint tokens, in order of usage preference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetIndexDevice(System.Guid)">
            <summary>
            Provide device to store index checkpoint (including overflow buckets)
            </summary>
            <param name="indexToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetSnapshotLogDevice(System.Guid)">
            <summary>
            Provide device to store snapshot of log (required only for snapshot checkpoints)
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetSnapshotObjectLogDevice(System.Guid)">
            <summary>
            Provide device to store snapshot of object log (required only for snapshot checkpoints)
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.GetDeltaLogDevice(System.Guid)">
            <summary>
            Provide device to store incremental (delta) snapshot of log (required only for incremental snapshot checkpoints)
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.Purge(System.Guid)">
            <summary>
            Cleanup all data (subfolder) related to the given guid by this manager
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.PurgeAll">
            <summary>
            Cleanup all data (subfolder) related to checkpoints by this manager
            </summary>
        </member>
        <member name="M:Tsavorite.core.ICheckpointManager.OnRecovery(System.Guid,System.Guid)">
            <summary>
            Initiatize manager on recovery (e.g., deleting other checkpoints)
            </summary>
            <param name="indexToken"></param>
            <param name="logToken"></param>
        </member>
        <member name="T:Tsavorite.core.TsavoriteBase">
            <summary/>
        </member>
        <member name="P:Tsavorite.core.TsavoriteBase.CheckpointManager">
            <summary>
            CheckpointManager
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteBase.recoveryCountdown">
            <summary>
            Main Index Recovery Functions
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteBase.loggerFactory">
            <summary>
            LoggerFactory
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteBase.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.#ctor(Tsavorite.core.LightEpoch,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.Initialize(System.Int64,System.Int32)">
            <summary>
            Initialize
            </summary>
            <param name="size"></param>
            <param name="sector_size"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.Initialize(System.Int32,System.Int64,System.Int32)">
            <summary>
            Initialize
            </summary>
            <param name="version"></param>
            <param name="size"></param>
            <param name="sector_size"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.FindTag(Tsavorite.core.HashEntryInfo@)">
            <summary>
            A helper function that is used to find the slot corresponding to a
            key in the specified version of the hash table
            </summary>
            <returns>true if such a slot exists, and populates <paramref name="hei"/>, else returns false</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.FindTagOrFreeInternal(Tsavorite.core.HashEntryInfo@,System.Int64)">
            <summary>
            Find existing entry (non-tentative) entry.
            </summary>
            <returns>If found, return the slot it is in, else return a pointer to some empty slot (which we may have allocated)</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.FindOtherSlotForThisTagMaybeTentativeInternal(System.UInt16,Tsavorite.core.HashBucket*@,System.Int32@,Tsavorite.core.HashBucket*,System.Int32)">
            <summary>
            Look for an existing entry (tentative or otherwise) for this hash/tag, other than the specified "except for this" bucket/slot.
            </summary>
            <returns>True if found, else false. Does not return a free slot.</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteBase.UpdateSlot(Tsavorite.core.HashBucket*,System.Int32,System.Int64,System.Int64,System.Int64@)">
            <summary>
            Helper function used to update the slot atomically with the
            new offset value using the CAS operation
            </summary>
            <param name="bucket"></param>
            <param name="entrySlot"></param>
            <param name="expected"></param>
            <param name="desired"></param>
            <param name="found"></param>
            <returns>If atomic update was successful</returns>
        </member>
        <member name="T:Tsavorite.core.LogFileInfo">
            <summary>
            Log File info
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogFileInfo.snapshotFileEndAddress">
            <summary>
            Snapshot file end address (start address is always 0)
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogFileInfo.hybridLogFileStartAddress">
            <summary>
            Hybrid log file start address
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogFileInfo.hybridLogFileEndAddress">
            <summary>
            Hybrid log file end address
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogFileInfo.deltaLogTailAddress">
            <summary>
            Delta log tail address
            </summary>
        </member>
        <member name="T:Tsavorite.core.DisposeReason">
            <summary>
            The reason for a call to <see cref="M:Tsavorite.core.IRecordDisposer`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)"/>
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.None">
            <summary>
            No Dispose() call was made
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.SingleWriterCASFailed">
            <summary>
            Failure of SingleWriter insertion of a record at the tail of the cache.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.CopyUpdaterCASFailed">
            <summary>
            Failure of CopyUpdater insertion of a record at the tail of the cache.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.InitialUpdaterCASFailed">
            <summary>
            Failure of InitialUpdater insertion of a record at the tail of the cache.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.SingleDeleterCASFailed">
            <summary>
            Failure of SingleDeleter insertion of a record at the tail of the cache.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.DeserializedFromDisk">
            <summary>
            A record was deserialized from the disk for a pending Read or RMW operation.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.RevivificationFreeList">
            <summary>
            A record was retrieved from the revivification freelist, and thus the key space may have to be adjusted as well.
            </summary>
        </member>
        <member name="F:Tsavorite.core.DisposeReason.PageEviction">
            <summary>
            A page was evicted from the in-memory portion of the main log, or from the readcache.
            </summary>
        </member>
        <member name="T:Tsavorite.core.IRecordDisposer`2">
            <summary>
            Interface to implement the Disposer component of <see cref="T:Tsavorite.core.IStoreFunctions`2"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.IRecordDisposer`2.DisposeOnPageEviction">
            <summary>
            If true, <see cref="M:Tsavorite.core.IRecordDisposer`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)"/> with <see cref="F:Tsavorite.core.DisposeReason.PageEviction"/> 
            is called on page evictions from both readcache and main log. Otherwise, the user can register an Observer and do any needed disposal there.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IRecordDisposer`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)">
            <summary>
            Dispose the Key and Value of a record, if necessary. See comments in <see cref="M:Tsavorite.core.IStoreFunctions`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)"/> for details.
            </summary>
        </member>
        <member name="T:Tsavorite.core.DefaultRecordDisposer`2">
            <summary>
            Default no-op implementation if <see cref="T:Tsavorite.core.IRecordDisposer`2"/>
            </summary>
            <remarks>It is appropriate to call methods on this instance as a no-op.</remarks>
        </member>
        <member name="F:Tsavorite.core.DefaultRecordDisposer`2.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="P:Tsavorite.core.DefaultRecordDisposer`2.DisposeOnPageEviction">
            <summary>
            Assumes the key and value have no need of Dispose(), and does nothing.
            </summary>
        </member>
        <member name="M:Tsavorite.core.DefaultRecordDisposer`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)">
            <summary>
            Assumes the key and value have no need of Dispose(), and does nothing.
            </summary>
        </member>
        <member name="T:Tsavorite.core.SpanByteRecordDisposer">
            <summary>
            Default no-op implementation if <see cref="T:Tsavorite.core.IRecordDisposer`2"/> for SpanByte
            </summary>
        </member>
        <member name="F:Tsavorite.core.SpanByteRecordDisposer.Instance">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByteRecordDisposer.DisposeOnPageEviction">
            <summary>
            Assumes the key and value have no need of Dispose(), and does nothing.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteRecordDisposer.DisposeRecord(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.DisposeReason,System.Int32)">
            <summary>
            If <paramref name="reason"/> is <see cref="F:Tsavorite.core.DisposeReason.RevivificationFreeList"/> and <paramref name="newKeySize"/> is >= 0,
            this adjusts the key (and if necessary value) space as needed to preserve log zero-init correctness.
            Otherwise the key and value have no need of disposal, and this does nothing.
            </summary>
        </member>
        <member name="T:Tsavorite.core.IStoreFunctions`2">
            <summary>
            The interface to define functions on the TsavoriteKV store itself (rather than a session).
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.GetKeyHashCode64(`0@)">
            <summary>Get a 64-bit hash code for a key</summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.KeysEqual(`0@,`0@)">
            <summary>Compare two keys for equality</summary>
        </member>
        <member name="P:Tsavorite.core.IStoreFunctions`2.HasKeySerializer">
            <summary>Indicates whether the Key Serializer is to be used</summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.BeginSerializeKey(System.IO.Stream)">
            <summary>Instatiate a KeySerializer and begin Key serialization to the given stream.</summary>
            <remarks>This must instantiate a new serializer as multiple threads may be serializing or deserializing.</remarks>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.BeginDeserializeKey(System.IO.Stream)">
            <summary>Instatiate a KeySerializer and begin Key deserialization from the given stream.</summary>
            <remarks>This must instantiate a new serializer as multiple threads may be serializing or deserializing.</remarks>
        </member>
        <member name="P:Tsavorite.core.IStoreFunctions`2.HasValueSerializer">
            <summary>Indicates whether the Value Serializer is to be used</summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.BeginSerializeValue(System.IO.Stream)">
            <summary>Instatiate a ValueSerializer and begin Value serialization to the given stream.</summary>
            <remarks>This must instantiate a new serializer as multiple threads may be serializing or deserializing.</remarks>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.BeginDeserializeValue(System.IO.Stream)">
            <summary>Instatiate a ValueSerializer and begin Value deserialization from the given stream.</summary>
            <remarks>This must instantiate a new serializer as multiple threads may be serializing or deserializing.</remarks>
        </member>
        <member name="P:Tsavorite.core.IStoreFunctions`2.DisposeOnPageEviction">
            <summary>
            If true, <see cref="M:Tsavorite.core.IStoreFunctions`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)"/> with <see cref="F:Tsavorite.core.DisposeReason.PageEviction"/> 
            is called on page evictions from both readcache and main log. Otherwise, the user can register an Observer and
            do any needed disposal there.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)">
            <summary>Dispose the Key and Value of a record, if necessary.</summary>
            <param name="key">The key for the record</param>
            <param name="value">The value for the record</param>
            <param name="newKeySize">For <see cref="F:Tsavorite.core.DisposeReason.RevivificationFreeList"/> only, this is a record from the freelist and we may be disposing the key as well as value
                (it is -1 when revivifying a record in the hash chain or when doing a RETRY; for these the key does not change)</param>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.SetCheckpointCompletedCallback(System.Action)">
            <summary>Set the parameterless checkpoint completion callback.</summary>
        </member>
        <member name="M:Tsavorite.core.IStoreFunctions`2.OnCheckpointCompleted">
            <summary>Called when a checkpoint has completed.</summary>
        </member>
        <member name="T:Tsavorite.core.StoreFunctions`4">
            <summary>
            Store functions for <typeparamref name="TKey"/> and <typeparamref name="TValue"/>.
            </summary>
            <remarks>
            The implementation takes instances of the supported interfaces (e.g. <see cref="T:Tsavorite.core.IObjectSerializer`1"/>) to allow custom
            implementation of any/all. We also provide standard implementations for standard types. The design exposes the instances
            because there is no need to wrap calls to them with additional functionality. This can be changed to redirect if such wrapper
            functionality is needed.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.#ctor(`2,System.Func{Tsavorite.core.IObjectSerializer{`0}},System.Func{Tsavorite.core.IObjectSerializer{`1}},`3)">
            <summary>
            Store functions for <typeparamref name="TKey"/> and <typeparamref name="TValue"/>.
            </summary>
            <remarks>
            The implementation takes instances of the supported interfaces (e.g. <see cref="T:Tsavorite.core.IObjectSerializer`1"/>) to allow custom
            implementation of any/all. We also provide standard implementations for standard types. The design exposes the instances
            because there is no need to wrap calls to them with additional functionality. This can be changed to redirect if such wrapper
            functionality is needed.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StoreFunctions`4.keyComparer">
            <summary>Compare two keys for equality, and get a key's hash code.</summary>
        </member>
        <member name="F:Tsavorite.core.StoreFunctions`4.keySerializerCreator">
            <summary>Serialize a Key to persistent storage</summary>
        </member>
        <member name="F:Tsavorite.core.StoreFunctions`4.valueSerializerCreator">
            <summary>Serialize a Value to persistent storage</summary>
        </member>
        <member name="F:Tsavorite.core.StoreFunctions`4.recordDisposer">
            <summary>Dispose a record</summary>
        </member>
        <member name="F:Tsavorite.core.StoreFunctions`4.checkpointCompletionCallback">
            <summary>Optional checkpoint completion callback, set separately from ctor.</summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.GetKeyHashCode64(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.KeysEqual(`0@,`0@)">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.StoreFunctions`4.HasKeySerializer">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.BeginSerializeKey(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.BeginDeserializeKey(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.StoreFunctions`4.HasValueSerializer">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.BeginSerializeValue(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.BeginDeserializeValue(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.StoreFunctions`4.DisposeOnPageEviction">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.DisposeRecord(`0@,`1@,Tsavorite.core.DisposeReason,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.SetCheckpointCompletedCallback(System.Action)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`4.OnCheckpointCompleted">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.StoreFunctions`2">
            <summary>
            A non-parameterized version of StoreFunctions that provides type-reduced Create() methods.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`2.Create``2(``0,System.Func{Tsavorite.core.IObjectSerializer{`0}},System.Func{Tsavorite.core.IObjectSerializer{`1}},``1)">
            <summary>
            Construct a StoreFunctions instance with all types specified and contained instances passed, e.g. for custom objects.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`2.Create``1(``0,System.Func{Tsavorite.core.IObjectSerializer{`0}},System.Func{Tsavorite.core.IObjectSerializer{`1}})">
            <summary>
            Construct a StoreFunctions instance with all types specified and contained instances passed, e.g. for custom objects.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`2.Create``2(``0,``1)">
            <summary>
            Construct a StoreFunctions instance with all types specified and contained instances passed, e.g. for custom objects.
            </summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`2.Create``1(``0)">
            <summary>
            Store functions for <typeparamref name="TKey"/> and <typeparamref name="TValue"/> that take only the <paramref name="keyComparer"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.StoreFunctions`2.Create">
            <summary>
            Store functions for <see cref="T:Tsavorite.core.SpanByte"/> Key and Value
            </summary>
        </member>
        <member name="F:Tsavorite.core.Constants.kCacheLineBytes">
            Size of cache line in bytes
        </member>
        <member name="F:Tsavorite.core.Constants.kBitsPerBucket">
            Number of entries per bucket (assuming 8-byte entries to fill a cacheline)
            Number of bits per bucket (assuming 8-byte entries to fill a cacheline)
        </member>
        <member name="F:Tsavorite.core.Constants.kInvalidEntrySlot">
            Invalid entry value
        </member>
        <member name="F:Tsavorite.core.Constants.kOverflowBucketIndex">
            Location of the special bucket entry
        </member>
        <member name="F:Tsavorite.core.Constants.kInvalidEntry">
            Invalid value in the hash table
        </member>
        <member name="F:Tsavorite.core.Constants.kRetryThreshold">
            Number of times to retry a compare-and-swap before failure
        </member>
        <member name="F:Tsavorite.core.Constants.kFlushSpinCount">
            Number of times to spin before awaiting or Waiting for a Flush Task.
        </member>
        <member name="F:Tsavorite.core.Constants.kNumMergeChunkBits">
            Number of merge/split chunks.
        </member>
        <member name="T:Tsavorite.core.Extensions">
            <summary>
            Log subscription extensions
            </summary>
        </member>
        <member name="M:Tsavorite.core.Extensions.ToRecordObservable``2(System.IObservable{Tsavorite.core.ITsavoriteScanIterator{``0,``1}})">
            <summary>
            Create observable of log records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.HashEntryInfo">
            <summary>Hash table entry information for a key</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.firstBucket">
            <summary>The first bucket in this chain for this hash bucket</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.bucket">
            <summary>The hash bucket for this key (may be an overflow bucket)</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.slot">
            <summary>The hash bucket entry slot for this key</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.entry">
            <summary>The hash bucket entry for this key</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.hash">
            <summary>The hash code for this key</summary>
        </member>
        <member name="F:Tsavorite.core.HashEntryInfo.tag">
            <summary>The hash tag for this key</summary>
        </member>
        <member name="P:Tsavorite.core.HashEntryInfo.Address">
            <summary>
            The original address of this hash entry (at the time of FindTag, etc.)
            </summary>
        </member>
        <member name="P:Tsavorite.core.HashEntryInfo.CurrentAddress">
            <summary>
            The current address of this hash entry (which may have been updated (via CAS) in the bucket after FindTag, etc.)
            </summary>
        </member>
        <member name="P:Tsavorite.core.HashEntryInfo.IsCurrent">
            <summary>
            Return whether the <see cref="T:Tsavorite.core.HashBucketEntry"/> has been updated
            </summary>
        </member>
        <member name="P:Tsavorite.core.HashEntryInfo.IsReadCache">
            <summary>
            Whether the original address for this hash entry (at the time of FindTag, etc.) is a readcache address.
            </summary>
        </member>
        <member name="P:Tsavorite.core.HashEntryInfo.IsCurrentReadCache">
            <summary>
            Whether the current address for this hash entry (possibly modified after FindTag, etc.) is a readcache address.
            </summary>
        </member>
        <member name="M:Tsavorite.core.HashEntryInfo.SetToCurrent">
            <summary>
            Set members to the current entry (which may have been updated (via CAS) in the bucket after FindTag, etc.)
            </summary>
        </member>
        <member name="T:Tsavorite.core.ILockTable`1">
            <summary>
            Manual-enabled (both manual and transient) LockTable interface definition
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:Tsavorite.core.ILockTable`1.IsEnabled">
            <summary>
            Try to acquire a manual lock for the key.
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.TryLockShared(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Try to acquire a shared lock for <paramref name="hei"/>. 
            </summary>
            <param name="hei">The hash table entry info of the key to lock</param>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.TryLockExclusive(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Try to acquire an exclusive lock for <paramref name="hei"/>.
            </summary>
            <param name="hei">The hash table entry info of the key to lock</param>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.UnlockShared(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Release a shared lock on the <paramref name="hei"/>.
            </summary>
            <param name="hei">The hash table entry info of the key to lock</param>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.UnlockExclusive(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Release an exclusive lock on <paramref name="hei"/>.
            </summary>
            <param name="hei">The hash table entry info of the key to lock</param>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.IsLockedShared(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Return whether the <paramref name="hei"/> is S locked
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.IsLockedExclusive(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Return whether the <paramref name="hei"/> is X locked
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.IsLocked(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Return whether an the key is S or X locked
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILockTable`1.GetLockState(Tsavorite.core.HashEntryInfo@)">
            <summary>
            Return the Lock state of the key.
            </summary>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.TryLockShared(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.TryLockExclusive(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.TryPromoteLock(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.UnlockShared(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.UnlockExclusive(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.IsLockedShared(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.IsLockedExclusive(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.IsLocked(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.GetLockState(Tsavorite.core.HashEntryInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.CompareKeyHashes``1(``0,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.CompareKeyHashes``1(``0@,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.SortKeyHashes``1(System.Span{``0})">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.OverflowBucketLockTable`4.KeyComparer`1">
            <summary>
            Need this struct because the Comparison{T} form of Array.Sort is not available with start and length arguments.
            </summary>
        </member>
        <member name="M:Tsavorite.core.OverflowBucketLockTable`4.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.SetRecordSourceToHashEntry(Tsavorite.core.AllocatorBase{`0,`1,`2,`3})">
            <summary>
            Sets <see cref="F:Tsavorite.core.OperationStackContext`4.recSrc"/> to the current <see cref="F:Tsavorite.core.OperationStackContext`4.hei"/>.<see cref="P:Tsavorite.core.HashEntryInfo.Address"/>, which is the address it had
            at the time of last retrieval from the hash table.
            </summary>
            <param name="srcLog">The TsavoriteKV's hlog</param>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.UpdateRecordSourceToCurrentHashEntry(Tsavorite.core.AllocatorBase{`0,`1,`2,`3})">
            <summary>
            Sets <see cref="F:Tsavorite.core.OperationStackContext`4.recSrc"/> to the current <see cref="F:Tsavorite.core.OperationStackContext`4.hei"/>.<see cref="P:Tsavorite.core.HashEntryInfo.CurrentAddress"/>, which is the current address
            in the hash table. This is the same effect as calling <see cref="M:Tsavorite.core.TsavoriteBase.FindTag(Tsavorite.core.HashEntryInfo@)"/>.
            </summary>
        </member>
        <member name="F:Tsavorite.core.OperationStackContext`4.newLogicalAddress">
            <summary>
            If this is not <see cref="F:Tsavorite.core.Constants.kInvalidAddress"/>, it is the logical Address allocated by CreateNewRecord*; if an exception
            occurs, this needs to be set invalid and non-tentative by the caller's 'finally' (to avoid another try/finally overhead).
            </summary>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.SetNewRecord(System.Int64)">
            <summary>
            Sets the new record to be handled on error recovery.
            </summary>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.SetNewRecordInvalid(Tsavorite.core.RecordInfo@)">
            <summary>
            Called during normal operations when a record insertion fails, to set the new record invalid and non-tentative.
            </summary>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.ClearNewRecord">
            <summary>
            Called during normal operations when a record insertion succeeds, to set the new record non-tentative (permanent).
            </summary>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.HandleNewRecordOnException(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3})">
            <summary>
            Called during InternalXxx 'finally' handler, to set the new record invalid if an exception or other error occurred.
            </summary>
        </member>
        <member name="M:Tsavorite.core.OperationStackContext`4.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.RecordSource`4">
            <summary>
            Carries various addresses and accompanying values corresponding to source records for the current InternalXxx or InternalContinuePendingR*
            operations, where "source" is a copy source for RMW and/or a locked record. This is passed to functions that create records, such as 
            TsavoriteKV.CreateNewRecord*() or TsavoriteKV.InternalTryCopyToTail(), and to unlocking utilities.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordSource`4.LogicalAddress">
            <summary>
            If valid, this is the logical address of a record. As "source", it may be copied from for RMW or pending Reads,
            or is locked. This address lives in one of the following places:
            <list type="bullet">
                <item>In the in-memory portion of the main log (<see cref="P:Tsavorite.core.RecordSource`4.HasMainLogSrc"/>). In this case, it may be a source for RMW CopyUpdater, or simply used for locking.</item>
                <item>In the readcache (<see cref="P:Tsavorite.core.RecordSource`4.HasReadCacheSrc"/>). In this case, it may be a source for RMW CopyUpdater, or simply used for locking.</item>
                <item>In the on-disk portion of the main log. In this case, the current call comes from a completed I/O request</item>
            </list>
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordSource`4.PhysicalAddress">
            <summary>
            If <see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/> this is the physical address of <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/>.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordSource`4.LatestLogicalAddress">
            <summary>
            The highest logical address in the main log (i.e. below readcache) for this key; if we have a readcache prefix chain, this is the splice point.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordSource`4.LowestReadCacheLogicalAddress">
            <summary>
            If valid, the lowest readcache logical address for this key; used to splice records between readcache and main log.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RecordSource`4.LowestReadCachePhysicalAddress">
            <summary>
            The physical address of <see cref="F:Tsavorite.core.RecordSource`4.LowestReadCacheLogicalAddress"/>.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.Allocator">
            <summary>
            If <see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>, this is the allocator (hlog or readcache) that <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/> is in.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.AllocatorBase">
            <summary>
            If <see cref="P:Tsavorite.core.RecordSource`4.HasInMemorySrc"/>, this is the allocator base (hlog or readcache) that <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/> is in.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.HasTransientSLock">
            <summary>
            Set (and cleared) by caller to indicate whether we have a LockTable-based Transient Shared lock (does not include Manual locks; this is per-operation only).
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.HasTransientXLock">
            <summary>
            Set (and cleared) by caller to indicate whether we have a LockTable-based Transient Exclusive lock (does not include Manual locks; this is per-operation only).
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.HasLock">
            <summary>
            Indicates whether we have any type of non-Manual lock.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.HasMainLogSrc">
            <summary>
            Set by caller to indicate whether the <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/> is an in-memory record in the main log, being used as a copy source and/or a lock.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordSource`4.HasReadCacheSrc">
            <summary>
            Set by caller to indicate whether the <see cref="F:Tsavorite.core.RecordSource`4.LogicalAddress"/> is an in-memory record in the readcache, being used as a copy source and/or a lock.
            </summary>
        </member>
        <member name="M:Tsavorite.core.RecordSource`4.Set(System.Int64,Tsavorite.core.AllocatorBase{`0,`1,`2,`3})">
            <summary>
            Initialize to the latest logical address from the caller.
            </summary>
        </member>
        <member name="M:Tsavorite.core.CheckEmptyWorker`4.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.FreeRecord.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.FreeRecordBin.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.FreeRecordPool`4.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.RevivificationSettings">
            <summary>
            Settings for record Revivification
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.DefaultRevivifiableFraction">
            <summary>
            Default revivification to use the full mutable region.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.EnableRevivification">
            <summary>
            Indicates whether deleted record space should be reused.
            <list type="bullet">
            <li>If this is true, then tombstoned records in the hashtable chain are revivified if possible, and a FreeList is maintained if 
                <see cref="F:Tsavorite.core.RevivificationSettings.FreeRecordBins"/> is non-null and non-empty.
            </li>
            <li>If this is false, then tombstoned records in the hashtable chain will not be revivified, and no FreeList is used (regardless 
                of the setting of <see cref="F:Tsavorite.core.RevivificationSettings.FreeRecordBins"/>).
            </li>
            </list>
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.RevivifiableFraction">
            <summary>
            What percentage of <see cref="F:Tsavorite.core.LogSettings.MutableFraction"/>, from the tail down, is eligible for revivification, calculated as
            (TailAddress - ReadOnlyAddress) * RevivifiableFraction. This prevents revivifying records too close to ReadOnly for the app's usage pattern--it
            may be important for recent records to remain near the tail. Default is to use the full mutable region. See also <see cref="F:Tsavorite.core.RevivificationSettings.UseFreeRecordPoolForCopyToTail"/>
            to control whether CopyToTail operations use the FreeRecordList.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.FreeRecordBins">
            <summary>
            Bin definitions for the free list (in addition to any in the hash chains). These must be ordered by <see cref="F:Tsavorite.core.RevivificationBin.RecordSize"/>.
            </summary>
            <remarks>
            If the Key and Value are both fixed-length datatypes (either blittable or object), this must contain a single bin whose
            <see cref="F:Tsavorite.core.RevivificationBin.RecordSize"/> is ignored. Otherwise, one or both of the Key and Value are variable-length,
            and this usually contains multiple bins.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.NumberOfBinsToSearch">
            <summary>
            By default, when looking for FreeRecords we search only the bin for the specified size. This allows searching the next-highest bin as well.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.RestoreDeletedRecordsIfBinIsFull">
            <summary>
            Deleted records that are to be added to a RevivificationBin are elided from the hash chain. If the bin is full, this option controls whether the
            record is restored (if possible) to the hash chain. This preserves them as in-chain revivifiable records, at the potential cost of having the record
            evicted to disk while part of the hash chain, and thus having to do an I/O only to find that the record is deleted and thus potentially unnecessary.
            For applications that add and delete the same keys repeatedly, this option should be set true if the FreeList is used.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationSettings.UseFreeRecordPoolForCopyToTail">
            <summary>
            When doing explicit CopyToTail operations such as Compaction, CopyToTail when reading from the immutable in-memory region, or disk IO, this controls
            whether the allocation for the retrieved records may be satisfied from the FreeRecordPool. These operations may require that the records be allocated
            at the tail of the log, to remain in memory as long as possible. See also <see cref="F:Tsavorite.core.RevivificationSettings.RevivifiableFraction"/> to control how much of the mutable memory
            space below the log tail is eligible for revivification.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RevivificationSettings.PowerOf2Bins">
            <summary>
            Use power-of-2 bins with a single oversize bin.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RevivificationSettings.DefaultFixedLength">
            <summary>
            Default bin for fixed-length.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RevivificationSettings.InChainOnly">
            <summary>
            Enable only in-tag-chain revivification; do not use FreeList
            </summary>
        </member>
        <member name="P:Tsavorite.core.RevivificationSettings.None">
            <summary>
            Turn off all revivification.
            </summary>
        </member>
        <member name="M:Tsavorite.core.RevivificationSettings.Clone">
            <summary>
            Return a copy of these RevivificationSettings.
            </summary>
        </member>
        <member name="M:Tsavorite.core.RevivificationSettings.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.RevivificationBin">
            <summary>
            Settings for a Revivification bin
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.MinRecordSize">
            <summary>
            The minimum size of a record; RecordInfo + int key/value, or any key/value combination below 8 bytes total, as record size is
            a multiple of 8.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.MinRecordsPerBin">
            <summary>
            The minimum number of records per bin.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.MaxRecordSize">
            <summary>
            The maximum size of a record; must fit on a single page.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.MaxInlineRecordSize">
            <summary>
            The maximum size of a record whose size can be stored "inline" in the FreeRecord metadata. This is informational, not a limit;
            sizes larger than this are considered "oversize" and require calls to the allocator to determine exact record size, which is slower.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.BestFitScanAll">
            <summary>
            Scan all records in the bin for best fit.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.UseFirstFit">
            <summary>
            Use first-fit instead of best-fit.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.DefaultRecordsPerBin">
            <summary>
            The default number of records per bin.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.RecordSize">
            <summary>
            The maximum size of records in this partition. This should be partitioned for your app. Ignored if this is the single bin
            for fixed-length records.
            </summary>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.NumberOfRecords">
            <summary>
            The number of records for each partition. This count will be adjusted upward so the partition is cache-line aligned.
            </summary>
            <remarks>
            The first record is not available; its space is used to store the circular buffer read and write pointers
            </remarks>
        </member>
        <member name="F:Tsavorite.core.RevivificationBin.BestFitScanLimit">
            <summary>
            The maximum number of entries to scan for best fit after finding first fit. Ignored for fixed-length datatypes. 
            </summary>
        </member>
        <member name="M:Tsavorite.core.RevivificationBin.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.RevivificationBin.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.PowerOf2BinsRevivificationSettings">
            <summary>
            Default revivification bin definition: Use power-of-2 bins with a single oversize bin.
            </summary>
        </member>
        <member name="M:Tsavorite.core.PowerOf2BinsRevivificationSettings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Tsavorite.core.RevivificationStats">
            <summary>
            Revivification statistics
            </summary>
        </member>
        <member name="M:Tsavorite.core.RevivificationStats.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.LogAccessor`4">
            <summary>
            Wrapper to process log-related commands
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.#ctor(Tsavorite.core.TsavoriteKV{`0,`1,`2,`3},`3)">
            <summary>
            Constructor
            </summary>
            <param name="store"></param>
            <param name="allocator"></param>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.TailAddress">
            <summary>
            Tail address of log
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.ReadOnlyAddress">
            <summary>
            Read-only address of log, i.e. boundary between read-only region and mutable region
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.SafeReadOnlyAddress">
            <summary>
            Safe read-only address of log, i.e. boundary between read-only region and mutable region
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.HeadAddress">
            <summary>
            Head address of log, i.e. beginning of in-memory regions
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.BeginAddress">
            <summary>
            Beginning address of log
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.FixedRecordSize">
            <summary>
            Get the bytes used on the primary log by every record. Does not include
            the size of variable-length inline data. Note that class objects occupy
            8 bytes (reference) on the main log (i.e., the heap space occupied by
            class objects is not included in the result of this call).
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.EmptyPageCount">
            <summary>
            Number of pages left empty or unallocated in the in-memory buffer (between 0 and BufferSize-1)
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.MaxEmptyPageCount">
            <summary>
            Maximum possible number of empty pages in Allocator
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.MinEmptyPageCount">
            <summary>
            Minimum possible number of empty pages in Allocator
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.SetEmptyPageCount(System.Int32,System.Boolean)">
            <summary>
            Set empty page count in allocator
            </summary>
            <param name="pageCount">New empty page count</param>
            <param name="wait">Whether to wait for shift addresses to complete</param>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.BufferSize">
            <summary>
            Total in-memory circular buffer capacity (in number of pages)
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.MemorySizeBytes">
            <summary>
            Actual memory used by log (not including heap objects) and overflow pages
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.MaxMemorySizeBytes">
            <summary>
            Maximum memory size in bytes
            </summary>
        </member>
        <member name="P:Tsavorite.core.LogAccessor`4.AllocatedPageCount">
            <summary>
            Number of pages allocated
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.ShiftBeginAddress(System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Shift begin address to the provided untilAddress. Make sure address corresponds to record boundary if snapToPageStart is set to 
            false. Destructive operation if truncateLog is set to true.
            </summary>
            <param name="untilAddress">Address to shift begin address until</param>
            <param name="snapToPageStart">Whether given address should be snapped to nearest earlier page start address</param>
            <param name="truncateLog">If true, we will also truncate the log on disk until the given BeginAddress. Truncate is a destructive operation 
            that can result in data loss. If false, log will be truncated after the next checkpoint.</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Truncate">
            <summary>
            Truncate physical log on disk until the current BeginAddress. Use ShiftBeginAddress to shift the begin address.
            Truncate is a destructive operation that can result in data loss. For data safety, take a checkpoint instead of 
            using this call, as a checkpoint truncates the log to the BeginAddress after persisting the data and metadata.
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.ShiftHeadAddress(System.Int64,System.Boolean)">
            <summary>
            Shift log head address to prune memory foorprint of hybrid log
            </summary>
            <param name="newHeadAddress">Address to shift head until</param>
            <param name="wait">Wait for operation to complete (may involve page flushing and closing)</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Subscribe(System.IObserver{Tsavorite.core.ITsavoriteScanIterator{`0,`1}})">
            <summary>
            Subscribe to records (in batches) as they become read-only in the log
            Currently, we support only one subscriber to the log (easy to extend)
            Subscriber only receives new log updates from the time of subscription onwards
            To scan the historical part of the log, use the Scan(...) method
            </summary>
            <param name="readOnlyObserver">Observer to which scan iterator is pushed</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.SubscribeEvictions(System.IObserver{Tsavorite.core.ITsavoriteScanIterator{`0,`1}})">
            <summary>
            Subscribe to records (in batches) as they get evicted from main memory.
            Currently, we support only one subscriber to the log (easy to extend)
            Subscriber only receives eviction updates from the time of subscription onwards
            To scan the historical part of the log, use the Scan(...) method
            </summary>
            <param name="evictionObserver">Observer to which scan iterator is pushed</param>
        </member>
        <member name="T:Tsavorite.core.LogAccessor`4.LogSubscribeDisposable">
            <summary>
            Wrapper to help dispose the subscription
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.ShiftReadOnlyAddress(System.Int64,System.Boolean)">
            <summary>
            Shift log read-only address
            </summary>
            <param name="newReadOnlyAddress">Address to shift read-only until</param>
            <param name="wait">Wait to ensure shift is complete (may involve page flushing)</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Scan(System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode,System.Boolean)">
            <summary>
            Pull-scan the log given address range; returns all records with address less than endAddress
            </summary>
            <returns>Scan iterator instance</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Scan``1(``0@,System.Int64,System.Int64,Tsavorite.core.ScanBufferingMode)">
            <summary>
            Push-scan the log given address range; returns all records with address less than endAddress
            </summary>
            <returns>True if Scan completed; false if Scan ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.IterateKeyVersions``1(``0@,`0@)">
            <summary>
            Iterate versions of the specified key, starting with most recent
            </summary>
            <returns>True if Scan completed; false if Scan ended early due to one of the TScanIterator reader functions returning false</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Flush(System.Boolean)">
            <summary>
            Flush log until current tail (records are still retained in memory)
            </summary>
            <param name="wait">Synchronous wait for operation to complete</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.FlushAndEvict(System.Boolean)">
            <summary>
            Flush log and evict all records from memory
            </summary>
            <param name="wait">Wait for operation to complete</param>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.DisposeFromMemory">
            <summary>
            Delete log entirely from memory. Cannot allocate on the log
            after this point. This is a synchronous operation.
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Compact``4(``3,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="functions">Functions used to manage key-values during compaction</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Compact``4(``3,``0@,``1@,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="functions">Functions used to manage key-values during compaction</param>
            <param name="input">Input for SingleWriter</param>
            <param name="output">Output from SingleWriter; it will be called all records that are moved, before Compact() returns, so the user must supply buffering or process each output completely</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Compact``5(``3,``4,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="functions">Functions used to manage key-values during compaction</param>
            <param name="cf">User provided compaction functions (see <see cref="T:Tsavorite.core.ICompactionFunctions`2"/>)</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="M:Tsavorite.core.LogAccessor`4.Compact``5(``3,``4,``0@,``1@,System.Int64,Tsavorite.core.CompactionType)">
            <summary>
            Compact the log until specified address, moving active records to the tail of the log. BeginAddress is shifted, but the physical log
            is not deleted from disk. Caller is responsible for truncating the physical log on disk by taking a checkpoint or calling Log.Truncate
            </summary>
            <param name="functions">Functions used to manage key-values during compaction</param>
            <param name="cf">User provided compaction functions (see <see cref="T:Tsavorite.core.ICompactionFunctions`2"/>)</param>
            <param name="input">Input for SingleWriter</param>
            <param name="output">Output from SingleWriter; it will be called all records that are moved, before Compact() returns, so the user must supply buffering or process each output completely</param>
            <param name="untilAddress">Compact log until this address</param>
            <param name="compactionType">Compaction type (whether we lookup records or scan log for liveness checking)</param>
            <returns>Address until which compaction was done</returns>
        </member>
        <member name="T:Tsavorite.core.WriteReason">
            <summary>
            The reason a SingleWriter was performed
            </summary>
        </member>
        <member name="F:Tsavorite.core.WriteReason.Upsert">
            <summary>A new record appended by Upsert</summary>
        </member>
        <member name="F:Tsavorite.core.WriteReason.CopyToTail">
            <summary>Copying a read from disk to the tail of the log</summary>
        </member>
        <member name="F:Tsavorite.core.WriteReason.CopyToReadCache">
            <summary>Copying a read from disk to the read cache</summary>
        </member>
        <member name="F:Tsavorite.core.WriteReason.Compaction">
            <summary>The user called Compact()</summary>
        </member>
        <member name="T:Tsavorite.core.CommitFailureException">
            <summary>
            Exception thrown when commit fails
            </summary>
        </member>
        <member name="P:Tsavorite.core.CommitFailureException.LinkedCommitInfo">
            <summary>
            Commit info and next commit task in chain
            </summary>
        </member>
        <member name="T:Tsavorite.core.CommitInfo">
            <summary>
            Info contained in task associated with commit
            </summary>
        </member>
        <member name="F:Tsavorite.core.CommitInfo.FromAddress">
            <summary>
            From address of commit range
            </summary>
        </member>
        <member name="F:Tsavorite.core.CommitInfo.UntilAddress">
            <summary>
            Until address of commit range
            </summary>
        </member>
        <member name="F:Tsavorite.core.CommitInfo.ErrorCode">
            <summary>
            Error code (0 = success)
            </summary>
        </member>
        <member name="T:Tsavorite.core.LinkedCommitInfo">
            <summary>
            Linked list (chain) of commit info
            </summary>
        </member>
        <member name="F:Tsavorite.core.LinkedCommitInfo.CommitInfo">
            <summary>
            Commit info
            </summary>
        </member>
        <member name="F:Tsavorite.core.LinkedCommitInfo.NextTask">
            <summary>
            Next task in commit chain
            </summary>
        </member>
        <member name="T:Tsavorite.core.ILogCommitManager">
            <summary>
            Log commit manager
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.Commit(System.Int64,System.Int64,System.Byte[],System.Int64,System.Boolean)">
            <summary>
            Perform (synchronous) commit with specified metadata
            </summary>
            <param name="beginAddress">Committed begin address (for information only, not necessary to persist)</param>
            <param name="untilAddress">Address committed until (for information only, not necessary to persist)</param>
            <param name="commitMetadata">Commit metadata - should be persisted</param>
            <param name="commitNum">commit num</param>
            <param name="forceWriteMetadata">force writing of metadata in case of fast commit</param>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.GetCommitMetadata(System.Int64)">
            <summary>
            Return commit metadata
            </summary>
            <param name="commitNum"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.ListCommits">
            <summary>
            Get list of commits, in order of usage preference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.RemoveCommit(System.Int64)">
            <summary>
            Remove the given commit, if present. Should only be invoked if PreciseCommitNumRecoverySupport returns true
            </summary>
            <param name="commitNum">commit num to remove</param>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.RemoveAllCommits">
            <summary>
            Remove all log commits from this manager
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILogCommitManager.OnRecovery(System.Int64)">
            <summary>
            Initiatize manager on recovery (e.g., deleting other commits)
            </summary>
            <param name="commitNum">Commit number</param>
        </member>
        <member name="T:Tsavorite.core.ILogEnqueueEntry">
            <summary>
             Represents a entry that can be serialized directly onto TsavoriteLog when enqueuing
            </summary>
        </member>
        <member name="P:Tsavorite.core.ILogEnqueueEntry.SerializedLength">
            <summary></summary>
            <returns> the size in bytes after serialization onto TsavoriteLog</returns>
        </member>
        <member name="M:Tsavorite.core.ILogEnqueueEntry.SerializeTo(System.Span{System.Byte})">
            <summary>
            Serialize the entry onto TsavoriteLog.
            </summary>
            <param name="dest">Memory buffer of TsavoriteLog to serialize onto. Guaranteed to have at least SerializedLength() many bytes</param>
        </member>
        <member name="T:Tsavorite.core.ILogEntryConsumer">
            <summary>
            Consumes a TsavoriteLog entry without copying 
            </summary>
        </member>
        <member name="M:Tsavorite.core.ILogEntryConsumer.Consume(System.Byte*,System.Int32,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Consumes the given entry.
            </summary>
            <param name="payloadPtr"></param>
            <param name="payloadLength"></param>
            <param name="currentAddress">Address of the consumed entry (excluding log header)</param>
            <param name="nextAddress">Expected address of the next log entry</param>
            <param name="isProtected">Whether call is under epoch protection</param>
        </member>
        <member name="T:Tsavorite.core.IBulkLogEntryConsumer">
            <summary>
            Consumes TsavoriteLog entries in bulk (raw data) without copying 
            </summary>
        </member>
        <member name="M:Tsavorite.core.IBulkLogEntryConsumer.Consume(System.Byte*,System.Int32,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Consumes the given bulk entries (raw data) under epoch protection - do not block.
            </summary>
            <param name="payloadPtr"></param>
            <param name="payloadLength"></param>
            <param name="currentAddress"> address of the consumed entry </param>
            <param name="nextAddress"> (predicted) address of the next entry </param>
            <param name="isProtected"> If call is under epoch protection </param>
        </member>
        <member name="M:Tsavorite.core.IBulkLogEntryConsumer.Throttle">
            <summary>
            Throttle the iteration if needed, outside epoch protection - blocking here is fine.
            </summary>
        </member>
        <member name="T:Tsavorite.core.IReadOnlySpanBatch">
            <summary>
            Interface to provide a batch of ReadOnlySpan[byte] data to Tsavorite
            </summary>
        </member>
        <member name="M:Tsavorite.core.IReadOnlySpanBatch.TotalEntries">
            <summary>
            Number of entries in provided batch
            </summary>
            <returns>Number of entries</returns>
        </member>
        <member name="M:Tsavorite.core.IReadOnlySpanBatch.Get(System.Int32)">
            <summary>
            Retrieve batch entry at specified index
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.IStoreInput">
            <summary>
            Represents a store input that can be serialized into / deserialized from TsavoriteLog
            </summary>
        </member>
        <member name="P:Tsavorite.core.IStoreInput.SerializedLength">
            <summary>
            Size of serialized IStoreInput object
            </summary>
        </member>
        <member name="M:Tsavorite.core.IStoreInput.CopyTo(System.Byte*,System.Int32)">
            <summary>
            Serialize the IStoreInput object into memory buffer
            </summary>
            <param name="dest">Memory buffer to serialize into. Guaranteed to have at least SerializedLength many bytes</param>
            <param name="length">Length of buffer to serialize into.</param>
            <returns>Number of serialized bytes</returns>
        </member>
        <member name="M:Tsavorite.core.IStoreInput.DeserializeFrom(System.Byte*)">
            <summary>
            Deserializes the IStoreInput object from memory buffer.
            </summary>
            <param name="src">Memory buffer to deserialize from. Guaranteed to have at least SerializedLength many bytes</param>
            <returns>Number of deserialized bytes</returns>
        </member>
        <member name="T:Tsavorite.core.LogCommitPolicy">
            <summary>
            LogCommitPolicy defines the way TsavoriteLog behaves on Commit(). In addition
            to choosing from a set of pre-defined ones, users can implement their own for custom behavior
            </summary>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.OnAttached(Tsavorite.core.TsavoriteLog)">
            <summary>
            Invoked when policy object is attached to a TsavoriteLog instance.
            </summary>
            <param name="log">The log this log commit policy is attached to</param>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.AdmitCommit(System.Int64,System.Boolean)">
            <summary>
            Admission control to decide whether a call to Commit() should successfully start or not.
            If false, commit logic will not execute. If true, a commit will be created to cover at least the tail given,
            although the underlying implementation may choose to compact multiple admitted Commit() invocations into
            one commit operation. It is the implementer's responsibility to log and retry any filtered Commit() when
            necessary (e.g., when there will not be any future Commit() invocations, but the last Commit() was filtered)
            </summary>
            <param name="currentTail">If successful, this request will commit at least up to this tail</param>
            <param name="commitRequired">Whether commit may be required, i.e., tail address is higher than last covered commit request or metadata (e.g., iterators) changed </param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.OnCommitCreated(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <summary>
            Invoked when a commit is successfully created
            </summary>
            <param name="info"> commit content </param>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.OnCommitFinished(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <summary>
            Invoked after a commit is complete
            </summary>
            <param name="info"> commit content </param>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.Default">
            <summary>
            The default log commit policy ensures that each record is covered by at most one commit request (except when
            the metadata has changed). Redundant commit calls are dropped and corresponding commit invocation will
            return false.
            </summary>
            <returns> policy object </returns>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.MaxParallel(System.Int32)">
            <summary>
            MaxParallel log commit policy allows k (non-strong) commit requests to be in progress at any giving time. The k commits are guaranteed
            to be non-overlapping unless there are metadata changes. Additional commit requests will fail and
            automatically retried.
            </summary>
            <param name="k"> maximum number of commits that can be outstanding at a time </param>
            <returns> policy object </returns>
        </member>
        <member name="M:Tsavorite.core.LogCommitPolicy.RateLimit(System.Int64,System.Int64)">
            <summary>
            RateLimit log commit policy will only issue a request if it covers at least m bytes or if there has not been a
            commit request in n milliseconds. Additional commit requests will fail and automatically retried
            </summary>
            <param name="thresholdMilli">
            minimum time, in milliseconds, to be allowed between two commits, unless thresholdRange bytes will be committed
            </param>
            <param name="thresholdBytes">
            minimum range, in bytes, to be allowed between two commits, unless it has been thresholdMilli milliseconds
            </param>
            <returns> policy object </returns>
        </member>
        <member name="M:Tsavorite.core.DefaultLogCommitPolicy.OnAttached(Tsavorite.core.TsavoriteLog)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.DefaultLogCommitPolicy.AdmitCommit(System.Int64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.DefaultLogCommitPolicy.OnCommitCreated(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.DefaultLogCommitPolicy.OnCommitFinished(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.MaxParallelLogCommitPolicy.OnAttached(Tsavorite.core.TsavoriteLog)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.MaxParallelLogCommitPolicy.AdmitCommit(System.Int64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.MaxParallelLogCommitPolicy.OnCommitCreated(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.MaxParallelLogCommitPolicy.OnCommitFinished(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.RateLimitLogCommitPolicy.OnAttached(Tsavorite.core.TsavoriteLog)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.RateLimitLogCommitPolicy.AdmitCommit(System.Int64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.RateLimitLogCommitPolicy.OnCommitCreated(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.RateLimitLogCommitPolicy.OnCommitFinished(Tsavorite.core.TsavoriteLogRecoveryInfo)">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.TsavoriteLog">
            <summary>
            Tsavorite log
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.BeginAddress">
            <summary>
            Beginning address of log
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.AllocatorBeginAddress">
            <summary>
            BeginAddress as per allocator, used in tests
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.TailAddress">
            <summary>
            Tail address of log
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.FlushedUntilAddress">
            <summary>
            Log flushed until address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.SafeTailAddress">
            <summary>
            Log safe read-only address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.CommittedUntilAddress">
            <summary>
            Log committed until address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.CommittedBeginAddress">
            <summary>
            Log committed begin address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.RecoveredCookie">
            <summary>
            Recovered Commit Cookie
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.HeaderSize">
            <summary>
            Header size used by TsavoriteLog
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.CommitTask">
            <summary>
            Task notifying commit completions
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.FlushEvent">
            <summary>
            Task notifying log flush completions
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.persistedCommitNum">
            <summary>
            Committed view of commitMetadataVersion
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.logRefCount">
            <summary>
            Number of references to log, including itself
            Used to determine disposability of log
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.SafeTailRefreshFrequencyMs">
            <summary>
            SafeTailAddress refresh frequency in milliseconds. -1 => disabled; 0 => immediate refresh after every enqueue, >1 => refresh period in milliseconds.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.safeTailRefreshTaskCts">
            <summary>
            CTS to allow cancellation of the safe tail refresh background task, called during Dispose
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.safeTailRefreshLastTailAddress">
            <summary>
            Last captured safe tail address before epoch bump
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.safeTailRefreshCallbackCompleted">
            <summary>
            Events to control callback execution
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.safeTailRefreshEntryEnqueued">
            <summary>
            Events to control callback execution
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.safeTailRefreshTask">
            <summary>
            Task corresponding to safe tail refresh
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.periodicRefreshSafeTailAddressBumpCallbackAction">
            <summary>
            Action for bump epoch to refresh safe tail
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.SafeTailShiftCallback">
            <summary>
            Callback when safe tail shifts
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLog.AutoCommit">
            <summary>
            Whether we automatically commit as records are inserted
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.MaxMemorySizeBytes">
            <summary>
            Maximum memory size in bytes
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.MemorySizeBytes">
            <summary>
            Actual memory used by log
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.#ctor(Tsavorite.core.TsavoriteLogSettings,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new log instance
            </summary>
            <param name="logSettings">Log settings</param>
            <param name="logger">Log settings</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.#ctor(Tsavorite.core.TsavoriteLogSettings,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new log instance
            </summary>
            <param name="logSettings">Log settings</param>
            <param name="syncRecover">Recover synchronously</param>
            <param name="logger">Log settings</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Reset">
            <summary>
            Reset TsavoriteLog to empty state
            WARNING: Run after database is quiesced
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.SafeInitialize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initialize new log instance safely by notifying readers that initialization is in progress.
            </summary>
            <param name="beginAddress"></param>
            <param name="committedUntilAddress"></param>
            <param name="lastCommitNum"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Initialize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initialize new log instance with specific begin address and (optional) last commit number
            </summary>
            <param name="beginAddress"></param>
            <param name="committedUntilAddress"></param>
            <param name="lastCommitNum"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Recover(System.Int64)">
            <summary>
            Recover TsavoriteLog to the specific commit number, or latest if -1
            </summary>
            <param name="requestedCommitNum">Requested commit number</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CreateAsync(Tsavorite.core.TsavoriteLogSettings,System.Threading.CancellationToken)">
            <summary>
            Create new log instance asynchronously
            </summary>
            <param name="logSettings"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CompleteLog(System.Boolean)">
            <summary>
            Mark the log as complete. A completed log will no longer allow enqueues, and all currently enqueued items will
            be immediately committed.
            </summary>
            <param name="spinWait"> whether to spin until log completion becomes committed </param>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLog.LogCompleted">
            <summary>
            Check if the log is complete. A completed log will no longer allow enqueues, and all currently enqueued items will
            be immediately committed.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue(System.Byte[])">
            <summary>
            Enqueue entry to log (in memory) - no guarantee of flush/commit
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Enqueue entry to log (in memory) - no guarantee of flush/commit
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeEnqueueRaw(System.ReadOnlySpan{System.Byte},System.Boolean)">
            <summary>
            Enqueue raw pre-formatted bytes with headers to the log (in memory).
            </summary>
            <param name="entryBytes">Raw bytes to be enqueued to log</param>
            <param name="noCommit">Do not auto-commit</param>
            <returns>First logical address of added entries</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeCommitMetadataOnly(Tsavorite.core.TsavoriteLogRecoveryInfo,System.Boolean)">
            <summary>
            Commit metadata only (no records added to main log)
            </summary>
            <param name="info"></param>
            <param name="isProtected"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeGetLogPageSizeBits">
            <summary>
            Get page size in bits
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeGetReadOnlyAddressLagOffset">
            <summary>
            Get read only lag address
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue(Tsavorite.core.IReadOnlySpanBatch)">
            <summary>
            Enqueue batch of entries to log (in memory) - no guarantee of flush/commit
            </summary>
            <param name="readOnlySpanBatch">Batch of entries to be enqueued to log</param>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``1(``0)">
            <summary>
            Enqueue batch of entries to log (in memory) - no guarantee of flush/commit
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enqueue batch of entries to log (in memory) - no guarantee of flush/commit
            </summary>
            <param name="entries">Batch of entries to be enqueued to log</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue``1(``0,System.Int64@)">
            <summary>
            Try to enqueue entry to log (in memory). If it returns true, we are
            done. If it returns false, we need to retry.
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <param name="logicalAddress">Logical address of added entry</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue``1(System.Collections.Generic.IEnumerable{``0},System.Int64@)">
            <summary>
            Try to enqueue batch of entries as a single atomic unit (to memory). Entire 
            batch needs to fit on one log page.
            </summary>
            <param name="entries">Batch to be appended to log</param>
            <param name="logicalAddress">Logical address of first added entry</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue(System.Byte[],System.Int64@)">
            <summary>
            Try to enqueue entry to log (in memory). If it returns true, we are
            done. If it returns false, we need to retry.
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeTryEnqueueRaw(System.ReadOnlySpan{System.Byte},System.Boolean,System.Int64@)">
            <summary>
            Try to enqueue raw pre-formatted bytes with headers to the log (in memory). If it returns true, we are
            done. If it returns false, we need to retry.
            </summary>
            <param name="entryBytes">Entry bytes to be enqueued to log</param>
            <param name="noCommit">Do not auto-commit</param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue(System.ReadOnlySpan{System.Byte},System.Int64@)">
            <summary>
            Try to append entry to log. If it returns true, we are
            done. If it returns false, we need to retry.
            </summary>
            <param name="entry">Entry to be appended to log</param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``1(``0,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``1(``0,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and one <see cref="T:Tsavorite.core.SpanByte"/> entry atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``2(``0,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,``1,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and two <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Append two <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``1(``0,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and three <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``2(``0,``1@,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and three <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="input"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``3(``0,Tsavorite.core.SpanByte@,``1@,``2,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and three <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="input"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue``3(``0,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,``1@,``2,System.Int64@)">
            <summary>
            Append a user-defined blittable struct header and three <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="input"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Enqueue(System.Byte,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Append a user-defined header byte and a <see cref="T:Tsavorite.core.SpanByte"/> entry atomically to the log.
            </summary>
            <param name="userHeader"></param>
            <param name="item"></param>
            <param name="logicalAddress">Logical address of added entry</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue``1(``0,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Try to append a user-defined blittable struct header and two <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            If it returns true, we are done. If it returns false, we need to retry.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue``1(``0,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Try to append a user-defined blittable struct header and three <see cref="T:Tsavorite.core.SpanByte"/> entries entries atomically to the log.
            If it returns true, we are done. If it returns false, we need to retry.
            </summary>
            <param name="userHeader"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue(System.Byte,Tsavorite.core.SpanByte@,System.Int64@)">
            <summary>
            Try to append a user-defined header byte and a <see cref="T:Tsavorite.core.SpanByte"/> entry atomically to the log. If it returns true, we are
            done. If it returns false, we need to retry.
            </summary>
            <param name="userHeader"></param>
            <param name="item"></param>
            <param name="logicalAddress">Logical address of added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryEnqueue(Tsavorite.core.IReadOnlySpanBatch,System.Int64@)">
            <summary>
            Try to enqueue batch of entries as a single atomic unit (to memory). Entire 
            batch needs to fit on one log page.
            </summary>
            <param name="readOnlySpanBatch">Batch to be appended to log</param>
            <param name="logicalAddress">Logical address of first added entry</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Enqueue entry to log in memory (async) - completes after entry is 
            appended to memory, NOT committed to storage.
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Enqueue entry to log in memory (async) - completes after entry is 
            appended to memory, NOT committed to storage.
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAsync(Tsavorite.core.IReadOnlySpanBatch,System.Threading.CancellationToken)">
            <summary>
            Enqueue batch of entries to log in memory (async) - completes after entry is 
            appended to memory, NOT committed to storage.
            </summary>
            <param name="readOnlySpanBatch">Batch to enqueue</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Enqueue entry to log in memory (async) - completes after entry is 
            appended to memory, NOT committed to storage.
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Enqueue batch of entries to log in memory (async) - completes after entry is 
            appended to memory, NOT committed to storage.
            </summary>
            <param name="entries">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of first added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.WaitForCommit(System.Int64,System.Int64)">
            <summary>
            Spin-wait until specified address (or tail) and commit num (or latest), to commit to 
            storage. Does NOT itself issue a commit, just waits for commit. So you should 
            ensure that someone else causes the commit to happen.
            </summary>
            <param name="untilAddress">Address until which we should wait for commit, default 0 for tail of log</param>
            <param name ="commitNum">CommitNum until which we should wait for commit, default -1 for latest as of now</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.WaitForCommitAsync(System.Int64,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Wait until specified address (or tail) and commit num (or latest), to commit to 
            storage. Does NOT itself issue a commit, just waits for commit. So you should 
            ensure that someone else causes the commit to happen.
            </summary>
            <param name="untilAddress">Address until which we should wait for commit, default 0 for tail of log</param>
            <param name ="commitNum">CommitNum until which we should wait for commit, default -1 for latest as of now</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.WaitUncommittedAsync(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Wait for more data to get added to the uncommitted tail of the log
            </summary>
            <returns>true if there's more data available to be read; false if there will never be more data (log has been shutdown)</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Commit(System.Boolean,System.Byte[])">
            <summary>
            Issue commit request for log (until tail)
            </summary>
            <param name="spinWait">If true, spin-wait until commit completes. Otherwise, issue commit and return immediately.</param>
            <returns> whether there is anything to commit. </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CommitStrongly(System.Int64@,System.Int64@,System.Boolean,System.Byte[],System.Int64,System.Action)">
            <summary>
            Issue a strong commit request for log (until tail) with the given commitNum. Strong commits bypass commit policies
            and will never be compressed with other concurrent commit requests.
            </summary>
            <param name="commitTail">The tail committed by this call</param>
            <param name="actualCommitNum">
            A unique, monotonically increasing identifier for the commit that can be used to recover to exactly this commit
            </param>
            <param name="spinWait">If true, spin-wait until commit completes. Otherwise, issue commit and return immediately</param>
            <param name="cookie">
            A custom piece of metadata to be associated with this commit. If commit is successful, any recovery from
            this commit will recover the cookie in RecoveredCookie field. Note that cookies are not stored by TsavoriteLog
            itself, so the user is responsible for tracking cookie content and supplying it to every commit call if needed
            </param>
            <param name="proposedCommitNum">
            Proposal for the identifier to use for this commit, or -1 if the system should pick one. If supplied with
            a non -1 value, commit is guaranteed to have the supplied identifier if commit call is successful
            </param>
            <param name="callback"> callback function that will be invoked when strong commit is persistent </param>
            <returns>Whether commit is successful </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CommitAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Async commit log (until tail), completes only when we 
            complete the commit. Throws exception if this or any 
            ongoing commit fails.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CommitAsync(System.Threading.Tasks.Task{Tsavorite.core.LinkedCommitInfo},System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Async commit log (until tail), completes only when we 
            complete the commit. Throws exception if any commit
            from prevCommitTask to current fails.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CommitStronglyAsync(System.Byte[],System.Int64,System.Threading.CancellationToken)">
            <summary>
            Issue commit request for log (until tail) with the given commitNum
            </summary>
            <param name="cookie">
            A custom piece of metadata to be associated with this commit. If commit is successful, any recovery from
            this commit will recover the cookie in RecoveredCookie field. Note that cookies are not stored by TsavoriteLog
            itself, so the user is responsible for tracking cookie content and supplying it to every commit call if needed
            </param>
            <param name="proposedCommitNum">
            Proposal for the identifier to use for this commit, or -1 if the system should pick one. If supplied with
            a non -1 value, commit is guaranteed to have the supplied identifier if commit call is successful
            </param>
            <param name="token">Cancellation token</param>
            <returns>Whether commit is successful, commit tail, and actual commit number</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommit(System.Byte[])">
            <summary>
            Append entry to log - spin-waits until entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommit(System.ReadOnlySpan{System.Byte})">
            <summary>
            Append entry to log - spin-waits until entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommit(Tsavorite.core.IReadOnlySpanBatch)">
            <summary>
            Append batch of entries to log - spin-waits until entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="readOnlySpanBatch"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommit``1(``0)">
            <summary>
            Append entry to log - spin-waits until entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry">Entry to be enqueued to log</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommit``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append entry to log - spin-waits until entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entries">Entries to be enqueued to log</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of first added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommitAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Append entry to log (async) - completes after entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommitAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Append entry to log (async) - completes after entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommitAsync(Tsavorite.core.IReadOnlySpanBatch,System.Threading.CancellationToken)">
            <summary>
            Append batch of entries to log (async) - completes after batch is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="readOnlySpanBatch"></param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommitAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Append entry to log (async) - completes after entry is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entry">Entry to enqueue</param>
            <param name="token">Cancellation token</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.EnqueueAndWaitForCommitAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Append batch of entries to log (async) - completes after batch is committed to storage.
            Does NOT itself issue flush!
            </summary>
            <param name="entries"> entries to enqueue</param>
            <param name="token">Cancellation token</param>
            <typeparam name="T">type of entry</typeparam>
            <returns>Logical address of added entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TruncateUntil(System.Int64)">
            <summary>
            Truncate the log until, but not including, untilAddress. **User should ensure
            that the provided address is a valid starting address for some record.** The
            truncation is not persisted until the next commit.
            </summary>
            <param name="untilAddress">Until address</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeShiftBeginAddress(System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Unsafely shift the begin address of the log and optionally truncate files on disk, without committing.
            Do not use unless you know what you are doing.
            </summary>
            <param name="untilAddress"></param>
            <param name="snapToPageStart"></param>
            <param name="truncateLog"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TruncateUntilPageStart(System.Int64)">
            <summary>
            Truncate the log until the start of the page corresponding to untilAddress. This is 
            safer than TruncateUntil, as page starts are always a valid truncation point. The
            truncation is not persisted until the next commit.
            </summary>
            <param name="untilAddress">Until address</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.Scan(System.Int64,System.Int64,System.Boolean,Tsavorite.core.ScanBufferingMode,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Pull-based iterator interface for scanning Tsavorite log
            </summary>
            <param name="beginAddress">Begin address for scan.</param>
            <param name="endAddress">End address for scan (or long.MaxValue for tailing).</param>
            <param name="recover">Whether to recover named iterator from latest commit (if exists). If false, iterator starts from beginAddress.</param>
            <param name="scanBufferingMode">Use single or double buffering</param>
            <param name="scanUncommitted">Whether we scan uncommitted data</param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.ReadAsync(System.Int64,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Random read record from log, at given address
            </summary>
            <param name="address">Logical address to read from</param>
            <param name="estimatedLength">Estimated length of entry, if known</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.ReadAsync(System.Int64,System.Buffers.MemoryPool{System.Byte},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Random read record from log as IMemoryOwner&lt;byte&gt;, at given address
            </summary>
            <param name="address">Logical address to read from</param>
            <param name="memoryPool">MemoryPool to rent the destination buffer from</param>
            <param name="estimatedLength">Estimated length of entry, if known</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.ReadRecordLengthAsync(System.Int64,System.Threading.CancellationToken)">
            <summary>
            Random read record from log, at given address
            </summary>
            <param name="address">Logical address to read from</param>
            <param name="token">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.DoAutoRefreshSafeTailAddress">
            <summary>
            Trigger refresh of safe tail address
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.CommitCallback(Tsavorite.core.CommitInfo)">
            <summary>
            Commit log
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.RecoverReadOnly">
            <summary>
            Synchronously recover instance to TsavoriteLog's latest valid commit, when being used as a readonly log iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.RecoverReadOnlyAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously recover instance to TsavoriteLog's latest commit, when being used as a readonly log iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.RestoreLatestAsync(System.Threading.CancellationToken)">
            <summary>
            Restore log asynchronously
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.TryAppend(Tsavorite.core.IReadOnlySpanBatch,System.Int64@,System.Int32@)">
            <summary>
            Try to append batch of entries as a single atomic unit. Entire batch
            needs to fit on one page.
            </summary>
            <param name="readOnlySpanBatch">Batch to be appended to log</param>
            <param name="logicalAddress">Logical address of first added entry</param>
            <param name="allocatedLength">Actual allocated length</param>
            <returns>Whether the append succeeded</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeGetLength(System.Byte*)">
            <summary>
            Get length of entry from pointer to header
            </summary>
            <param name="headerPtr"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLog.UnsafeAlign(System.Int32)">
            <summary>
            Get aligned version of record length
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.TsavoriteLogScanIterator">
            <summary>
            Scan iterator for hybrid log
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLogScanIterator.Ended">
            <summary>
            Whether iteration has ended, either because we reached the end address of iteration, or because
            we reached the end of a completed log.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.#ctor(Tsavorite.core.TsavoriteLog,Tsavorite.core.BlittableAllocatorImpl{Tsavorite.core.Empty,System.Byte,Tsavorite.core.StoreFunctions{Tsavorite.core.Empty,System.Byte,Tsavorite.core.EmptyKeyComparer,Tsavorite.core.DefaultRecordDisposer{Tsavorite.core.Empty,System.Byte}}},System.Int64,System.Int64,Tsavorite.core.GetMemory,Tsavorite.core.ScanBufferingMode,Tsavorite.core.LightEpoch,System.Int32,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
            <param name="tsavoriteLog"></param>
            <param name="hlog"></param>
            <param name="beginAddress"></param>
            <param name="endAddress"></param>
            <param name="scanBufferingMode"></param>
            <param name="epoch"></param>
            <param name="headerSize"></param>
            <param name="getMemory"></param>
            <param name="scanUncommitted"></param>
            <param name="logger"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetAsyncEnumerable(System.Threading.CancellationToken)">
            <summary>
            Async enumerable for iterator
            </summary>
            <returns>Entry, actual entry length, logical address of entry, logical address of next entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetAsyncEnumerable(System.Buffers.MemoryPool{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Async enumerable for iterator (memory pool based version)
            </summary>
            <returns>Entry, actual entry length, logical address of entry, logical address of next entry</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.ConsumeAllAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Asynchronously consume the log with given consumer until end of iteration or cancelled
            </summary>
            <param name="consumer"> consumer </param>
            <param name="token"> cancellation token </param>
            <typeparam name="T"> consumer type </typeparam>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.BulkConsumeAllAsync``1(``0,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously consume the log with given consumer until end of iteration or cancelled
            </summary>
            <param name="consumer"> consumer </param>
            <param name="throttleMs">throttle the iteration speed</param>
            <param name="maxChunkSize">max size of returned chunk</param>
            <param name="token"> cancellation token </param>
            <typeparam name="T"> consumer type </typeparam>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Wait for iteration to be ready to continue
            </summary>
            <returns>true if there's more data available to be read; false if there will never be more data (log has been shutdown / iterator has reached endAddress)</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetNext(System.Byte[]@,System.Int32@,System.Int64@)">
            <summary>
            Get next record in iterator
            </summary>
            <param name="entry">Copy of entry, if found</param>
            <param name="entryLength">Actual length of entry</param>
            <param name="currentAddress">Logical address of entry</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetNext(System.Byte[]@,System.Int32@,System.Int64@,System.Int64@)">
            <summary>
            Get next record in iterator
            </summary>
            <param name="entry">Copy of entry, if found</param>
            <param name="entryLength">Actual length of entry</param>
            <param name="currentAddress">Logical address of entry</param>
            <param name="nextAddress">Logical address of next entry</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetNext(System.Buffers.MemoryPool{System.Byte},System.Buffers.IMemoryOwner{System.Byte}@,System.Int32@,System.Int64@)">
            <summary>
            GetNext supporting memory pools
            </summary>
            <param name="pool">Memory pool</param>
            <param name="entry">Copy of entry, if found</param>
            <param name="entryLength">Actual length of entry</param>
            <param name="currentAddress">Logical address of entry</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetNext(System.Buffers.MemoryPool{System.Byte},System.Buffers.IMemoryOwner{System.Byte}@,System.Int32@,System.Int64@,System.Int64@)">
            <summary>
            GetNext supporting memory pools
            </summary>
            <param name="pool">Memory pool</param>
            <param name="entry">Copy of entry, if found</param>
            <param name="entryLength">Actual length of entry</param>
            <param name="currentAddress">Logical address of entry</param>
            <param name="nextAddress">Logical address of next entry</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.TryConsumeNext``1(``0)">
            <summary>
            Consume the next entry in the log with the given consumer
            </summary>
            <param name="consumer">consumer</param>
            <typeparam name="T">concrete type of consumer</typeparam>
            <returns>whether a next entry is present</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.TryBulkConsumeNext``1(``0,System.Int32)">
            <summary>
            Consume the next entry in the log with the given consumer
            </summary>
            <param name="consumer">consumer</param>
            <param name="maxChunkSize"></param>
            <typeparam name="T">concrete type of consumer</typeparam>
            <returns>whether a next entry is present</returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.UnsafeGetNext(System.Byte*@,System.Int32@,System.Int64@,System.Int64@)">
            <summary>
            WARNING: advanced users only.
            Get next record in iterator, accessing unsafe raw bytes and retaining epoch protection.
            Make sure to call UnsafeRelease when done processing the raw bytes (without delay).
            </summary>
            <param name="entry">Copy of entry, if found</param>
            <param name="entryLength">Actual length of entry</param>
            <param name="currentAddress">Logical address of entry</param>
            <param name="nextAddress">Logical address of next entry</param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.UnsafeRelease">
            <summary>
            WARNING: advanced users only.
            Release a native memory reference obtained via a successful UnsafeGetNext.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.Dispose">
            <summary>
            Dispose the iterator
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogScanIterator.GetNextInternal(System.Int64@,System.Int32@,System.Int64@,System.Int64@,System.Boolean@,System.Boolean@)">
            <summary>
            Retrieve physical address of next iterator value
            (under epoch protection if it is from main page buffer)
            </summary>
            <param name="physicalAddress"></param>
            <param name="entryLength"></param>
            <param name="currentAddress"></param>
            <param name="outNextAddress"></param>
            <param name="commitRecord"></param>
            <param name="onFrame"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.TsavoriteLogRecoveryInfo">
            <summary>
            Recovery info for Tsavorite Log
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.TsavoriteLogRecoveryVersion">
            <summary>
            TsavoriteLog recovery version
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.BeginAddress">
            <summary>
            Begin address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.UntilAddress">
            <summary>
            Flushed logical address
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.Cookie">
            <summary>
            User-specified commit cookie
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.CommitNum">
            <summary>
            commit num unique to this commit request
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.FastForwardAllowed">
            <summary>
            whether this request is from a strong commit
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogRecoveryInfo.Callback">
            <summary>
            callback to invoke when commit is presistent
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.Initialize">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.Initialize(System.ReadOnlySpan{System.Byte})">
            <summary>
            Initialize from stream
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.ToByteArray">
            <summary>
            Write info to byte array
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.SerializedSize">
            <summary>
            </summary>
            <returns> size of this recovery info serialized </returns>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogRecoveryInfo.DebugPrint">
            <summary>
            Print checkpoint info for debugging purposes
            </summary>
        </member>
        <member name="T:Tsavorite.core.TsavoriteLogScanSingleIterator">
            <summary>
            Scan iterator for hybrid log - only a single scan is supported per instance
            This modification allows us to use a SingleWaiterAutoResetEvent per iterator
            so we can avoid TCS allocations per tail bump.
            </summary>
        </member>
        <member name="T:Tsavorite.core.GetMemory">
            <summary>
            Delegate for getting memory from user
            </summary>
            <param name="minLength">Minimum length of returned byte array</param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.LogChecksumType">
            <summary>
            Type of checksum to add to log
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogChecksumType.None">
            <summary>
            No checksums
            </summary>
        </member>
        <member name="F:Tsavorite.core.LogChecksumType.PerEntry">
            <summary>
            Checksum per entry
            </summary>
        </member>
        <member name="T:Tsavorite.core.TsavoriteLogSettings">
            <summary>
            Tsavorite Log Settings
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.LogDevice">
            <summary>
            Device used for log
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.PageSize">
            <summary>
            Size of a page, in bits
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLogSettings.PageSizeBits">
            <summary>
            Support bit-based setting of page size for backward compatibility, use PageSize directly for simplicity.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.MemorySize">
            <summary>
            Total size of in-memory part of log, in bits
            Should be at least one page long
            Num pages = 2^(MemorySizeBits-PageSizeBits)
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLogSettings.MemorySizeBits">
            <summary>
            Support bit-based setting of memory size for backward compatibility, use MemorySize directly for simplicity.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.SegmentSize">
            <summary>
            Size of a segment (group of pages), in bits
            This is the granularity of files on disk
            </summary>
        </member>
        <member name="P:Tsavorite.core.TsavoriteLogSettings.SegmentSizeBits">
            <summary>
            Support bit-based setting of segment size for backward compatibility, use SegmentSize directly for simplicity.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.LogCommitManager">
            <summary>
            Log commit manager - if you want to override the default implementation of commit.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.LogCommitDir">
            <summary>
            Use specified directory (path) as base for storing and retrieving log commits. By default,
            commits will be stored in a folder named log-commits under this directory. If not provided, 
            we use the base path of the log device by default.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.GetMemory">
            <summary>
            User callback to allocate memory for read entries
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.LogChecksum">
            <summary>
            Type of checksum to add to log
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.MutableFraction">
            <summary>
            Fraction of log marked as mutable (uncommitted)
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.ReadOnlyMode">
            <summary>
            Use TsavoriteLog as read-only iterator/viewer of log being committed by another instance
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.FastCommitMode">
            <summary>
            When FastCommitMode is enabled, TsavoriteLog will reduce commit critical path latency, but may result in slower
            recovery to a commit on restart. Additionally, FastCommitMode is only possible when log checksum is turned
            on.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.RemoveOutdatedCommits">
            <summary>
            When true, we automatically delete commit files that are covered by a successful subsequent commit, and during
            recovery we delete all commit files other than the one we have recovered to.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.LogCommitPolicy">
            <summary>
            Log commit policy that influences the behavior of Commit() calls.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.TryRecoverLatest">
            <summary>
            Try to recover from latest commit, if available
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.SafeTailRefreshFrequencyMs">
            <summary>
            SafeTailAddress refresh frequency in milliseconds. -1 => disabled; 0 => immediate refresh after every enqueue, >1 => refresh period in milliseconds.
            </summary>
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.AutoCommit">
            <summary>
            Whether we automatically commit the log as records are inserted
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogSettings.#ctor">
            <summary>
            Create default configuration settings for TsavoriteLog. You need to create and specify LogDevice 
            explicitly with this API.
            Use Utility.ParseSize to specify sizes in familiar string notation (e.g., "4k" and "4 MB").
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogSettings.#ctor(System.String,System.Boolean)">
            <summary>
            Create default configuration backed by local storage at given base directory.
            Use Utility.ParseSize to specify sizes in familiar string notation (e.g., "4k" and "4 MB").
            Default index size is 64MB.
            </summary>
            <param name="baseDir">Base directory (without trailing path separator)</param>
            <param name="deleteDirOnDispose">Whether to delete base directory on dispose. This option prevents later recovery.</param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogSettings.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.TsavoriteLogSettings.ToString">
            <inheritdoc />
        </member>
        <member name="F:Tsavorite.core.TsavoriteLogSettings.TolerateDeviceFailure">
             <summary>
             TsavoriteLog throws CommitFailureException on non-zero IDevice error codes. If TolerateDeviceFailure, TsavoriteLog
             will permit operations and commits to proceed as normal after the exception is thrown, even if committed
             data may be lost as a result of the error. Otherwise, TsavoriteLog enters a permanently errored state and
             prevents future operations until restarted (on a repaired IDevice).
            
             WARNING: TOLERATING DEVICE FAILURE CAN LEAD TO DATA LOSS OR CORRUPTION AND IS FOR ADVANCED USERS ONLY
             </summary>
        </member>
        <member name="T:Tsavorite.core.AsyncCountDown">
            <summary>
            Offers reactivity about when a counter reaches zero
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncCountDown.Add">
            <summary>
            Increments the counter by 1
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncCountDown.Remove">
            <summary>
            Decrements the counter by 1
            </summary>
        </member>
        <member name="P:Tsavorite.core.AsyncCountDown.IsEmpty">
            <summary>
            Check if countdown is empty
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncCountDown.WaitUntilEmptyAsync(System.Threading.CancellationToken)">
            <summary>
            Provides a way to execute a continuation when the counter reaches zero
            </summary>
            <returns>A Task that completes when the counter reaches zero</returns>
        </member>
        <member name="T:Tsavorite.core.AsyncQueue`1">
            <summary>
            Async queue
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Tsavorite.core.AsyncQueue`1.Count">
            <summary>
            Queue count
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Enqueue item
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Async dequeue
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.WaitForEntry">
            <summary>
            Wait for queue to have at least one entry
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.WaitForEntryAsync(System.Threading.CancellationToken)">
            <summary>
            Wait for queue to have at least one entry
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Try dequeue (if item exists)
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.SectorAlignedMemory">
            <summary>
            Sector aligned memory allocator
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.buffer">
            <summary>
            Actual buffer
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.handle">
            <summary>
            Handle
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.offset">
            <summary>
            Offset
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.aligned_pointer">
            <summary>
            Aligned pointer
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.valid_offset">
            <summary>
            Valid offset
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.required_bytes">
            <summary>
            Required bytes
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedMemory.available_bytes">
            <summary>
            Available bytes
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.#ctor(System.Int32)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.#ctor(System.Int32,System.Int32)">
            <summary>
            Create new instance of SectorAlignedMemory
            </summary>
            <param name="numRecords"></param>
            <param name="sectorSize"></param>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.Return">
            <summary>
            Return
            </summary>
        </member>
        <member name="P:Tsavorite.core.SectorAlignedMemory.AlignedTotalCapacity">
            <summary>
            Get the total aligned memory capacity of the buffer
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.GetValidPointer">
            <summary>
            Get valid pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedMemory.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.SectorAlignedBufferPool">
            <summary>
            SectorAlignedBufferPool is a pool of memory. 
            Internally, it is organized as an array of concurrent queues where each concurrent
            queue represents a memory of size in particular range. queue[i] contains memory 
            segments each of size (2^i * sectorSize).
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedBufferPool.Disabled">
            <summary>
            Disable buffer pool.
            This static option should be enabled on program entry, and not modified once Tsavorite is instantiated.
            </summary>
        </member>
        <member name="F:Tsavorite.core.SectorAlignedBufferPool.UnpinOnReturn">
            <summary>
            Unpin objects when they are returned to the pool, so that we do not hold pinned objects long term.
            If set, we will unpin when objects are returned and re-pin when objects are returned from the pool.
            This static option should be enabled on program entry, and not modified once Tsavorite is instantiated.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedBufferPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="recordSize">Record size. May be 1 if allocations of different lengths will be made</param>
            <param name="sectorSize">Sector size, e.g. from log device</param>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedBufferPool.Return(Tsavorite.core.SectorAlignedMemory)">
            <summary>
            Return
            </summary>
            <param name="page"></param>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedBufferPool.Get(System.Int32)">
            <summary>
            Get buffer
            </summary>
            <param name="numRecords"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedBufferPool.Free">
            <summary>
            Free buffer
            </summary>
        </member>
        <member name="M:Tsavorite.core.SectorAlignedBufferPool.Print">
            <summary>
            Print pool contents
            </summary>
        </member>
        <member name="M:Tsavorite.core.CompletionEvent.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.LockType">
            <summary>
            Type of lock taken by Tsavorite on Read, Upsert, RMW, or Delete operations, either directly or within concurrent callback operations
            </summary>
        </member>
        <member name="F:Tsavorite.core.LockType.None">
            <summary>
            No lock
            </summary>
        </member>
        <member name="F:Tsavorite.core.LockType.Exclusive">
            <summary>
            Exclusive lock, taken on Upsert, RMW, or Delete
            </summary>
        </member>
        <member name="F:Tsavorite.core.LockType.Shared">
            <summary>
            Shared lock, taken on Read
            </summary>
        </member>
        <member name="T:Tsavorite.core.ILockableKey">
            <summary>
            Interface that must be implemented to participate in keyHash-based locking.
            </summary>
        </member>
        <member name="P:Tsavorite.core.ILockableKey.KeyHash">
            <summary>
            The hash code for a specific key, obtained from <see cref="M:Tsavorite.core.ITsavoriteContext`1.GetKeyHash(`0@)"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.ILockableKey.LockType">
            <summary>
            The lock type for a specific key
            </summary>
        </member>
        <member name="T:Tsavorite.core.FixedLengthLockableKeyStruct`1">
            <summary>
            A utility class to carry a fixed-length key (blittable or object type) and its assciated info for Locking
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="F:Tsavorite.core.FixedLengthLockableKeyStruct`1.Key">
            <summary>
            The key that is acquiring or releasing a lock
            </summary>
        </member>
        <member name="P:Tsavorite.core.FixedLengthLockableKeyStruct`1.KeyHash">
            <inheritdoc/>
        </member>
        <member name="P:Tsavorite.core.FixedLengthLockableKeyStruct`1.LockType">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.#ctor(`0,Tsavorite.core.LockType,Tsavorite.core.ITsavoriteContext{`0})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.#ctor(`0@,Tsavorite.core.LockType,Tsavorite.core.ITsavoriteContext{`0})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.#ctor(`0,System.Int64,Tsavorite.core.LockType,Tsavorite.core.ILockableContext{`0})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.#ctor(`0@,System.Int64,Tsavorite.core.LockType,Tsavorite.core.ILockableContext{`0})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.Sort(Tsavorite.core.FixedLengthLockableKeyStruct{`0}[],Tsavorite.core.ILockableContext{`0})">
            <summary>
            Sort the passed key array for use in <see cref="M:Tsavorite.core.ILockableContext`1.Lock``1(System.ReadOnlySpan{``0})"/>
            and <see cref="M:Tsavorite.core.ILockableContext`1.Unlock``1(System.ReadOnlySpan{``0})"/>
            </summary>
            <param name="keys"></param>
            <param name="context"></param>
        </member>
        <member name="M:Tsavorite.core.FixedLengthLockableKeyStruct`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.LockState">
            <summary>
            Lock state of a record
            </summary>
        </member>
        <member name="T:Tsavorite.core.Native32">
            <summary>
            Interop with WINAPI for file I/O, threading, and NUMA functions.
            </summary>
        </member>
        <member name="M:Tsavorite.core.Native32.GetLogicalProcessorsPerCore">
            <summary>
            Gets the number of logical processors per physical core (e.g., 2 for hyperthreading).
            </summary>
        </member>
        <member name="M:Tsavorite.core.Native32.AffinitizeThreadRoundRobin(System.UInt32,System.Boolean)">
            <summary>
            Accepts thread id = 0, 1, 2, ... and sprays them round-robin
            across all cores (viewed as a flat space). On NUMA machines,
            this gives us [socket, core] ordering of affinitization. That is, 
            if there are N cores per socket, then thread indices of 0 to N-1 map
            to the range [socket 0, core 0] to [socket 0, core N-1].
            </summary>
            <param name="threadIdx">Index of thread (from 0 onwards)</param>
        </member>
        <member name="M:Tsavorite.core.Native32.GetNumGroupsProcsPerGroup">
            <summary>
            Get number of groups (sockets) and processors per group
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Native32.AffinitizeThreadShardedNuma(System.UInt32,System.UInt16)">
            <summary>
            Accepts thread id = 0, 1, 2, ... and sprays them round-robin
            across all cores (viewed as a flat space). On NUMA machines,
            this gives us [core, socket] ordering of affinitization. That is, 
            if there are N cores per socket, then thread indices of 0 to N-1 map
            to the range [socket 0, core 0] to [socket N-1, core 0].
            </summary>
            <param name="threadIdx">Index of thread (from 0 onwards)</param>
            <param name="nrOfProcessorGroups">Number of NUMA sockets</param>
        </member>
        <member name="M:Tsavorite.core.Native32.EnableProcessPrivileges">
            <summary>
            Enable privilege for process
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Native32.SetFileSize(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64)">
            <summary>
            Set file size
            </summary>
            <param name="file_handle"></param>
            <param name="file_size"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.OverflowPool`1">
            <summary>
            Fixed size pool of overflow objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Tsavorite.core.OverflowPool`1.Count">
            <summary>
            Number of pages in pool
            </summary>
        </member>
        <member name="M:Tsavorite.core.OverflowPool`1.#ctor(System.Int32,System.Action{`0})">
            <summary>
            Constructor
            </summary>
            <param name="size"></param>
            <param name="disposer"></param>
        </member>
        <member name="M:Tsavorite.core.OverflowPool`1.TryGet(`0@)">
            <summary>
            Try get overflow item, if it exists
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.OverflowPool`1.TryAdd(`0)">
            <summary>
            Try to add overflow item to pool
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Tsavorite.core.OverflowPool`1.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Tsavorite.core.PageAsyncReadResult`1">
            <summary>
            Result of async page read
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="M:Tsavorite.core.PageAsyncReadResult`1.Free">
            <summary>
            Free
            </summary>
        </member>
        <member name="T:Tsavorite.core.FlushCompletionTracker">
            <summary>
            Shared flush completion tracker, when bulk-flushing many pages
            </summary>
        </member>
        <member name="F:Tsavorite.core.FlushCompletionTracker.completedSemaphore">
            <summary>
            Semaphore to set on flush completion
            </summary>
        </member>
        <member name="F:Tsavorite.core.FlushCompletionTracker.flushSemaphore">
            <summary>
            Semaphore to wait on for flush completion
            </summary>
        </member>
        <member name="F:Tsavorite.core.FlushCompletionTracker.count">
            <summary>
            Number of pages being flushed
            </summary>
        </member>
        <member name="M:Tsavorite.core.FlushCompletionTracker.#ctor(System.Threading.SemaphoreSlim,System.Threading.SemaphoreSlim,System.Int32)">
            <summary>
            Create a flush completion tracker
            </summary>
            <param name="completedSemaphore">Semaphpore to release when all flushes completed</param>
            <param name="flushSemaphore">Semaphpore to release when each flush completes</param>
            <param name="count">Number of pages to flush</param>
        </member>
        <member name="M:Tsavorite.core.FlushCompletionTracker.CompleteFlush">
            <summary>
            Complete flush of one page
            </summary>
        </member>
        <member name="T:Tsavorite.core.PageAsyncFlushResult`1">
            <summary>
            Page async flush result
            </summary>
            <typeparam name="TContext"></typeparam>
        </member>
        <member name="F:Tsavorite.core.PageAsyncFlushResult`1.page">
            <summary>
            Page
            </summary>
        </member>
        <member name="F:Tsavorite.core.PageAsyncFlushResult`1.context">
            <summary>
            Context
            </summary>
        </member>
        <member name="F:Tsavorite.core.PageAsyncFlushResult`1.count">
            <summary>
            Count
            </summary>
        </member>
        <member name="M:Tsavorite.core.PageAsyncFlushResult`1.Free">
            <summary>
            Free
            </summary>
        </member>
        <member name="T:Tsavorite.core.SafeConcurrentDictionary`2">
            <summary>
            A dictionary that supports concurrency with similar interface to .NET's ConcurrentDictionary.
            However, this dictionary changes the implementation of AddOrUpdate and GetOrAdd functions to
            guarantee atomicity per-key for factory lambdas.
            </summary>
            <typeparam name="TKey">Type of keys in the dictionary</typeparam>
            <typeparam name="TValue">Type of values in the dictionary</typeparam>
        </member>
        <member name="P:Tsavorite.core.SafeConcurrentDictionary`2.Count">
            <summary>
            Returns the count of the dictionary.
            </summary>
        </member>
        <member name="P:Tsavorite.core.SafeConcurrentDictionary`2.IsEmpty">
            <summary>
            Returns whether or not the dictionary is empty.
            </summary>
        </member>
        <member name="P:Tsavorite.core.SafeConcurrentDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with a key.
            </summary>
        </member>
        <member name="P:Tsavorite.core.SafeConcurrentDictionary`2.Keys">
            <summary>
            Returns a collection of the keys in the dictionary.
            </summary>
        </member>
        <member name="P:Tsavorite.core.SafeConcurrentDictionary`2.Values">
            <summary>
            Returns a collection of the values in the dictionary.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds or updates a key/value pair to the dictionary.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds or updates a key/value pair to the dictionary.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the dictionary if it does not exist.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the dictionary if it does not exist.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.ContainsKey(`0)">
            <summary>
            Returns whether or not the dictionary contains the specified key.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator of the elements in the dictionary.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.ToArray">
            <summary>
            Copies the key/value pairs to a new array.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the specified key/value to the dictionary if it does not exist.
            Returns true or false depending on if the value was added or not, respectively.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value for the specified key.
            Returns true if the key was in the dictionary or false otherwise.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove the value for the specified key.
            Returns true if the key was in the dictionary or false otherwise.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.TryRemoveConditional(`0,`1@)">
            <summary>
            Attempts to remove the value for the specified key based on equality to <paramref name="ifValue"/>.
            Returns true if successful, false otherwise (value changed or key not found).
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>
            Compares the existing value for the specified key with a specified value,
            and updates it if and only if it is a match. Returns true is updated or
            false otherwise.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SafeConcurrentDictionary`2.GetLock(`0)">
            <summary>
            Retrieves lock associated with a key (creating it if it does not exist).
            </summary>
        </member>
        <member name="T:Tsavorite.core.RecordStatus">
            <summary>
            Status result of operation on Tsavorite
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordStatus.Created">
            <summary>
            Whether a new record for a previously non-existent key was appended to the log.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordStatus.InPlaceUpdated">
            <summary>
            Whether an existing record was updated in place.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordStatus.CopyUpdated">
            <summary>
            Whether an existing record key was copied, updated, and appended to the log.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordStatus.Copied">
            <summary>
            Whether an existing record key was copied and appended to the log.
            </summary>
        </member>
        <member name="P:Tsavorite.core.RecordStatus.CopiedToReadCache">
            <summary>
            Whether an existing record key was copied, updated, and added to the readcache.
            </summary>
        </member>
        <member name="T:Tsavorite.core.Status">
            <summary>
            Status result of operation on Tsavorite
            </summary>
        </member>
        <member name="F:Tsavorite.core.Status.Record">
            <summary>
            Status specific to the record
            </summary>
        </member>
        <member name="M:Tsavorite.core.Status.#ctor(Tsavorite.core.StatusCode)">
            <summary>
            Create status from given status code
            </summary>
            <param name="statusCode"></param>
        </member>
        <member name="M:Tsavorite.core.Status.CreateFound">
            <summary>
            Create a <see cref="P:Tsavorite.core.Status.Found"/> Status value.
            </summary>
        </member>
        <member name="M:Tsavorite.core.Status.CreatePending">
            <summary>
            Create a <see cref="P:Tsavorite.core.Status.IsPending"/> Status value. Use the Is* properties to query.
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.Found">
            <summary>
            Whether a Read or RMW found the key
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.NotFound">
            <summary>
            Whether a Read or RMW did not find the key
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.IsPending">
            <summary>
            Whether the operation went pending
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.IsCompleted">
            <summary>
            Whether the operation went pending
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.IsFaulted">
            <summary>
            Whether the operation is in an error state
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.IsCanceled">
            <summary>
            Whether the operation was canceled
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.Expired">
            <summary>
            Whether the operation found an expired record
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.IsCompletedSuccessfully">
            <summary>
            Whether the operation completed successfully, i.e., it is not pending and did not error out
            </summary>
        </member>
        <member name="P:Tsavorite.core.Status.Value">
            <summary>
            Get the underlying status code value
            </summary>
        </member>
        <member name="M:Tsavorite.core.Status.ToString">
            <inheritdoc />
            <remarks>"Found" is zero, so does not appear in the output by default; this handles that explicitly</remarks>
        </member>
        <member name="T:Tsavorite.core.StatusCode">
            <summary>
            Return status code for Tsavorite operations
            These are the basic codes that correspond to the old Status values, but *do not* compare to these directly; use the IsXxx functions.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StatusCode.Found">
            <summary>
            General success indicator. By itself it means they key for the operation was found; it may have been updated in place or copied to the log tail.
            </summary>
            <remarks>
            <list type="bullet">
            <item>Upsert ConcurrentWriter: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.InPlaceUpdatedRecord"/></item>
            <item>RMW InPlaceUpdater: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.InPlaceUpdatedRecord"/></item>
            <item>RMW CopyUpdater: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.CopyUpdatedRecord"/></item>
            <list type="bullet">
              <item>If NeedCopyUpdate returns false: <see cref="F:Tsavorite.core.StatusCode.Found"/></item>
            </list>
            <item>Delete ConcurrentDeleter: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.InPlaceUpdatedRecord"/></item>
            <item>Read ConcurrentReader: <see cref="F:Tsavorite.core.StatusCode.Found"/></item>
            <list type="bullet">
              <item>If in immutable region and copying to tail: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.CopiedRecord"/></item>
            </list>
            <item>Read Pending to SingleReader: <see cref="F:Tsavorite.core.StatusCode.Found"/></item>
            <list type="bullet">
              <item>If copying to tail: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.CopiedRecord"/></item>
              <item>If copying to readCache: <see cref="F:Tsavorite.core.StatusCode.Found"/> | <see cref="F:Tsavorite.core.StatusCode.CopiedRecordToReadCache"/></item>
            </list>
            </list>
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.NotFound">
            <summary>
            The key for the operation was not found. For Read, that is all that is returned for an unfound key. For other operations, see
            the advanced enum values for more detailed information.
            </summary>
            <remarks>
            <list type="bullet">
            <item>Upsert SingleWriter (not found in mutable region): <see cref="F:Tsavorite.core.StatusCode.NotFound"/> | <see cref="F:Tsavorite.core.StatusCode.CreatedRecord"/></item>
            <item>RMW InitialUpdater (not found in mutable, immutable, or on-disk regions): <see cref="F:Tsavorite.core.StatusCode.NotFound"/> | <see cref="F:Tsavorite.core.StatusCode.CreatedRecord"/></item>
            <list type="bullet">
              <item>If NeedInitialUpdate returns false: <see cref="F:Tsavorite.core.StatusCode.NotFound"/></item>
            </list>
            <item>Delete SingleDeleter (not found in mutable region): <see cref="F:Tsavorite.core.StatusCode.NotFound"/> | <see cref="F:Tsavorite.core.StatusCode.CreatedRecord"/></item>
            </list>
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.Canceled">
            <summary>
            The operation was canceled (e.g. by an ISessionFunctions method setting info.CancelOperation). This is not combined with advanced enum values.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StatusCode.Pending">
            <summary>
            The Read or RMW operation went pending for I/O. This is not combined with advanced enum values; however, the application should
            use this to issue CompletePending operations, and then can apply knowledge of this to the advanced enum values to know whether,
            for example, a <see cref="F:Tsavorite.core.StatusCode.CopyUpdatedRecord"/> was a copy of a record from the ReadOnly in-memory region or from Storage.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StatusCode.Error">
            <summary>
            An error occurred. This is not combined with advanced enum values.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StatusCode.CreatedRecord">
            <summary>
            Indicates that a new record for a previously non-existent key was appended to the log.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.InPlaceUpdatedRecord">
            <summary>
            Indicates that an existing record was updated in place.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.CopyUpdatedRecord">
            <summary>
            Indicates that an existing record key was copied, updated, and appended to the log.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.CopiedRecord">
            <summary>
            Indicates that an existing record key was copied and appended to the log.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.CopiedRecordToReadCache">
            <summary>
            Indicates that an existing record key was copied, updated, and added to the readcache.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="F:Tsavorite.core.StatusCode.RecordStatusMask">
            <summary>
            Individual record-status values that are not masked together.
            </summary>
        </member>
        <member name="F:Tsavorite.core.StatusCode.Expired">
            <summary>
            Indicates that an existing record key was auto-expired. This is a flag that is combined with RecordStatusMask values.
            </summary>
            <remarks>
            See basic codes for details of usage.
            </remarks>
        </member>
        <member name="T:Tsavorite.core.TsavoriteException">
            <summary>
            Tsavorite exception base type
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteException.#ctor">
            <summary>
            Throw Tsavorite exception
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteException.#ctor(System.String)">
            <summary>
            Throw Tsavorite exception with message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Tsavorite.core.TsavoriteException.#ctor(System.String,System.Exception)">
            <summary>
            Throw Tsavorite exception with message and inner exception
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Tsavorite.core.TsavoriteIOException">
            <summary>
            Tsavorite IO exception type with message and inner exception
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteIOException.#ctor(System.String,System.Exception)">
            <summary>
            Throw Tsavorite exception
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Tsavorite.core.TsavoriteNoHybridLogException">
            <summary>
            TsavoriteNoHybridLog exception type with message and inner exception.
            </summary>
        </member>
        <member name="M:Tsavorite.core.TsavoriteNoHybridLogException.#ctor(System.String)">
            <summary>
            Throw Tsavorite exception
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Tsavorite.core.Empty">
            <summary>
            Empty type
            </summary>
        </member>
        <member name="F:Tsavorite.core.Empty.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="T:Tsavorite.core.Utility">
            <summary>
            Tsavorite utility functions
            </summary>
        </member>
        <member name="M:Tsavorite.core.Utility.ParseSize(System.String)">
            <summary>
            Parse size in string notation into long.
            Examples: 4k, 4K, 4KB, 4 KB, 8m, 8MB, 12g, 12 GB, 16t, 16 TB, 32p, 32 PB.
            </summary>
            <param name="value">String version of number</param>
            <returns>The number</returns>
        </member>
        <member name="M:Tsavorite.core.Utility.NumBitsPreviousPowerOf2(System.Int64,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Num bits in the previous power of 2 for specified number
            </summary>
            <param name="v"></param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.PreviousPowerOf2(System.Int64)">
            <summary>
            Previous power of 2
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.PrettySize(System.Int64)">
            <summary>
            Pretty print value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.RoundUp(System.Int32,System.Int32)">
            <summary>Rounds up value to alignment</summary>
            <param name="value">Value to be aligned</param>
            <param name="alignment">Align to this</param>
            <returns>Aligned value</returns>
        </member>
        <member name="M:Tsavorite.core.Utility.IsBlittable``1">
            <summary>
            Is type blittable
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.GetHashCode(System.Int64)">
            <summary>
            Get 64-bit hash code for a long value
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.HashBytes(System.Byte*,System.Int32)">
            <summary>
            Get 64-bit hash code for a byte array
            </summary>
            <param name="pbString"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.XorBytes(System.Byte*,System.Int32)">
            <summary>
            Compute XOR of all provided bytes
            </summary>
            <param name="src"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.Rotr64(System.UInt64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperations.RotateRight(System.UInt64,System.Int32)"/>
        </member>
        <member name="M:Tsavorite.core.Utility.IsPowerOfTwo(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.UInt64)"/>
        </member>
        <member name="M:Tsavorite.core.Utility.GetLogBase2(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperations.Log2(System.UInt32)"/>
        </member>
        <member name="M:Tsavorite.core.Utility.GetLogBase2(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperations.Log2(System.UInt64)"/>
        </member>
        <member name="M:Tsavorite.core.Utility.Is32Bit(System.Int64)">
            <summary>
            Check if power of two
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.Murmur3(System.Int32)">
            <summary>
            A 32-bit murmur3 implementation.
            </summary>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.Utility.MonotonicUpdate(System.Int64@,System.Int64,System.Int64@)">
            <summary>
            Updates the variable to newValue only if the current value is smaller than the new value.
            </summary>
            <param name="variable">The variable to possibly replace</param>
            <param name="newValue">The value that replaces the variable if successful</param>
            <param name="oldValue">The orignal value in the variable</param>
            <returns> if oldValue less than newValue </returns>
        </member>
        <member name="M:Tsavorite.core.Utility.MonotonicUpdate(System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Updates the variable to newValue only if the current value is smaller than the new value.
            </summary>
            <param name="variable">The variable to possibly replace</param>
            <param name="newValue">The value that replaces the variable if successful</param>
            <param name="oldValue">The orignal value in the variable</param>
            <returns>if oldValue less than or equal to newValue</returns>
        </member>
        <member name="M:Tsavorite.core.Utility.WithCancellationAsync``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Throws OperationCanceledException if token cancels before the real task completes.
            Doesn't abort the inner task, but allows the calling code to get "unblocked" and react to stuck tasks.
            </summary>
        </member>
        <member name="M:Tsavorite.core.Utility.GetCurrentMilliseconds">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:Tsavorite.core.IVariableLengthInput`2">
            <summary>
            Interface for variable length Inputs to RMW; only implemented for <typeparamref name="TValue"/> of <see cref="T:Tsavorite.core.SpanByte"/>.
            </summary>
        </member>
        <member name="M:Tsavorite.core.IVariableLengthInput`2.GetRMWModifiedValueLength(`0@,`1@)">
            <summary>
            Length of resulting value object when performing RMW modification of value using given input
            </summary>
        </member>
        <member name="M:Tsavorite.core.IVariableLengthInput`2.GetRMWInitialValueLength(`1@)">
            <summary>
            Initial expected length of value object when populated by RMW using given input
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Tsavorite.core.IVariableLengthInput`2.GetUpsertValueLength(`0@,`1@)">
            <summary>
            Length of value object, when populated by Upsert using given value and input
            </summary>
            <param name="value"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Tsavorite.core.SpanByte">
            <summary>
            Represents a pinned variable length byte array that is viewable as a pinned Span&lt;byte&gt;
            Important: AOF header version needs to be updated if this struct's disk representation changes
            </summary>
            <remarks>
            Format: [4-byte (int) length of payload][[optional 8-byte metadata] payload bytes...]
            First 2 bits of length are used as a mask for properties, so max payload length is 1GB
            </remarks>
        </member>
        <member name="F:Tsavorite.core.SpanByte.length">
            <summary>
            Length of the payload
            </summary>
        </member>
        <member name="F:Tsavorite.core.SpanByte.payload">
            <summary>
            Start of payload
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToPointer">
            <summary>
            Pointer to the beginning of payload, not including metadata if any
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToPointerWithMetadata">
            <summary>
            Pointer to the beginning of payload, including metadata if any
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.Length">
            <summary>
            Length of payload, including metadata if any
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.LengthWithoutMetadata">
            <summary>
            Length of payload, not including metadata if any
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.Serialized">
            <summary>
            Format of structure
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.TotalSize">
            <summary>
            Total serialized size in bytes, including header and metadata if any
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.MetadataSize">
            <summary>
            Size of metadata header, if any (returns 0 or 8)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.#ctor(System.Int32,System.IntPtr)">
            <summary>
            Create a <see cref="T:Tsavorite.core.SpanByte"/> around a given <paramref name="payload"/> pointer and given <paramref name="length"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.ExtraMetadata">
            <summary>
            Extra metadata header
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.MarkExtraMetadata">
            <summary>
            Mark <see cref="T:Tsavorite.core.SpanByte"/> as having 8-byte metadata in header of payload
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.UnmarkExtraMetadata">
            <summary>
            Unmark <see cref="T:Tsavorite.core.SpanByte"/> as having 8-byte metadata in header of payload
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByte.Invalid">
            <summary>
            Check or set struct as invalid
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsSpan">
            <summary>
            Get Span&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (excluding metadata if any)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsSpan(System.Int32)">
            <summary>
            Get Span&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (excluding metadata if any)
            <paramref name="offset">
            Parameter to avoid having to call slice when wanting to interact directly with payload skipping ETag at the front of the payload
            </paramref>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsReadOnlySpan">
            <summary>
            Get ReadOnlySpan&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (excluding metadata if any)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsReadOnlySpan(System.Int32)">
            <summary>
            Get ReadOnlySpan&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (excluding metadata if any)
            <paramref name="offset">
            Parameter to avoid having to call slice when wanting to interact directly with payload skipping ETag at the front of the payload
            </paramref>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsSpanWithMetadata">
            <summary>
            Get Span&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (including metadata if any)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.AsReadOnlySpanWithMetadata">
            <summary>
            Get ReadOnlySpan&lt;byte&gt; for this <see cref="T:Tsavorite.core.SpanByte"/>'s payload (including metadata if any)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.Deserialize">
            <summary>
            If <see cref="T:Tsavorite.core.SpanByte"/> is in a serialized form, return a non-serialized <see cref="T:Tsavorite.core.SpanByte"/> wrapper that points to the same payload.
            </summary>
            <remarks>
            SAFETY: The resulting <see cref="T:Tsavorite.core.SpanByte"/> is safe to heap-copy, as long as the underlying payload remains pinned.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByte.Reinterpret(System.Span{System.Byte})">
            <summary>
            Reinterpret a fixed Span&lt;byte&gt; as a serialized <see cref="T:Tsavorite.core.SpanByte"/>. Automatically adds Span length to the first 4 bytes.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ReinterpretWithoutLength(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reinterpret a fixed ReadOnlySpan&lt;byte&gt; as a serialized <see cref="T:Tsavorite.core.SpanByte"/>, without adding length header
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.Reinterpret(System.Byte*)">
            <summary>
            Reinterpret a fixed pointer as a serialized <see cref="T:Tsavorite.core.SpanByte"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.Reinterpret``1(``0@)">
            <summary>
            Reinterpret a fixed ref as a serialized <see cref="T:Tsavorite.core.SpanByte"/> (user needs to write the payload length to the first 4 bytes)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.FromPinnedPointer(System.Byte*,System.Int32)">
            <summary>
            Create a SpanByte around a pinned memory <paramref name="pointer"/> of given <paramref name="length"/>.
            </summary>
            <remarks>
            SAFETY: The <paramref name="pointer"/> MUST point to pinned memory.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByte.FromPinnedStruct``1(``0*)">
            <summary>
            Create a SpanByte around a pinned unmanaged struct.
            </summary>
            <remarks>
            SAFETY: The provided unmanaged struct MUST be on the stack or point to pinned memory.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByte.FromPinnedSpan(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a <see cref="T:Tsavorite.core.SpanByte"/> from the given <paramref name="span"/>.
            </summary>
            <remarks>
            SAFETY: The <paramref name="span"/> MUST point to pinned memory.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByte.FromPinnedMemory(System.Memory{System.Byte})">
            <summary>
            Create SpanByte around a pinned <paramref name="memory"/>.
            </summary>
            <remarks>
            SAFETY: The <paramref name="memory"/> MUST be pinned.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToByteArray">
            <summary>
            Convert payload to new byte array
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToMemoryOwner(System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Convert payload to specified (disposable) memory owner
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToSpanByteAndMemory">
            <summary>
            Convert to <see cref="T:Tsavorite.core.SpanByteAndMemory"/> wrapper
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.TryCopyTo(Tsavorite.core.SpanByte@)">
            <summary>
            Try to copy to given pre-allocated <see cref="T:Tsavorite.core.SpanByte"/>, checking if space permits at destination <see cref="T:Tsavorite.core.SpanByte"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopyTo(Tsavorite.core.SpanByte@,System.Int64)">
            <summary>
            Blindly copy to given pre-allocated <see cref="T:Tsavorite.core.SpanByte"/>, assuming sufficient space.
            Does not change length of destination.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.TrySafeCopyTo(Tsavorite.core.SpanByte@,System.Int32,System.Int64)">
            <summary>
            Try to copy to given pre-allocated <see cref="T:Tsavorite.core.SpanByte"/>, checking if space permits at destination <see cref="T:Tsavorite.core.SpanByte"/>
            </summary>
            <param name="dst">The target of the copy</param>
            <param name="metadata">Optional metadata to add to the destination</param>
            <param name="fullDestSize">The size available at the destination (e.g. dst.TotalSize or the log-space Value allocation size)</param>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ShrinkSerializedLength(System.Int32)">
            <summary>
            Shrink the length header of the in-place allocated buffer on
            Tsavorite hybrid log, pointed to by the given <see cref="T:Tsavorite.core.SpanByte"/>.
            Zeroes out the extra space to retain log scan correctness.
            </summary>
            <param name="newLength">New length of payload (including metadata)</param>
        </member>
        <member name="M:Tsavorite.core.SpanByte.Clear(System.Byte*,System.Int32)">
            <summary>
            Utility to zero out an arbitrary span of bytes. 
            One use is to zero extra space after in-place update shrinks a value, to retain log scan correctness.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopyTo(Tsavorite.core.SpanByteAndMemory@,System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Copy to given <see cref="T:Tsavorite.core.SpanByteAndMemory"/> (only payload copied to actual span/memory)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopySliceTo(System.Int32,Tsavorite.core.SpanByteAndMemory@,System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Copy to given <see cref="T:Tsavorite.core.SpanByteAndMemory"/> (only payload copied to actual span/memory)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopyWithHeaderTo(Tsavorite.core.SpanByteAndMemory@,System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Copy to given <see cref="T:Tsavorite.core.SpanByteAndMemory"/> (header and payload copied to actual span/memory)
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopyTo(System.Span{System.Byte})">
            <summary>
            Copy serialized version to specified memory location
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.CopyTo(System.Byte*)">
            <summary>
            Copy serialized version to specified memory location
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.GetEtagInPayload">
            <summary>
            Gets an Etag from the payload of the SpanByte, caller should make sure the SpanByte has an Etag for the record by checking RecordInfo
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByte.SetEtagInPayload(System.Int64)">
            <summary>
            Gets an Etag from the payload of the SpanByte, caller should make sure the SpanByte has an Etag for the record by checking RecordInfo
            </summary>
            <param name="etag">The Etag value to set</param>
        </member>
        <member name="M:Tsavorite.core.SpanByte.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Tsavorite.core.SpanByteAndMemory">
            <summary>
            Output that encapsulates sync stack output (via <see cref="T:Tsavorite.core.SpanByte"/>) and async heap output (via IMemoryOwner)
            </summary>
        </member>
        <member name="F:Tsavorite.core.SpanByteAndMemory.SpanByte">
            <summary>
            Stack output as <see cref="T:Tsavorite.core.SpanByte"/>
            </summary>
        </member>
        <member name="F:Tsavorite.core.SpanByteAndMemory.Memory">
            <summary>
            Heap output as IMemoryOwner
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.#ctor(Tsavorite.core.SpanByte)">
            <summary>
            Constructor using given <paramref name="spanByte"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.#ctor(System.Void*,System.Int32)">
            <summary>
            Constructor using <see cref="T:Tsavorite.core.SpanByte"/> at given pinned <paramref name="pointer"/>, of given <paramref name="length"/>
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByteAndMemory.Length">
            <summary>
            Get length
            </summary>
        </member>
        <member name="P:Tsavorite.core.SpanByteAndMemory.IsSpanByte">
            <summary>
            Is it allocated as <see cref="T:Tsavorite.core.SpanByte"/> (on stack)?
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.#ctor(System.Buffers.IMemoryOwner{System.Byte})">
            <summary>
            Constructor using given IMemoryOwner
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.#ctor(System.Buffers.IMemoryOwner{System.Byte},System.Int32)">
            <summary>
            Constructor using given IMemoryOwner and length
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.AsReadOnlySpan">
            <summary>
            As a span of the contained data. Use this when you haven't tested <see cref="P:Tsavorite.core.SpanByteAndMemory.IsSpanByte"/>.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.AsMemoryReadOnlySpan">
            <summary>
            As a span of the contained data. Use this when you have already tested <see cref="P:Tsavorite.core.SpanByteAndMemory.IsSpanByte"/>.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.CopyFrom(System.ReadOnlySpan{System.Byte},System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Copy from the passed ReadOnlySpan{byte}. Use this when you have not tested <see cref="P:Tsavorite.core.SpanByteAndMemory.IsSpanByte"/>.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.FromPinnedSpan(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a <see cref="T:Tsavorite.core.SpanByteAndMemory"/> from pinned <paramref name="span"/>.
            </summary>
            <remarks>
            SAFETY: The <paramref name="span"/> MUST point to pinned memory.
            </remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByteAndMemory.ConvertToHeap">
            <summary>
            Convert to be used on heap (IMemoryOwner)
            </summary>
        </member>
        <member name="T:Tsavorite.core.SpanByteComparer">
            <summary>
            Equality comparer for <see cref="T:Tsavorite.core.SpanByte"/>
            </summary>
        </member>
        <member name="F:Tsavorite.core.SpanByteComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Tsavorite.core.SpanByteComparer.GetHashCode64(Tsavorite.core.SpanByte@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteComparer.StaticGetHashCode64(Tsavorite.core.SpanByte@)">
            <summary>
            Get 64-bit hash code
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteComparer.Equals(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteComparer.StaticEquals(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <summary>
            Equality comparison
            </summary>
        </member>
        <member name="T:Tsavorite.core.SpanByteFunctions`1">
            <summary>
            Callback functions for <see cref="T:Tsavorite.core.SpanByte"/> Key, Value, Input; <see cref="T:Tsavorite.core.SpanByteAndMemory"/> Output; and specified <typeparamref name="TContext"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`1.#ctor(System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="memoryPool"></param>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`1.SingleReader(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`1.ConcurrentReader(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`1.ConvertOutputToHeap(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="T:Tsavorite.core.SpanByteFunctions`3">
            <summary>
            Callback functions for <see cref="T:Tsavorite.core.SpanByte"/> key, value; specified <typeparamref name="TInput"/>, <typeparamref name="TOutput"/>, and <typeparamref name="TContext"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`3.SingleWriter(Tsavorite.core.SpanByte@,`0@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,`1@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`3.ConcurrentWriter(Tsavorite.core.SpanByte@,`0@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,`1@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`3.DoSafeCopy(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@,System.Int64)">
            <summary>
            Utility function for <see cref="T:Tsavorite.core.SpanByte"/> copying, Upsert version.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`3.DoSafeCopy(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <summary>
            Utility function for <see cref="T:Tsavorite.core.SpanByte"/> copying, RMW version.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`3.SingleDeleter(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
            <remarks>Avoids the "value = default" for added tombstone record, which do not have space for the payload</remarks>
        </member>
        <member name="T:Tsavorite.core.SpanByteFunctions`2">
            <summary>
            Callback functions for <see cref="T:Tsavorite.core.SpanByte"/> key, value, input; specified <typeparamref name="TOutput"/> and <typeparamref name="TContext"/>
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.InitialUpdater(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,`0@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.CopyUpdater(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,`0@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.InPlaceUpdater(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,`0@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.GetRMWModifiedValueLength(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <summary>
            Length of resulting object when doing RMW with given value and input. Here we set the length
            to the max of input and old value lengths. You can provide a custom implementation for other cases.
            </summary>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.GetRMWInitialValueLength(Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Tsavorite.core.SpanByteFunctions`2.GetUpsertValueLength(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <summary>
            Length of resulting object when doing Upsert with given value and input. Here we set the length to the
            length of the provided value, ignoring input. You can provide a custom implementation for other cases.
            </summary>
        </member>
        <member name="T:Tsavorite.core.SpanByteHeapContainer">
            <summary>
            Heap container for <see cref="T:Tsavorite.core.SpanByte"/> structs
            </summary>
        </member>
        <member name="T:Tsavorite.core.UnmanagedMemoryManager`1">
            <summary>
            A MemoryManager over a raw pointer
            </summary>
            <remarks>The pointer is assumed to be fully unmanaged, or externally pinned - no attempt will be made to pin this data</remarks>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.#ctor(`0*,System.Int32)">
            <summary>
            Create a new UnmanagedMemoryManager instance at the given pointer and size
            </summary>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.SetDestination(`0*,System.Int32)">
            <summary>
            Set destination for this object
            </summary>
            <param name="pointer"></param>
            <param name="length"></param>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.GetSpan">
            <summary>
            Obtains a span that represents the region
            </summary>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.Pin(System.Int32)">
            <summary>
            Provides access to a pointer that represents the data (note: no actual pin occurs)
            </summary>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.Unpin">
            <summary>
            Has no effect
            </summary>
        </member>
        <member name="M:Tsavorite.core.UnmanagedMemoryManager`1.Dispose(System.Boolean)">
            <summary>
            Releases all resources associated with this object
            </summary>
        </member>
    </members>
</doc>
