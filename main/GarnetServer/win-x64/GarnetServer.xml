<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GarnetServer</name>
    </assembly>
    <members>
        <member name="T:Garnet.DeleteIfMatchCustomCommand">
             <summary>
             Functions to implement custom command DELIFMATCH - del if value matches exactly (used for unlocking)
            
             Format: DELIFMATCH key value
            
             Description: Delete key only if the given value matches the
             existing value for that key. If it does not match (or there is no existing value),
             then do nothing.
             </summary>
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.Reader(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.NeedInitialUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.GetInitialLength(Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.InitialUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.InPlaceUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},System.Int32@,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.NeedCopyUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.GetLength(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.DeleteIfMatchCustomCommand.CopyUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.GetTwoKeysNoTxn">
            <summary>
            Functions to implement custom transaction GETTWOKEYSNOTXN - it will use the Finalize method of a stored procedure
            to read two keys in a non-transactional way. The transaction itself is empty.
            
            Format: GETTWOKEYSNOTXN 2 getkey1 getkey2
            
            Description: Read two keys without any transactional guarantee, return the values as an array of bulk strings
            </summary>
        </member>
        <member name="M:Garnet.GetTwoKeysNoTxn.Prepare``1(``0,Garnet.server.CustomProcedureInput@)">
            <summary>
            No transactional phase, skip Prepare
            </summary>
        </member>
        <member name="M:Garnet.GetTwoKeysNoTxn.Main``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Main will not be called because Prepare returns false
            </summary>
        </member>
        <member name="M:Garnet.GetTwoKeysNoTxn.Finalize``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings
            </summary>
        </member>
        <member name="T:Garnet.MGetIfPM">
            <summary>
            Functions to implement custom transaction MGETIFPM - get multiple keys whose values match with the given prefix
            
            Format: MGETIFPM prefix key1 key2 ...
            Output: array of matching key-value pairs
            
            Description: Perform a non-transactional multi-get with value condition (prefix match) for the given set of keys
            </summary>
        </member>
        <member name="M:Garnet.MGetIfPM.Prepare``1(``0,Garnet.server.CustomProcedureInput@)">
            <summary>
            No transactional phase, skip Prepare
            </summary>
        </member>
        <member name="M:Garnet.MGetIfPM.Main``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Main will not be called because Prepare returns false
            </summary>
        </member>
        <member name="M:Garnet.MGetIfPM.Finalize``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Perform the MGETIFPM operation
            </summary>
        </member>
        <member name="T:Garnet.MSetPxTxn">
            <summary>
            Functions to implement custom transaction MSETPX - set multiple keys with given expiration in milliseconds
            
            Format: MSETPX 60000 key1 value1 key2 value2 ...
            
            Description: Perform a non-transactional multi-set with expiry for the given set of key-value pairs
            </summary>
        </member>
        <member name="M:Garnet.MSetPxTxn.Prepare``1(``0,Garnet.server.CustomProcedureInput@)">
            <summary>
            No transactional phase, skip Prepare
            </summary>
        </member>
        <member name="M:Garnet.MSetPxTxn.Main``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Main will not be called because Prepare returns false
            </summary>
        </member>
        <member name="M:Garnet.MSetPxTxn.Finalize``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Perform the MSETPX operation
            </summary>
        </member>
        <member name="M:Garnet.MyDict.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <summary>
            Returns the items from this object using a cursor to indicate the start of the scan,
            a pattern to filter out the items to return, and a count to indicate the number of items to return.
            </summary>
            <param name="start"></param>
            <param name="items"></param>
            <param name="cursor"></param>
            <param name="count"></param>
            <param name="pattern"></param>
            <param name="patternLength"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.ReadWriteTxn">
            <summary>
            Functions to implement custom tranasction READWRITE - read one key, write to two keys
            
            Format: READWRITE 3 readkey writekey1 writekey2
            
            Description: Update key to given value only if the given prefix matches the 
            existing value's prefix. If it does not match (or there is no existing value), 
            then do nothing.
            </summary>
        </member>
        <member name="T:Garnet.SampleDeleteTxn">
            <summary>
            Sample stored procedure that deletes different keys in the main and object stores
            </summary>
        </member>
        <member name="T:Garnet.SampleUpdateTxn">
            <summary>
            Sample stored procedure that updates different keys in the main and object stores
            </summary>
        </member>
        <member name="T:Garnet.SetIfPMCustomCommand">
             <summary>
             Functions to implement custom command SETIFPM - set if prefix match
            
             Format: SETIFPM key value prefix
            
             Description: Update key to given value only if the given prefix matches the
             existing value's prefix. If it does not match (or there is no existing value),
             then do nothing.
             </summary>
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.Reader(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.NeedInitialUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.GetInitialLength(Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.InitialUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.InPlaceUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},System.Int32@,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.NeedCopyUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.GetLength(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetIfPMCustomCommand.CopyUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.SetWPIFPGTCustomCommand">
             <summary>
             Functions to implement custom command SETPIFPGT - set with prefix, if existing prefix greater than specified (8 byte) long
            
             Format: SETWPIFPGT key value 8-byte-prefix
            
             Description: Update key to given "prefix + value" only if the given prefix (interpreted as 8 byte long) is greater than the
             existing value's 8-byte prefix, or there is no existing value. Otherwise, do nothing.
             </summary>
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.GetInitialLength(Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.GetLength(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.NeedInitialUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.NeedCopyUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.InitialUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.InPlaceUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},System.Int32@,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.CopyUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.SetWPIFPGTCustomCommand.Reader(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.Program">
            <summary>
            Garnet server entry point
            </summary>
        </member>
        <member name="M:Garnet.Program.RegisterExtensions(Garnet.GarnetServer)">
            <summary>
            Register new commands with the server. You can access these commands from clients using
            commands such as db.Execute in StackExchange.Redis. Example:
              db.Execute("SETIFPM", key, value, prefix);
            </summary>
        </member>
    </members>
</doc>
