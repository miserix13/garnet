<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Garnet.server</name>
    </assembly>
    <members>
        <member name="T:Garnet.server.ACL.AccessControlList">
            <summary>
            Models the high-level Access Control List (ACL) that defines access and command limitations for Garnet users.
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.AccessControlList.DefaultUserName">
            <summary>
            Username to use for the default user
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.AccessControlList._userHandles">
            <summary>
            Dictionary containing all <see cref="T:Garnet.server.ACL.UserHandle"/>s defined in the ACL.
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.AccessControlList._defaultUserHandle">
            <summary>
            The <see cref="T:Garnet.server.ACL.UserHandle"/> for the currently configured default user (for fast default lookups).
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.#ctor(System.String,System.String)">
            <summary>
            Creates a new Access Control List from an optional ACL configuration file
            and sets the default user's password, if not provided by the configuration.
            </summary>
            <param name="defaultPassword">The password for the default user (if not provided by configuration file).</param>
            <param name="aclConfigurationFile">ACL configuration file.</param>
            <exception cref="T:Garnet.server.ACL.ACLException">Thrown if configuration file cannot be parsed.</exception>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.GetUserHandle(System.String)">
            <summary>
            Returns the <see cref="T:Garnet.server.ACL.UserHandle"/> with the given name.
            </summary>
            <param name="username">Username of the user to retrieve.</param>
            <returns>Matching user object, or null if no user with the given name was found.</returns>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.GetDefaultUserHandle">
            <summary>
            Returns the currently configured default <see cref="T:Garnet.server.ACL.UserHandle"/>.
            </summary>
            <returns>The default user of this access control list.</returns>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.AddUserHandle(Garnet.server.ACL.UserHandle)">
            <summary>
            Adds the given <see cref="T:Garnet.server.ACL.UserHandle"/> to the ACL.
            </summary>
            <param name="userHandle">User to add to the list.</param>
            <exception cref="T:Garnet.server.ACL.ACLUserAlreadyExistsException">Thrown if a user with the given username already exists.</exception>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.DeleteUserHandle(System.String)">
            <summary>
            Deletes the <see cref="T:Garnet.server.ACL.UserHandle"/> associated with the given username.
            </summary>
            <param name="username">Username of the user to delete.</param>
            <returns>true if successful, false if no matching user was found.</returns>
            <exception cref="T:Garnet.server.ACL.ACLException">Thrown if the given user exists but cannot be deleted.</exception>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.ClearUsers">
            <summary>
            Remove all <see cref="T:Garnet.server.ACL.UserHandle"/>s from the list.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.GetUserHandles">
            <summary>
            Return a list of all usernames and user objects.
            </summary>
            <returns>Dictionary of username/user pairs.</returns>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.CreateDefaultUserHandle(System.String)">
            <summary>
            Creates the default user, if it does not exist yet.
            </summary>
            <param name="defaultPassword">Password to use if new user is created.</param>
            <returns>The newly created or already existing default user.</returns>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.Load(System.String,System.String)">
            <summary>
            Loads the given ACL configuration file and replaces all currently defined rules in this ACL.
            If the given ACL file contains errors, the old rules remain unmodified.
            </summary>
            <param name="defaultPassword">The password for the default user (if not defined in ACL configuration file)</param>
            <param name="aclConfigurationFile">ACL configuration file.</param>
            <exception cref="T:Garnet.server.ACL.ACLException">Thrown if configuration file cannot be parsed.</exception>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.Save(System.String)">
            <summary>
            Save current
            </summary>
            <param name="aclConfigurationFile"></param>
        </member>
        <member name="M:Garnet.server.ACL.AccessControlList.Import(System.IO.StreamReader,System.String)">
            <summary>
            Imports Access Control List rules from the given reader.
            </summary>
            <param name="input">Input text reader to a list of ACL user definition rules.</param>
            <param name="configurationFile">Configuration file identifier for clean debug messages.</param>
            <exception cref="T:Garnet.server.ACL.ACLParsingException">Thrown if ACL rules cannot be parsed.</exception>
        </member>
        <member name="T:Garnet.server.ACL.ACLException">
            <summary>
            ACL exception base
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLParsingException">
            <summary>
            Exception when parsing ACL rules
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.ACLParsingException.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new ACL Parsing Exception
            </summary>
            <param name="message">A message describing the exception that occurred.</param>
            <param name="filename">The name of the file in which the error occurred.</param>
            <param name="line">The line within the file on which the error occurred.</param>
        </member>
        <member name="F:Garnet.server.ACL.ACLParsingException.Filename">
            <summary>
            The name of the file in which the error occurred.
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.ACLParsingException.Line">
            <summary>
            The line in the input file, in which the error occurred.
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLPasswordException">
            <summary>
            Exception when interacting with ACL passwords
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLUnknownOperationException">
            <summary>
            Exception indicating an undefined ACL operation
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLCategoryDoesNotExistException">
            <summary>
            Exception indicating the given category does not exist
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLUserDoesNotExistException">
            <summary>
            Exception indicating the given user does not exist
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.ACLUserAlreadyExistsException">
            <summary>
            Exception indicating a user with the given name already exists
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.AclCommandDoesNotExistException">
            <summary>
            Exception indicating a given command does not exist.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.ACLParser.ParseACLRule(System.String,Garnet.server.ACL.AccessControlList)">
            <summary>
            Parses a single-line ACL rule and returns a new user according to that rule.
            
            ACL rules follow a subset of the Redis ACL rule syntax, with each rule
            being formatted as follows:
            
                ACL_RULE := user &lt;username> (&lt;ACL_OPERATION>)+
                ACL_OPERATION := on | off | +@&lt;category> | -@&lt;category>
            
            To manage user account:
                on/off: enable/disable the user account
            
            To configure user passwords:
                &gt;&lt;password>: Add the password to the list of valid passwords for the user
                &lt;&lt;password>: Remove the password from the list of valid password for the user
                #&lt;hash>: Add the password hash to the list of valid passwords for the user
                !&lt;hash>: Remove the password hash from the list of valid passwords for the user
                nopass: Specify this user can login without a password.
                resetpass: Reset all passwords defined for the user so far and disable passwordless login.
            </summary>
            <param name="input">A single line Redis-style ACL rule.</param>
            <param name="acl">An optional access control list to modify.</param>
            <returns>A user object representing the modified user.</returns>
            <exception cref="T:Garnet.server.ACL.ACLParsingException">Thrown if the ACL rule cannot be parsed.</exception>
            <exception cref="T:Garnet.server.ACL.ACLCategoryDoesNotExistException">Thrown if the ACL command category used by the operation does not exist.</exception>
            <exception cref="T:Garnet.server.ACL.ACLUnknownOperationException">Thrown if the given operation does not exist.</exception>
        </member>
        <member name="M:Garnet.server.ACL.ACLParser.ApplyACLOpToUser(Garnet.server.ACL.User@,System.String)">
            <summary>
            Parses the given ACL operation string and applies it to the given user.
            </summary>
            <param name="user">User to apply the operation to.</param>
            <param name="op">ACL operation as string.</param>
            <exception cref="T:Garnet.server.ACL.ACLCategoryDoesNotExistException">Thrown if the ACL command category used by the operation does not exist.</exception>
            <exception cref="T:Garnet.server.ACL.ACLUnknownOperationException">Thrown if the given operation does not exist.</exception>
        </member>
        <member name="M:Garnet.server.ACL.ACLParser.GetACLCategoryByName(System.String)">
            <summary>
            Lookup the <see cref="T:Garnet.server.RespAclCategories"/> by equivalent string.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.ACLParser.GetNameByACLCategory(Garnet.server.RespAclCategories)">
            <summary>
            Lookup the string equivalent to <paramref name="category"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.ACLParser.ListCategories">
            <summary>
            Returns a collection of all valid category names.
            </summary>
            <returns>Collection of valid category names.</returns>
        </member>
        <member name="T:Garnet.server.ACL.ACLPassword">
            <summary>
            Represents an individual ACL Password stored as a cryptographic (SHA-265) hash
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.ACLPassword.PasswordHash">
            <summary>
            The hash associated with this ACL password
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.#ctor(System.Byte[])">
            <summary>
            Private constructor to initialize a new ACL Password with the given hash
            </summary>
            <param name="passwordHash">Password hash as byte array.</param>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.ACLPasswordFromString(System.String)">
            <summary>
            Initializes a new ACLPassword from the given cleartext string.
            </summary>
            <param name="password">Cleartext password used to initialize the password hash.</param>
            <returns>ACLPassword object for the given cleartext password.</returns>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.ACLPasswordFromHash(System.String)">
            <summary>
            Initializes a new ACLPassword from the given string representation of a password hash.
            </summary>
            <param name="hashString">A hex-string containing a valid SHA-265 password hash.</param>
            <returns>ACLPassword object with the given hash.</returns>
            <exception cref="T:Garnet.server.ACL.ACLPasswordException">Thrown when the given input string cannot be parsed.</exception>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.ToString">
            <summary>
            Outputs the hexadecimal representation of the password hash.
            </summary>
            <returns>Password hash as hex-string.</returns>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.Equals(Garnet.server.ACL.ACLPassword)">
            <summary>
            Compares the password hash with the given password hash.
            </summary>
            <param name="password">Password hash to compare to.</param>
            <returns>True if equal, otherwise false.</returns>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.GetHashCode">
            <summary>
            Return a short non-cryptographic hash to speedup indexing.
            </summary>
            <returns>The hash value generated for this ACLPassword.</returns>
        </member>
        <member name="M:Garnet.server.ACL.ACLPassword.Equals(System.Object)">
            <summary>
            Checks if the current ACLPassword is equal to the given object.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns>true if the current ACLPassword is equal to the other object; otherwise, false.</returns>
        </member>
        <member name="F:Garnet.server.ACL.ACLPassword.NumHashBytes">
            <summary>
            The number of bytes per hash
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.CommandPermissionSet">
            <summary>
            Wraps up command permissions behind a reference so it can be atomically swapped.
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.CommandPermissionSet.Description">
            <summary>
            String which, when parsed by <see cref="T:Garnet.server.ACL.ACLParser"/>, will produce an equivalent <see cref="T:Garnet.server.ACL.CommandPermissionSet"/> to this one.
            
            This is not updated automatically, and should be rationalized once modification via <see cref="M:Garnet.server.ACL.CommandPermissionSet.RemoveCommand(Garnet.server.RespCommand)"/> or <see cref="M:Garnet.server.ACL.CommandPermissionSet.AddCommand(Garnet.server.RespCommand)"/>
            is complete.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.CanRunCommand(Garnet.server.RespCommand)">
            <summary>
            Returns true if the given command + subCommand pair can be run.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.Copy">
            <summary>
            Copy this permission set.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.AddCommand(Garnet.server.RespCommand)">
            <summary>
            Enable this command / sub-command pair.
            
            subCommand == 0 is the root command.
            
            This is not thread safe.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.RemoveCommand(Garnet.server.RespCommand)">
            <summary>
            Remove this command / sub-command pair.
            
            subCommand == 0 is the root command.
            
            This is not thread safe.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.IsEquivalentTo(Garnet.server.ACL.CommandPermissionSet)">
            <summary>
            Check if this and another <see cref="T:Garnet.server.ACL.CommandPermissionSet"/> are equivalent.
            
            They may be built using different commands, but if they cover the same set of runnable commands they are equivalent.
            
            Note that All and None are only equivalent to themselves, as they are special cases that permit or forbid commands
            going forward.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.CommandPermissionSet.GetCommandListLength">
            <summary>
            Determines the size of the <see cref="F:Garnet.server.ACL.CommandPermissionSet._commandList"/> in each permission set.
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.SecretsUtility">
            <summary>
            A collection of shared utility methods to operate against secret key material.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.SecretsUtility.ConstantEquals(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Compare two spans of bytes and evaluate if they are equal in constant O(n) time.
            This is intended to reduce the likelihood of leaking the contents of the spans through side-channel timing attacks.
            
            Note: This function is explicitly not optimized for performance and must remain O(n) where a.Length == b.Length.
            </summary>
            <param name="a">The first span of data to compare</param>
            <param name="b">The second span of data to compare against</param>
            <returns>Returns true if both spans are of equal length and each sequential value matches</returns>
        </member>
        <member name="T:Garnet.server.ACL.User">
            <summary>
            Represents a Garnet user and associated access rights.
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.User.Name">
            <summary>
            The associated username
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.User.IsEnabled">
            <summary>
            Tracks whether the user account is currently active or disabled
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.User.IsPasswordless">
            <summary>
            Indicates that no password matching will be done, regardless of the passed in password.
            Note that passwordless mode needs to be enabled to successfully authenticate when no password hashes are set.
            </summary>
        </member>
        <member name="P:Garnet.server.ACL.User.Passwords">
            <summary>
            Returns a copy of the <see cref="T:Garnet.server.ACL.User"/>s passwords.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.#ctor(System.String)">
            <summary>
            Creates a new user with the given name
            </summary>
            <param name="name">Name of the new user</param>
        </member>
        <member name="M:Garnet.server.ACL.User.#ctor(Garnet.server.ACL.User)">
            <summary>
            Copy constructor for a <see cref="T:Garnet.server.ACL.User"/>.
            </summary>
            <param name="user">The <see cref="T:Garnet.server.ACL.User"/> the new <see cref="T:Garnet.server.ACL.User"/> is constructed from.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.CanAccessCommand(Garnet.server.RespCommand)">
            <summary>
            Checks whether the user can access the given command.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.AddCategory(Garnet.server.RespAclCategories)">
            <summary>
            Adds the given category to the user.
            </summary>
            <param name="category">Bit flag of the category to add.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.AddCommand(Garnet.server.RespCommand)">
            <summary>
            Adds the given command to the user.
            
            If the command has subcommands, and no specific subcommand is indicated, adds all subcommands too.
            </summary>
            <param name="command">Command to add.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.RemoveCategory(Garnet.server.RespAclCategories)">
            <summary>
            Removes the given category from the user.
            </summary>
            <param name="category">Bit flag of the category to remove.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.RemoveCommand(Garnet.server.RespCommand)">
            <summary>
            Removes the given command from the user.
            
            If the command has subcommands, and no specific subcommand is indicated, removes all subcommands too.
            </summary>
            <param name="command">Command to remove.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.AddPasswordHash(Garnet.server.ACL.ACLPassword)">
            <summary>
            Adds a new password for the user.
            </summary>
            <param name="password">ACLPassword to add to the allowed passwords for the user.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.RemovePasswordHash(Garnet.server.ACL.ACLPassword)">
            <summary>
            Removes the password from the list of allowed passwords for the user.
            </summary>
            <param name="password">ACLPassword to remove from the allowed passwords for the user.</param>
        </member>
        <member name="M:Garnet.server.ACL.User.ClearPasswords">
            <summary>
            Removes all passwords currently registered for the user.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.Reset">
            <summary>
            Removes all currently configured capabilities from the user and disables the user
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.ValidatePassword(Garnet.server.ACL.ACLPassword)">
            <summary>
            Returns true if the given password hash is valid for this user.
            </summary>
            <param name="password">An ACL password hash to check against this user.</param>
            <returns>true if the given password hash is valid for this user, otherwise false.</returns>
        </member>
        <member name="M:Garnet.server.ACL.User.DescribeUser">
            <summary>
            Exports an easily readable textual representation of the user settings in ACL rule format.
            </summary>
            <returns>String representation of the user.</returns>
        </member>
        <member name="M:Garnet.server.ACL.User.GetEnabledCommandsDescription">
            <summary>
            Returns a <see cref="T:System.String"/> containing the enabled commands.
            </summary>
            <returns>A <see cref="T:System.String"/> containing the enabled commands.</returns>
        </member>
        <member name="M:Garnet.server.ACL.User.DetermineCommandDetails(System.Collections.Generic.IReadOnlyList{Garnet.server.RespCommandsInfo})">
            <summary>
            Determine the command / sub command pairs that are associated with this command information entries
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.RationalizeACLDescription(Garnet.server.ACL.CommandPermissionSet,System.String,System.Boolean)">
            <summary>
            Check to see if any tokens from a description can be removed without modifying the effective permissions.
            
            This is an expensive method, but ACL modifications are rare enough it's hopefully not a problem. In situations
            where it is known ahead of time that the CommandPermissionSet does not require reductions, set useDeepRationalization
            to true to optimize the method execution by avoiding a deeper recursive analysis.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.CopyCommandPermissionSet">
            <summary>
            Returns a copy of the users current <see cref="T:Garnet.server.ACL.CommandPermissionSet"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.User.CopyPasswordHashes">
            <summary>
            Returns a copy of the password hashes for the <see cref="T:Garnet.server.ACL.User"/>.
            </summary>
            <returns>A <see cref="T:System.Collections.Generic.HashSet`1"/> of <see cref="T:Garnet.server.ACL.ACLPassword"/> representing password hashes for the user.</returns>
        </member>
        <member name="F:Garnet.server.ACL.User._enabledCommands">
            <summary>
            Commands enabled for the user
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.User._passwordHashes">
            <summary>
            A set of all allowed _passwordHashes for the user.
            
            NOTE: HashSet is not thread-safe, so accesses need to be synchronized
            </summary>
        </member>
        <member name="T:Garnet.server.ACL.UserHandle">
            <summary>
            A reference used to access a <see cref="P:Garnet.server.ACL.UserHandle.User"/>.
            </summary>
        </member>
        <member name="F:Garnet.server.ACL.UserHandle.user">
            <summary>
            The <see cref="P:Garnet.server.ACL.UserHandle.User"/> referred to by the <see cref="T:Garnet.server.ACL.UserHandle"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ACL.UserHandle.#ctor(Garnet.server.ACL.User)">
            <summary>
            Constructor for a <see cref="T:Garnet.server.ACL.UserHandle"/>.
            </summary>
            <param name="user">The <see cref="P:Garnet.server.ACL.UserHandle.User"/> the handle will reference.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="user"/> is <c>null</c>.</exception>
        </member>
        <member name="P:Garnet.server.ACL.UserHandle.User">
            <summary>
            Returns the current version of the <see cref="P:Garnet.server.ACL.UserHandle.User"/> with the latest modifications.
            </summary>
            <returns>Returns the current version of the <see cref="P:Garnet.server.ACL.UserHandle.User"/> with the latest modifications.</returns>
        </member>
        <member name="M:Garnet.server.ACL.UserHandle.TrySetUser(Garnet.server.ACL.User,Garnet.server.ACL.User)">
            <summary>
            Attempts to set the <see cref="P:Garnet.server.ACL.UserHandle.User"/> for a handle.
            </summary>
            <param name="newUser">A <see cref="P:Garnet.server.ACL.UserHandle.User"/> that should secede the existing <see cref="P:Garnet.server.ACL.UserHandle.User"/> referred to by the handle.</param>
            <param name="replacedUser">The <see cref="P:Garnet.server.ACL.UserHandle.User"/> expected to be replaced.</param>
            <returns>True if the assignment was performed; otherwise false.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="newUser"/> is <c>null</c>.</exception>
        </member>
        <member name="F:Garnet.server.AofEntryType.StoreUpsert">
            <summary>
            Store upsert
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.StoreRMW">
            <summary>
            Store RMW
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.StoreDelete">
            <summary>
            Store delete
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.ObjectStoreUpsert">
            <summary>
            Object store upsert
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.ObjectStoreRMW">
            <summary>
            Object store RMW
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.ObjectStoreDelete">
            <summary>
            Object store delete
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.TxnStart">
            <summary>
            Transaction start
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.TxnCommit">
            <summary>
            Transaction commit
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.TxnAbort">
            <summary>
            Transaction abort
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.CheckpointStartCommit">
            <summary>
            Checkpoint start marker for unified checkpoint
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.CheckpointEndCommit">
            <summary>
            Checkpoint end marker for unified checkpoint
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.MainStoreStreamingCheckpointStartCommit">
            <summary>
            Streaming checkpoint start marker for main store
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.ObjectStoreStreamingCheckpointStartCommit">
            <summary>
            Streaming checkpoint start marker for object store
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.MainStoreStreamingCheckpointEndCommit">
            <summary>
            Streaming checkpoint end marker for main store
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.ObjectStoreStreamingCheckpointEndCommit">
            <summary>
            Streaming checkpoint end marker for object store
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.StoredProcedure">
            <summary>
            StoredProcedure
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.FlushAll">
            <summary>
            Flush all
            </summary>
        </member>
        <member name="F:Garnet.server.AofEntryType.FlushDb">
            <summary>
            Flush db
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.aofHeaderVersion">
            <summary>
            Version of AOF
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.padding">
            <summary>
            Padding, for alignment and future use
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.opType">
            <summary>
            Type of operation
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.procedureId">
            <summary>
            Procedure ID
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.storeVersion">
            <summary>
            Store version
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.sessionID">
            <summary>
            Session ID
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.unsafeTruncateLog">
            <summary>
            Unsafe truncate log (used with FLUSH command)
            </summary>
        </member>
        <member name="F:Garnet.server.AofHeader.databaseId">
            <summary>
            Database ID (used with FLUSH command)
            </summary>
        </member>
        <member name="T:Garnet.server.AofProcessor">
            <summary>
            Wrapper for store and store-specific information
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.SetReadWriteSession">
            <summary>
            Set ReadWriteSession on the cluster session (NOTE: used for replaying stored procedures only)
            </summary>
        </member>
        <member name="F:Garnet.server.AofProcessor.basicContext">
            <summary>
            Session for main store
            </summary>
        </member>
        <member name="F:Garnet.server.AofProcessor.objectStoreBasicContext">
            <summary>
            Session for object store
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.#ctor(Garnet.server.StoreWrapper,Garnet.server.IClusterProvider,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new AOF processor
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.Recover(Garnet.server.GarnetDatabase,System.Int64)">
            <summary>
            Recover store using AOF
            </summary>
            <param name="db">Database to recover</param>
            <param name="untilAddress">Tail address for recovery</param>
            <returns>Tail address</returns>
        </member>
        <member name="M:Garnet.server.AofProcessor.ProcessAofRecordInternal(System.Byte*,System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            Process AOF record internal
            </summary>
            <param name="ptr"></param>
            <param name="length"></param>
            <param name="asReplica"></param>
            <param name="isCheckpointStart"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.SkipRecord(System.Boolean,System.Byte*,System.Int32,System.Boolean)">
            <summary>
            On recovery apply records with header.version greater than CurrentVersion.
            </summary>
            <param name="inFuzzyRegion"></param>
            <param name="entryPtr"></param>
            <param name="length"></param>
            <param name="asReplica"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="T:Garnet.server.AofProcessor.AofReplayCoordinator">
            <summary>
            Coordinates the replay of Append-Only File (AOF) operations, including transaction processing, fuzzy region
            handling, and stored procedure execution.
            </summary>
            <remarks>This class is responsible for managing the replay context, processing transaction
            groups, and handling operations within fuzzy regions. It provides methods to add, replay, and process
            transactions and operations, ensuring consistency and correctness during AOF replay.  The <see
            cref="T:Garnet.server.AofProcessor.AofReplayCoordinator"/> is designed to work with an <see cref="T:Garnet.server.AofProcessor"/> to facilitate the
            replay of operations.</remarks>
            <param name="aofProcessor"></param>
            <param name="logger"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.#ctor(Garnet.server.AofProcessor,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Coordinates the replay of Append-Only File (AOF) operations, including transaction processing, fuzzy region
            handling, and stored procedure execution.
            </summary>
            <remarks>This class is responsible for managing the replay context, processing transaction
            groups, and handling operations within fuzzy regions. It provides methods to add, replay, and process
            transactions and operations, ensuring consistency and correctness during AOF replay.  The <see
            cref="T:Garnet.server.AofProcessor.AofReplayCoordinator"/> is designed to work with an <see cref="T:Garnet.server.AofProcessor"/> to facilitate the
            replay of operations.</remarks>
            <param name="aofProcessor"></param>
            <param name="logger"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.FuzzyRegionBufferCount">
            <summary>
            Get fuzzy region buffer count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.ClearFuzzyRegionBuffer">
            <summary>
            Clear fuzzy region buffer
            </summary>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.AddFuzzyRegionOperation(System.ReadOnlySpan{System.Byte})">
            <summary>
            Add single operation to fuzzy region buffer
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.AddOrReplayTransactionOperation(System.Byte*,System.Int32,System.Boolean)">
            <summary>
            This method will perform one of the following
                1. TxnStart: Create a new transaction group
                2. TxnCommit: Replay or buffer transaction group depending if we are in fuzzyRegion. 
                3. TxnAbort: Clear corresponding sublog replay buffer.
                4. Default: Add an operation to an existing transaction group
            </summary>
            <param name="ptr"></param>
            <param name="length"></param>
            <param name="asReplica"></param>
            <returns>Returns true if a txn operation was processed and added otherwise false</returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.ProcessFuzzyRegionOperations(System.Int64,System.Boolean)">
            <summary>
            Process fuzzy region operations if any
            </summary>
            <param name="storeVersion"></param>
            <param name="asReplica"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.ProcessFuzzyRegionTransactionGroup(System.Byte*,System.Boolean)">
            <summary>
            Process fuzzy region transaction groups
            </summary>
            <param name="ptr"></param>
            <param name="asReplica"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.ProcessTransactionGroup(System.Byte*,System.Boolean,Garnet.server.TransactionGroup)">
            <summary>
            Process provided transaction group
            </summary>
            <param name="asReplica"></param>
            <param name="txnGroup"></param>
        </member>
        <member name="M:Garnet.server.AofProcessor.AofReplayCoordinator.ReplayStoredProc(System.Byte,System.Byte*)">
            <summary>
            Replay StoredProc wrapper for single and sharded logs
            </summary>
            <param name="id"></param>
            <param name="ptr"></param>
        </member>
        <member name="T:Garnet.server.AofReplayContext">
            <summary>
            AofReplayContext
            </summary>
        </member>
        <member name="F:Garnet.server.AofReplayContext.inFuzzyRegion">
            <summary>
            Fuzzy region of AOF is the region between the checkpoint start and end commit markers.
            This regions can contain entries in both (v) and (v+1) versions. The processing logic is:
            1) Process (v) entries as is.
            2) Store the (v+1) entries in a buffer.
            3) At the end of the fuzzy region, take a checkpoint
            4) Finally, replay the buffered (v+1) entries.
            </summary>
        </member>
        <member name="M:Garnet.server.AofReplayContext.#ctor">
            <summary>
            AofReplayContext constructor
            </summary>
        </member>
        <member name="M:Garnet.server.AofReplayContext.AddTransactionGroup(System.Int32)">
            <summary>
            Add transaction group to this replay buffer
            </summary>
            <param name="sessionID"></param>
        </member>
        <member name="M:Garnet.server.AofReplayContext.AddToFuzzyRegionBuffer(Garnet.server.TransactionGroup,System.ReadOnlySpan{System.Byte})">
            <summary>
            Add transaction group to fuzzy region buffer
            </summary>
            <param name="group"></param>
            <param name="commitMarker"></param>
        </member>
        <member name="T:Garnet.server.TransactionGroup">
            <summary>
            Transaction group contains list of operations associated with a given transaction
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionGroup.operations">
            <summary>
            Transaction operation buffer
            </summary>
        </member>
        <member name="M:Garnet.server.TransactionGroup.Clear">
            <summary>
            Clear the underlying buffer that holds the individual transaction operations
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetApi`2">
            <summary>
            Garnet API implementation
            </summary>
            <summary>
            Garnet API implementation
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetApi`2.WATCH(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.WATCH(System.Byte[],Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GET(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GET_WithPending(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,System.Int64,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GET_CompletePending(System.ValueTuple{Garnet.server.GarnetStatus,Tsavorite.core.SpanByteAndMemory}[],System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GETForMemoryResult(Garnet.server.ArgSlice,Garnet.common.MemoryResult{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GET(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GET(System.Byte[],Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.LCS(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GETEX(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GETRANGE(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.TTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.PTTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.PEXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.DEL_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET(Garnet.server.ArgSlice,System.Memory{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SET(System.Byte[],Garnet.server.IGarnetObject)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SETEX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SETEX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SETRANGE(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.MSET_Conditional(Garnet.server.RawStringInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.APPEND(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.APPEND(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />    
        </member>
        <member name="M:Garnet.server.GarnetApi`2.RENAME(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.RENAMENX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXISTS(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXPIRE(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,System.Boolean@,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXPIRE(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXPIRE(Garnet.server.ArgSlice,System.TimeSpan,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.EXPIREAT(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.PEXPIREAT(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.PERSIST(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.Increment(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.Increment(Garnet.server.ArgSlice,System.Int64@,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.Decrement(Garnet.server.ArgSlice,System.Int64@,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IncrementByFloat(Garnet.server.ArgSlice,Garnet.server.ArgSlice@,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IncrementByFloat(Garnet.server.ArgSlice,System.Double@,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.DELETE(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.DELETE(Tsavorite.core.SpanByte@,Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.DELETE(System.Byte[],Garnet.server.StoreType)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GETDEL(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GETDEL(Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GetKeyType(Garnet.server.ArgSlice,System.String@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.MemoryUsageForKey(Garnet.server.ArgSlice,System.Int64@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.RMW_MainStore(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.Read_MainStore(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.RMW_ObjectStore(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.Read_ObjectStore(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringSetBit(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringSetBit(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringGetBit(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringGetBit(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitCount(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitCount(Garnet.server.ArgSlice,System.Int64,System.Int64,System.Int64@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitOperation(Garnet.server.RawStringInput@,Garnet.server.BitmapOperation,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitOperation(Garnet.server.BitmapOperation,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitPosition(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitField(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Garnet.server.RespCommand,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitFieldReadOnly(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Garnet.server.RespCommand,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.StringBitField(Garnet.server.ArgSlice,System.Collections.Generic.List{Garnet.server.BitFieldCmdArgs},System.Collections.Generic.List{System.Nullable{System.Int64}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HyperLogLogAdd(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HyperLogLogAdd(Garnet.server.ArgSlice,System.String[],System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HyperLogLogLength(Garnet.server.RawStringInput@,System.Int64@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HyperLogLogLength(System.Span{Garnet.server.ArgSlice},System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HyperLogLogMerge(Garnet.server.RawStringInput@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GetDbKeys(Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GetDbSize">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.DbScan(Garnet.server.ArgSlice,System.Boolean,System.Int64,System.Int64@,System.Collections.Generic.List{System.Byte[]}@,System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IterateMainStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IterateMainStore">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IterateObjectStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.IterateObjectStore">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ObjectScan(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GetScratchBufferOffset">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ResetScratchBuffer(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetAdd(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRangeStore(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ObjectInput@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetScore(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetScores(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetMPop(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32,System.Boolean,Garnet.server.ArgSlice@,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetPop(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetCount(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetCount(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetLengthByValue(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemoveRangeByLex(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemoveRangeByLex(Garnet.server.ArgSlice,System.String,System.String,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemoveRangeByScore(Garnet.server.ArgSlice,System.String,System.String,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemoveRangeByRank(Garnet.server.ArgSlice,System.Int32,System.Int32,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetIncrement(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetIncrement(Garnet.server.ArgSlice,System.Double,Garnet.server.ArgSlice,System.Double@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRemoveRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRank(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRank(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Nullable{System.Int64}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRandomMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetRange(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.SortedSetOrderOperation,Garnet.server.ArgSlice[]@,System.String@,System.Boolean,System.Boolean,System.ValueTuple{System.String,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetDifference(Garnet.server.ArgSlice[],System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetUnion(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetDifferenceStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetIntersect(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetIntersectStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetExpire(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetExpire(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.DateTimeOffset,Garnet.server.ExpireOption,System.Int32[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetPersist(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetPersist(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetTimeToLive(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetTimeToLive(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.TimeSpan[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetCollect(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetCollect">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SortedSetCollect(System.ReadOnlySpan{Garnet.server.ArgSlice})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GeoAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GeoCommands(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GeoSearchReadOnly(Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.GeoSearchStore(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPush(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPush(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListPosition(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLeftPop(Garnet.server.ArgSlice[],System.Int32,Garnet.server.ArgSlice@,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRightPop(Garnet.server.ArgSlice[],System.Int32,Garnet.server.ArgSlice@,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.OperationDirection,Garnet.server.OperationDirection,System.Byte[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListTrim(Garnet.server.ArgSlice,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListTrim(System.Byte[],Garnet.server.ObjectInput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListInsert(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListIndex(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.ListSet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetMembers(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetMembers(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetIsMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetIsMember(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetRandomMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetUnionStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetDiff(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetDiffStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetIntersect(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.SetIntersectStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashSet(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashSetWhenNotExists(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashSet(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashSet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashDelete(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashDelete(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGet(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGetAll(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGetAll(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGetMultiple(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashGetMultiple(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashStrLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashExists(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashExists(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashRandomField(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashRandomField(Garnet.server.ArgSlice,System.Int32,System.Boolean,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashRandomField(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashDelete(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashKeys(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashVals(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashIncrement(System.Byte[],Garnet.server.ArgSlice,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashIncrement(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashExpire(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashPersist(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashTimeToLive(Garnet.server.ArgSlice,System.Boolean,System.Boolean,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetApi`2.HashCollect(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.GarnetStatus">
            <summary>
            Garnet API call return status
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetStatus.OK">
            <summary>
            OK
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetStatus.NOTFOUND">
            <summary>
            Not Found
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetStatus.MOVED">
            <summary>
            Moved
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetStatus.WRONGTYPE">
            <summary>
            Wrong type
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetWatchApi`1">
            <summary>
            Garnet API implementation for watch purposes
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GET(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GETForMemoryResult(Garnet.server.ArgSlice,Garnet.common.MemoryResult{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GET(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GET(System.Byte[],Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.LCS(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GETRANGE(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.TTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.PTTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.EXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.PEXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetCount(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetCount(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetLengthByValue(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetRandomMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetScore(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetScores(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetRank(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetRank(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Nullable{System.Int64}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetRange(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.SortedSetOrderOperation,Garnet.server.ArgSlice[]@,System.String@,System.Boolean,System.Boolean,System.ValueTuple{System.String,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetDifference(Garnet.server.ArgSlice[],System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetUnion(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GeoCommands(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GeoSearchReadOnly(Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetIntersect(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetTimeToLive(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SortedSetTimeToLive(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.TimeSpan[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.ListLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.ListLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.ListRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.ListIndex(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetMembers(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetIsMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetIsMember(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetMembers(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetUnion(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetIntersect(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.SetDiff(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashGet(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashGetMultiple(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashGetAll(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashLength(Garnet.server.ArgSlice,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashExists(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashRandomField(Garnet.server.ArgSlice,System.Int32,System.Boolean,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashRandomField(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashRandomField(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashGet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashStrLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashExists(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashKeys(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashVals(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HashTimeToLive(Garnet.server.ArgSlice,System.Boolean,System.Boolean,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringGetBit(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringGetBit(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringBitCount(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringBitCount(Garnet.server.ArgSlice,System.Int64,System.Int64,System.Int64@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringBitPosition(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.StringBitFieldReadOnly(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Garnet.server.RespCommand,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HyperLogLogLength(Garnet.server.RawStringInput@,System.Int64@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.HyperLogLogLength(System.Span{Garnet.server.ArgSlice},System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GetDbKeys(Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GetDbSize">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.DbScan(Garnet.server.ArgSlice,System.Boolean,System.Int64,System.Int64@,System.Collections.Generic.List{System.Byte[]}@,System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.IterateMainStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.IterateMainStore">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.IterateObjectStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.IterateObjectStore">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.GetScratchBufferOffset">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetWatchApi`1.ResetScratchBuffer(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.IGarnetAdvancedApi">
            <summary>
            Advanced API calls, not to be used by normal clients
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.GET_WithPending(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,System.Int64,System.Boolean@)">
            <summary>
            GET with support for pending multiple ongoing operations, scatter gather IO for outputs
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.GET_CompletePending(System.ValueTuple{Garnet.server.GarnetStatus,Tsavorite.core.SpanByteAndMemory}[],System.Boolean)">
            <summary>
            Complete pending read operations on main store
            </summary>
            <param name="outputArr"></param>
            <param name="wait"></param>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.GET_CompletePending(Tsavorite.core.CompletedOutputIterator{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,Garnet.server.RawStringInput,Tsavorite.core.SpanByteAndMemory,System.Int64}@,System.Boolean)">
            <summary>
            Complete pending read operations on main store
            </summary>
            <param name="completedOutputs"></param>
            <param name="wait"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.RMW_MainStore(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            RMW operation on main store
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.Read_MainStore(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Read operation on main store
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.RMW_ObjectStore(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            RMW operation on object store
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.Read_ObjectStore(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Read operation on object store
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetAdvancedApi.ReadWithPrefetch``1(``0@,System.Int64)">
            <summary>
            Read batch of keys on main store.
            </summary>
        </member>
        <member name="T:Garnet.server.IGarnetApi">
            <summary>
            Interface for Garnet API
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GETEX(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GETEX
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@)">
            <summary>
            SET
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@)">
            <summary>
            SET
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@)">
            <summary>
            SET Conditional
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.DEL_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@)">
            <summary>
            DEL Conditional
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET_Conditional(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            SET Conditional
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET(Garnet.server.ArgSlice,System.Memory{System.Byte})">
            <summary>
            SET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            SET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SET(System.Byte[],Garnet.server.IGarnetObject)">
            <summary>
            SET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SETEX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            SETEX
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <param name="expiryMs">Expiry in milliseconds, formatted as ASCII digits</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SETEX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.TimeSpan)">
            <summary>
            SETEX
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
            <param name="expiry">Expiry</param>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SETRANGE(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,Garnet.server.ArgSlice@)">
            <summary>
            SETRANGE
            </summary>
            <param name="key">Key</param>
            <param name="input"></param>
            <param name="output">The output of the operation</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.MSET_Conditional(Garnet.server.RawStringInput@)">
            <summary>
            MSETNX
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.APPEND(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            APPEND command
            </summary>
            <param name="key">Key whose value is to be appended</param>
            <param name="input"></param>
            <param name="output">Length of updated value</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.APPEND(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            APPEND command
            </summary>
            <param name="key">Key whose value is to be appended</param>
            <param name="value">Value to be appended</param>
            <param name="output">Length of updated value</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.RENAME(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,Garnet.server.StoreType)">
            <summary>
            RENAME
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="storeType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.RENAMENX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean,Garnet.server.StoreType)">
            <summary>
            Renames key to newkey if newkey does not yet exist. It returns an error when key does not exist.
            </summary>
            <param name="oldKey">The old key to be renamed.</param>
            <param name="newKey">The new key name.</param>
            <param name="result">The result of the operation.</param>
            <param name="storeType">The type of store to perform the operation on.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.EXISTS(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <summary>
            EXISTS
            </summary>
            <param name="key"></param>
            <param name="storeType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.EXPIRE(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <summary>
            Set a timeout on key
            </summary>
            <param name="key">Key</param>
            <param name="expiryMs">Expiry in milliseconds, formatted as ASCII digits</param>
            <param name="timeoutSet">Whether timeout was set by the call</param>
            <param name="storeType">Store type: main, object, or both</param>
            <param name="expireOption">Expire option</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.EXPIRE(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,System.Boolean@,Garnet.server.StoreType)">
            <summary>
            Set a timeout on key using a timeSpan in seconds
            </summary>
            <param name="key">Key</param>
            <param name="input"></param>
            <param name="timeoutSet">Whether timeout was set by the call</param>
            <param name="storeType">Store type: main, object, or both</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.EXPIRE(Garnet.server.ArgSlice,System.TimeSpan,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <summary>
            Set a timeout on key using a timeSpan in seconds
            </summary>
            <param name="key">Key</param>
            <param name="expiry">Expiry in TimeSpan</param>
            <param name="timeoutSet">Whether timeout was set by the call</param>
            <param name="storeType">Store type: main, object, or both</param>
            <param name="expireOption">Expire option</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.EXPIREAT(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <summary>
            Set a timeout on key using absolute Unix timestamp (seconds since January 1, 1970) in seconds
            </summary>
            <param name="key">Key</param>
            <param name="expiryTimestamp">Absolute Unix timestamp in seconds</param>
            <param name="timeoutSet">Whether timeout was set by the call</param>
            <param name="storeType">Store type: main, object, or both</param>
            <param name="expireOption">Expire option</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.PEXPIREAT(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption)">
            <summary>
            Set a timeout on key using absolute Unix timestamp (seconds since January 1, 1970) in milliseconds
            </summary>
            <param name="key">Key</param>
            <param name="expiryTimestamp">Absolute Unix timestamp in milliseconds</param>
            <param name="timeoutSet">Whether timeout was set by the call</param>
            <param name="storeType">Store type: main, object, or both</param>
            <param name="expireOption">Expire option</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.PERSIST(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <summary>
            PERSIST
            </summary>
            <param name="key">Key</param>
            <param name="storeType">Store type: main, object, or both</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.Increment(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,Garnet.server.ArgSlice@)">
            <summary>
            Increment (INCR, INCRBY, INCRBYFLOAT, DECR, DECRBY)
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.Increment(Garnet.server.ArgSlice,System.Int64@,System.Int64)">
            <summary>
            Increment (INCR, INCRBY)
            </summary>
            <param name="key"></param>
            <param name="output"></param>
            <param name="incrementCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.Decrement(Garnet.server.ArgSlice,System.Int64@,System.Int64)">
            <summary>
            Decrement (DECR, DECRBY)
            </summary>
            <param name="key"></param>
            <param name="output"></param>
            <param name="decrementCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.IncrementByFloat(Garnet.server.ArgSlice,Garnet.server.ArgSlice@,System.Double)">
            <summary>
            Increment by float (INCRBYFLOAT)
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.IncrementByFloat(Garnet.server.ArgSlice,System.Double@,System.Double)">
            <summary>
            Increment by float (INCRBYFLOAT)
            </summary>
            <param name="key"></param>
            <param name="output"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.DELETE(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <summary>
            DELETE
            </summary>
            <param name="key"></param>
            <param name="storeType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.DELETE(Tsavorite.core.SpanByte@,Garnet.server.StoreType)">
            <summary>
            DELETE
            </summary>
            <param name="key"></param>
            <param name="storeType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.DELETE(System.Byte[],Garnet.server.StoreType)">
            <summary>
            DELETE
            </summary>
            <param name="key"></param>
            <param name="storeType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GETDEL(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GETDEL
            </summary>
            <param name="key"> Key to get and delete </param>
            <param name="output"> Current value of key </param>
            <returns> Operation status </returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GETDEL(Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GETDEL
            </summary>
            <param name="key"> Key to get and delete </param>
            <param name="output"> Current value of key </param>
            <returns> Operation status </returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GetKeyType(Garnet.server.ArgSlice,System.String@)">
            <summary>
            Returns the string representation of the type of the value stored at key.
            string, list, set, zset, and hash.
            </summary>
            <param name="key"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.MemoryUsageForKey(Garnet.server.ArgSlice,System.Int64@,System.Int32)">
            <summary>
             Gets the number of bytes that a key and its value require to be stored in RAM.
            </summary>
            <param name="key">Name of the key or object to get the memory usage</param>
            <param name="memoryUsage">The value in bytes the key or object is using</param>
            <param name="samples">Number of sampled nested values</param>
            <returns>GarnetStatus</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Adds the specified member with the specified score to the sorted set stored at key.
            </summary>
            <param name="key">Key</param>
            <param name="score">Score</param>
            <param name="member">Member</param>
            <param name="zaddCount">Number of adds performed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetAdd(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key.
            Current members get the score updated and reordered.
            </summary>
            <param name="key">Key</param>
            <param name="inputs">Input key-value pairs to add</param>
            <param name="zaddCount">Number of adds performed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key.
            Current members get the score updated and reordered.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRangeStore(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ObjectInput@,System.Int32@)">
            <summary>
            Stores a range of sorted set elements in the specified key space.
            </summary>
            <param name="dstKey">The distribution key for the sorted set.</param>
            <param name="srcKey">The sub-key for the sorted set.</param>
            <param name="input">The input object containing the elements to store.</param>
            <param name="result">The result of the store operation.</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Removes the specified member from the sorted set stored at key.
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            Removes the specified members from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <param name="key">Key</param>
            <param name="members">Input members to remove</param>
            <param name="zremCount">Number of removes performed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Removes the specified members from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemoveRangeByLex(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Removes all elements in the sorted set between the
            lexicographical range specified by min and max.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Removes and returns the first element from the sorted set stored at key,
            with the scores ordered from low to high (min) or high to low (max).
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetMPop(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32,System.Boolean,Garnet.server.ArgSlice@,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@)">
            <summary>
            Removes and returns multiple elements from a sorted set.
            </summary>
            <param name="keys">The keys of the sorted set.</param>
            <param name="count">The number of elements to pop.</param>
            <param name="lowScoresFirst">If true, elements with the lowest scores are popped first; otherwise, elements with the highest scores are popped first.</param>
            <param name="poppedKey">The key of the popped element.</param>
            <param name="pairs">An array of tuples containing the member and score of each popped element.</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the result of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetPop(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@,System.Int32,System.Boolean)">
            <summary>
            Removes and returns up to count members with the highest or lowest scores in the sorted set stored at key.
            </summary>
            <param name="key"></param>
            <param name="pairs"></param>
            <param name="count"></param>
            <param name="lowScoresFirst">When true, return the members with the lowest scores, otherwise return the highest scores.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetIncrement(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment.
            If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0).
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetIncrement(Garnet.server.ArgSlice,System.Double,Garnet.server.ArgSlice,System.Double@)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment.
            Returns the new score of member.
            If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0).
            </summary>
            <param name="key"></param>
            <param name="increment"></param>
            <param name="member"></param>
            <param name="newScore"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemoveRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            ZREMRANGEBYRANK: Removes all elements in the sorted set stored at key with rank between start and stop.
            Both start and stop are 0 -based indexes with 0 being the element with the lowest score.
            ZREMRANGEBYSCORE: Removes all elements in the sorted set stored at key with a score between min and max (inclusive by default).
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemoveRangeByLex(Garnet.server.ArgSlice,System.String,System.String,System.Int32@)">
            <summary>
            Removes all elements in the range specified by min and max, having the same score.
            </summary>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="countRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemoveRangeByScore(Garnet.server.ArgSlice,System.String,System.String,System.Int32@)">
            <summary>
            Removes all elements that have a score in the range specified by min and max.
            </summary>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="countRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetRemoveRangeByRank(Garnet.server.ArgSlice,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Removes all elements with the index in the range specified by start and stop.
            </summary>
            <param name="key"></param>
            <param name="start"></param>
            <param name="stop"></param>
            <param name="countRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetDifferenceStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32@)">
            <summary>
            Computes the difference between the first and all successive sorted sets and store resulting pairs in the output key.
            </summary>
            <param name="keys"></param>
            <param name="destinationKey"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GeoAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Adds geospatial items (longitude, latitude, name) to the specified key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.GeoSearchStore(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Geospatial search and store in destination key.
            </summary>
            <param name="key"></param>
            <param name="destinationKey"></param>
            <param name="opts"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetIntersectStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Int32@)">
            <summary>
            Intersects multiple sorted sets and stores the result in the destination key.
            </summary>
            <param name="destinationKey">The key where the result will be stored.</param>
            <param name="keys">The keys of the sorted sets to intersect.</param>
            <param name="weights">The weights to apply to each sorted set during the intersection.</param>
            <param name="aggregateType">The type of aggregation to use for the intersection.</param>
            <param name="count">The number of elements in the resulting sorted set.</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetUnionStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Int32@)">
            <summary>
            Performs a union of multiple sorted sets and stores the result in the destination key.
            </summary>
            <param name="destinationKey">The key where the result will be stored.</param>
            <param name="keys">The keys of the sorted sets to union.</param>
            <param name="count">The number of elements in the resulting sorted set.</param>
            <param name="weights">Optional weights to apply to each sorted set.</param>
            <param name="aggregateType">The type of aggregation to perform (e.g., Sum, Min, Max).</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetExpire(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Sets an expiration time on a sorted set member.
            </summary>
            <param name="key">The key of the sorted set.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetExpire(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.DateTimeOffset,Garnet.server.ExpireOption,System.Int32[]@)">
            <summary>
            Sets an expiration time on a sorted set member.
            </summary>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members to set expiration for.</param>
            <param name="expireAt">The expiration time.</param>
            <param name="expireOption">The expiration option to apply.</param>
            <param name="results">The results of the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetPersist(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Persists the specified sorted set member, removing any expiration time set on it.
            </summary>
            <param name="key">The key of the sorted set to persist.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetPersist(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32[]@)">
            <summary>
            Persists the specified sorted set members, removing any expiration time set on them.
            </summary>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members to persist.</param>
            <param name="results">The results of the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetCollect(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@)">
            <summary>
            Deletes already expired members from the sorted set.
            </summary>
            <param name="keys">The keys of the sorted set members to check for expiration.</param>
            <param name="input">The input object containing additional parameters.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetCollect">
            <summary>
            Collects expired elements from the sorted set.
            </summary>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SortedSetCollect(System.ReadOnlySpan{Garnet.server.ArgSlice})">
            <summary>
            Collects expired elements from the sorted set for the specified keys.
            </summary>
            <param name="keys">The keys of the sorted sets to collect expired elements from.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
             Adds the specified member to the set at key.
             If key does not exist, a new set is created.
            </summary>
            <param name="key"></param>
            <param name="member"></param>
            <param name="saddCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetAdd(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
             Adds the specified members to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <param name="key"></param>
            <param name="members"></param>
            <param name="saddCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetAdd(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
             Adds the specified members to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Removes the specified member from the set.
            Specified members that are not a member of this set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <param name="key"></param>
            <param name="member"></param>
            <param name="sremCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetRemove(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            Removes the specified members from the set.
            Specified members that are not a member of this set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <param name="key"></param>
            <param name="members"></param>
            <param name="sremCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Removes the specified members from the set.
            Specified members that are not a member of this set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            Removes and returns one random member from the set at key.
            </summary>
            <param name="key"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            Removes and returns random members from the set at key.
            </summary>
            <param name="key"></param>
            <param name="count"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Removes and returns random members from the set at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Moves a member from a source set to a destination set.
            If the move was performed, this command returns 1.
            If the member was not found in the source set, or if no operation was performed, this command returns 0.
            </summary>
            <param name="sourceKey"></param>
            <param name="destinationKey"></param>
            <param name="member"></param>
            <param name="smoveResult"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetRandomMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            When called with just the key argument, return a random element from the set value stored at key.
            If the provided count argument is positive, return an array of distinct elements.
            The array's length is either count or the set's cardinality (SCARD), whichever is lower.
            If called with a negative count, the behavior changes and the command is allowed to return the same element multiple times.
            In this case, the number of returned elements is the absolute value of the specified count.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetUnionStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SUNION, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key"></param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetIntersectStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SINTER, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key"></param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.SetDiffStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SDIFF, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key">destination</param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListPosition(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            The command returns the index of matching elements inside a Redis list.
            By default, when no options are given, it will scan the list from head to tail, looking for the first match of "element".
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPush(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            ListLeftPush ArgSlice version with ObjectOutputHeader output
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean)">
            <summary>
            ListLeftPush ArgSlice version, one element
            </summary>
            <param name="key"></param>
            <param name="element"></param>
            <param name="count"></param>
            <param name="whenExists">When true the operation is executed only if the key already exists</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,System.Boolean)">
            <summary>
            ListLeftPush ArgSlice version for multiple values
            </summary>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="count"></param>
            <param name="whenExists">When true the operation is executed only if the key already exists</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPush(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            ListRightPush ArgSlice version with ObjectOutputHeader output
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,System.Boolean)">
            <summary>
            ListRightPush ArgSlice version, one element
            </summary>
            <param name="key"></param>
            <param name="element"></param>
            <param name="count"></param>
            <param name="whenExists">When true the operation is executed only if the key already exists</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPush(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,System.Boolean)">
            <summary>
            ListRightPush ArgSlice version for multiple values
            </summary>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="count"></param>
            <param name="whenExists">When true the operation is executed only if the key already exists</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            ListLeftPop ArgSlice version, with GarnetObjectStoreOuput
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            ListLeftPop ArgSlice version, one element
            </summary>
            <param name="key"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            ListLeftPop ArgSlice version for multiple values
            </summary>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListLeftPop(Garnet.server.ArgSlice[],System.Int32,Garnet.server.ArgSlice@,Garnet.server.ArgSlice[]@)">
            <summary>
            ListLeftPop ArgSlice version for multiple keys and values
            </summary>
            <param name="keys"></param>
            <param name="count"></param>
            <param name="key"></param>
            <param name="elements"></param>
            <returns>GarnetStatus</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPop(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            ListRightPop ArgSlice version, with GarnetObjectStoreOutput
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPop(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            ListRightPop ArgSlice version, one element
            </summary>
            <param name="key"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPop(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            ListRightPop ArgSlice version for multiple values
            </summary>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRightPop(Garnet.server.ArgSlice[],System.Int32,Garnet.server.ArgSlice@,Garnet.server.ArgSlice[]@)">
            <summary>
            ListRightPop ArgSlice version for multiple keys and values
            </summary>
            <param name="keys"></param>
            <param name="count"></param>
            <param name="key"></param>
            <param name="elements"></param>
            <returns>GarnetStatus</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.OperationDirection,Garnet.server.OperationDirection,System.Byte[]@)">
            <summary>
            Atomically removes the first/last element of the list stored at source
            and pushes it to the first/last element of the list stored at destination.
            </summary>
            <param name="sourceKey"></param>
            <param name="destinationKey"></param>
            <param name="sourceDirection"></param>
            <param name="destinationDirection"></param>
            <param name="element">The element being popped and pushed</param>
            <returns>GarnetStatus</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListTrim(Garnet.server.ArgSlice,System.Int32,System.Int32)">
            <summary>
            Trim an existing list so it only contains the specified range of elements.
            </summary>
            <param name="key"></param>
            <param name="start"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListTrim(System.Byte[],Garnet.server.ObjectInput@)">
            <summary>
            Trim an existing list so it only contains the specified range of elements.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListInsert(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Inserts a new element in the list stored at key either before or after a value pivot
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListRemove(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Removes the first count occurrences of elements equal to element from the list.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.ListSet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Sets the list element at index to element.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashSet(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Sets the specified field to their respective value in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashSet(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@)">
            <summary>
            Sets the specified fields to their respective values in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashSet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Sets or updates the values of the specified fields that exist in the hash.
            if the Hash doesn't exist, a new a new hash is created.
            HashSet with nx parameter
            HashSet key field value
            HashSet key field value [field value...]
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashSetWhenNotExists(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Set only if field does not yet exist. If key does not exist, a new key holding a hash is created.
            If field already exists, no action is performed.
            HashSet only when field does not exist
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashDelete(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Removes the specified field from the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="count">Number of fields removed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashDelete(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            Removes the specified fields from the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="fields"></param>
            <param name="count">Number of fields removed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashDelete(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Removes the specified fields from the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashIncrement(System.Byte[],Garnet.server.ArgSlice,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Increments the number stored at field in the hash key by increment parameter.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashIncrement(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Increments the number stored at field representing a floating point value
            in the hash key by increment parameter.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashExpire(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Sets an expiration time on a hash field.
            </summary>
            <param name="key">The key of the hash.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashPersist(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Persists the specified hash key, removing any expiration time set on it.
            </summary>
            <param name="key">The key of the hash to persist.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HashCollect(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@)">
            <summary>
            Deletes already expired fields from the hash.
            </summary>
            <param name="keys">The keys of the hash fields to check for expiration.</param>
            <param name="input">The input object containing additional parameters.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringSetBit(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Boolean@)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="offset"></param>
             <param name="bit"></param>
             <param name="previous"></param>
             <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringSetBit(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Sets or clears the bit at offset in the given key.
            The bit is either set or cleared depending on value, which can be either 0 or 1.
            When key does not exist, a new key is created.The key is grown to make sure it can hold a bit at offset.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringBitOperation(Garnet.server.RawStringInput@,Garnet.server.BitmapOperation,System.Int64@)">
            <summary>
            Performs a bitwise operations on multiple keys
            </summary>
            <param name="input"></param>
            <param name="bitOp"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringBitOperation(Garnet.server.BitmapOperation,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int64@)">
            <summary>
            Perform a bitwise operation between multiple keys
            and store the result in the destination key.
            </summary>
            <param name="bitop"></param>
            <param name="destinationKey"></param>
            <param name="keys"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringBitField(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Garnet.server.RespCommand,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Performs arbitrary bitfield integer operations on strings.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="secondaryCommand"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.StringBitField(Garnet.server.ArgSlice,System.Collections.Generic.List{Garnet.server.BitFieldCmdArgs},System.Collections.Generic.List{System.Nullable{System.Int64}}@)">
            <summary>
            Performs arbitrary bitfield integer operations on strings.
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HyperLogLogAdd(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Adds all the element arguments to the HyperLogLog data structure stored at the variable name specified as key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HyperLogLogAdd(Garnet.server.ArgSlice,System.String[],System.Boolean@)">
            <summary>
            Adds all the element arguments to the HyperLogLog data structure stored at the variable name specified as key.
            </summary>
            <param name="keys"></param>
            <param name="elements"></param>
            <param name="updated">true if at least 1 HyperLogLog internal register was altered</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetApi.HyperLogLogMerge(Garnet.server.RawStringInput@,System.Boolean@)">
            <summary>
            Merge multiple HyperLogLog values into a unique value that will approximate the cardinality
            of the union of the observed Sets of the source HyperLogLog structures.
            </summary>
            <param name="input"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.IGarnetReadApi">
            <summary>
            Interface for Garnet API
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GET(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GET
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GETForMemoryResult(Garnet.server.ArgSlice,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            GET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GET(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            GET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GET(System.Byte[],Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            GET
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.LCS(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Finds the longest common subsequence (LCS) between two keys.
            </summary>
            <param name="key1">The first key to compare.</param>
            <param name="key2">The second key to compare.</param>
            <param name="output">The output containing the LCS result.</param>
            <param name="lenOnly">If true, only the length of the LCS is returned.</param>
            <param name="withIndices">If true, the indices of the LCS in both keys are returned.</param>
            <param name="withMatchLen">If true, the length of each match is returned.</param>
            <param name="minMatchLen">The minimum length of a match to be considered.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GETRANGE(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GETRANGE
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.TTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the remaining time to live in seconds of a key that has a timeout.
            </summary>
            <param name="key">The key to return the remaining time to live in the store</param>
            <param name="storeType">The store type to operate on.</param>
            <param name="output">The span to allocate the output of the operation.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.PTTL(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the remaining time to live in milliseconds of a key that has a timeout.
            </summary>
            <param name="key">The key to return the remaining time to live in the store.</param>
            <param name="storeType">The store type to operate on.</param>
            <param name="output">The span to allocate the output of the operation.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.EXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the absolute Unix timestamp (since January 1, 1970) in seconds at which the given key will expire.
            </summary>
            <param name="key">The key to get the expiration time for.</param>
            <param name="storeType">The type of store to retrieve the key from.</param>
            <param name="output">The output containing the expiration time.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.PEXPIRETIME(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds at which the given key will expire.
            </summary>
            <param name="key">The key to get the expiration time for.</param>
            <param name="storeType">The type of store to retrieve the key from.</param>
            <param name="output">The output containing the expiration time.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetLength(Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Returns the sorted set cardinality (number of elements) of the sorted set
            </summary>
            <param name="key">Key</param>
            <param name="zcardCount"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Returns the sorted set cardinality (number of elements) of the sorted set
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key.
            Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next element and so on.
            There can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetScore(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the score of member in the sorted set at key.
            If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetScores(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the scores associated with the specified members in the sorted set stored at key.
            For every member that does not exist in the sorted set, a nil value is returned.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetCount(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            </summary>
            <param name="key">Key</param>
            <param name="minScore">Min Score</param>
            <param name="maxScore">Max score</param>
            <param name="numElements">Number of elements</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetCount(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetLengthByValue(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Returns the number of elements in the sorted set with a value between min and max.
            When all the elements in a sorted set have the same score,
            this command forces lexicographical ordering.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetRank(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            ZRANK: Returns the rank of member in the sorted set, the scores in the sorted set are ordered from low to high
            ZREVRANK: Returns the rank of member in the sorted set, with the scores ordered from high to low
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetRank(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Nullable{System.Int64}@)">
            <summary>
            ZRANK: Returns the rank of member in the sorted set, the scores in the sorted set are ordered from low to high
            ZREVRANK: Returns the rank of member in the sorted set, with the scores ordered from high to low
            </summary>
            <param name="key"></param>
            <param name="member"></param>
            <param name="reverse"></param>
            <param name="rank"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetRandomMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns a random element from the sorted set key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetRange(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.SortedSetOrderOperation,Garnet.server.ArgSlice[]@,System.String@,System.Boolean,System.Boolean,System.ValueTuple{System.String,System.Int32})">
            <summary>
            Returns the specified range of elements in the sorted set stored at key, using byscore, bylex and rev modifiers.
            Min and max are range boundaries, where 0 is the first element, 1 is the next element and so on.
            There can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="sortedSetOrderOperation"></param>
            <param name="elements"></param>
            <param name="error"></param>
            <param name="withScores"></param>
            <param name="reverse"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetDifference(Garnet.server.ArgSlice[],System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <summary>
            Computes the difference between the first and all successive sorted sets and returns resulting pairs.
            </summary>
            <param name="keys"></param>
            <param name="pairs"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetUnion(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <summary>
            Performs a union of multiple sorted sets and stores the result in a dictionary.
            </summary>
            <param name="keys">A read-only span of ArgSlice representing the keys of the sorted sets to union.</param>
            <param name="pairs">An output sorted set where the result of the union will be stored.</param>
            <param name="weights">An optional array of doubles representing the weights to apply to each sorted set during the union.</param>
            <param name="aggregateType">The type of aggregation to use when combining scores from the sorted sets. Defaults to <see cref="F:Garnet.server.SortedSetAggregateType.Sum"/>.</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            Iterates members of SortedSet key and their associated scores using a cursor,
            a match pattern and count parameters
            </summary>
            <param name="key">The key of the sorted set</param>
            <param name="cursor">The value of the cursor</param>
            <param name="match">The pattern to match the members</param>
            <param name="count">Limit number for the response</param>
            <param name="items">The list of items for the response</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetIntersect(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <summary>
            Intersects multiple sorted sets and returns the result.
            </summary>
            <param name="keys">The keys of the sorted sets to intersect.</param>
            <param name="weights">The weights to apply to each sorted set.</param>
            <param name="aggregateType">The type of aggregation to perform.</param>
            <param name="pairs">The resulting dictionary of intersected elements and their scores.</param>
            <returns>A <see cref="T:Garnet.server.GarnetStatus"/> indicating the status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <summary>
            Computes the intersection of multiple sorted sets and counts the elements.
            </summary>
            <param name="keys">Input sorted set keys</param>
            <param name="limit">Optional max count limit</param>
            <param name="count">The count of elements in the intersection</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetTimeToLive(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the time to live for a sorted set members.
            </summary>
            <param name="key">The key of the sorted set.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SortedSetTimeToLive(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.TimeSpan[]@)">
            <summary>
            Returns the time to live for a sorted set members.
            </summary>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members to get the time to live for.</param>
            <param name="expireIn">The output array containing the time to live for each member.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GeoCommands(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            GEOHASH: Returns valid Geohash strings representing the position of one or more elements in a geospatial data of the sorted set.
            GEODIST: Returns the distance between two members in the geospatial index represented by the sorted set.
            GEOPOS: Returns the positions (longitude,latitude) of all the specified members in the sorted set.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GeoSearchReadOnly(Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            GEORADIUS (read variant): Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUS_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUSBYMEMBER (read variant): Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            GEORADIUSBYMEMBER_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            GEOSEARCH: Returns the members of a sorted set populated with geospatial data, which are within the borders of the area specified by a given shape.
            </summary>
            <param name="key"></param>
            <param name="opts"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ListLength(Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Gets length of the list
            </summary>
            <param name="key"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ListLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Gets length of the list, RESP version
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ListRange(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Gets the specified elements of the list stored at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ListIndex(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the element at index.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetLength(Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            SCARD key
            </summary>
            <param name="key">Key</param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Returns the number of elements of the set.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetMembers(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <summary>
            SMEMBERS key
            </summary>
            <param name="key"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetMembers(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns all members of the set at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetIsMember(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns if member is a member of the set stored at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetIsMember(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32[]@)">
            <summary>
            Returns whether each member is a member of the set stored at key.
            </summary>
            <param name="key"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            Iterates over the members of the Set with the given key using a cursor,
            a match pattern and count parameters.
            </summary>
            <param name="key"></param>
            <param name="cursor"></param>
            <param name="match"></param>
            <param name="count"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetUnion(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the union of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="keys"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetIntersect(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the intersection of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="keys"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetDiff(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the difference between the first set and all the successive sets.
            </summary>
            <param name="keys"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.SetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <summary>
            Returns the cardinality of the intersection between multiple sets.
            When limit is greater than 0, stops counting when reaching limit.
            </summary>
            <param name="keys">Keys of the sets to intersect</param>
            <param name="limit">Optional limit to stop counting at</param>
            <param name="count">The cardinality of the intersection</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGet(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            Returns the value associated to the field in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGetMultiple(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice[]@)">
            <summary>
            Returns the values associated with the fields in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="fields"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGet(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="input">The metadata input for the operation</param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGetAll(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns all fields and values of the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="input">The metadata input for the operation</param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGetMultiple(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="input">The metadata input for the operation</param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashGetAll(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@)">
            <summary>
            Returns ALL the values in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashLength(Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Returns the number of fields contained in the hash Key
            </summary>
            <param name="key"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashStrLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
             <summary>
            Returns the string length of the value associated with field in the hash stored at key. If the key or the field do not exist, 0 is returned.
             </summary>
             <param name="key"></param>
             <param name="input"></param>
             <param name="output"></param>
             <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashLength(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Returns the number of fields contained in the hash Key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashExists(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <summary>
            Returns if field is an existing field in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="exists"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashExists(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@)">
            <summary>
            Returns if field is an existing field in the hash stored at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashRandomField(Garnet.server.ArgSlice,System.Int32,System.Boolean,Garnet.server.ArgSlice[]@)">
            <summary>
            Returns count random fields from the hash value.
            </summary>
            <param name="key"></param>
            <param name="count"></param>
            <param name="withValues"></param>
            <param name="fields"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashRandomField(Garnet.server.ArgSlice,Garnet.server.ArgSlice@)">
            <summary>
            Returns a random field from the hash value stored at key.
            </summary>
            <param name="key"></param>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashRandomField(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns a random field(s) from the hash value stored at key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashKeys(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns all field names in the hash key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashVals(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns all values in the hash key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashScan(Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@)">
            <summary>
            Iterates fields of Hash key and their associated values using a cursor,
            a match pattern and count parameters
            </summary>
            <param name="key"></param>
            <param name="cursor"></param>
            <param name="match"></param>
            <param name="count"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HashTimeToLive(Garnet.server.ArgSlice,System.Boolean,System.Boolean,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Returns the time to live for a hash key.
            </summary>
            <param name="key">The key of the hash.</param>
            <param name="isMilliseconds">Indicates if the time to live is in milliseconds.</param>
            <param name="isTimestamp">Indicates if the time to live is a timestamp.</param>
            <param name="input">The input object containing additional parameters.</param>
            <param name="output">The output object to store the result.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringGetBit(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the bit value at offset in the key stored.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringGetBit(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@)">
            <summary>
            Returns the bit value at offset in the key stored.
            </summary>
            <param name="key"></param>
            <param name="offset"></param>
            <param name="bValue"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringBitCount(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Count the number of set bits in a string.
            It can be specified an interval for counting, passing the start and end arguments.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringBitCount(Garnet.server.ArgSlice,System.Int64,System.Int64,System.Int64@,System.Boolean)">
            <summary>
            Count the number of set bits in a string.
            It can be specified an interval for counting, passing the start and end arguments.
            </summary>
            <param name="key"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="result"></param>
            <param name="useBitInterval"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringBitPosition(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Returns the position of the first bit set to 1 or 0 in a key.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.StringBitFieldReadOnly(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Garnet.server.RespCommand,Tsavorite.core.SpanByteAndMemory@)">
            <summary>
            Read-only variant of the StringBitField method.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="secondaryCommand"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HyperLogLogLength(Garnet.server.RawStringInput@,System.Int64@,System.Boolean@)">
            <summary>
            Returns the approximated cardinality computed by the HyperLogLog data structure stored at the specified key,
            or 0 if the key does not exist.
            </summary>
            <param name="input"></param>
            <param name="count"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.HyperLogLogLength(System.Span{Garnet.server.ArgSlice},System.Int64@)">
             <summary>
            
             </summary>
             <param name="keys"></param>
             <param name="count"></param>
             <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GetDbKeys(Garnet.server.ArgSlice)">
            <summary>
            Gets the keys store in the DB matching the given pattern
            </summary>
            <param name="pattern">Expression to match the keys name</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GetDbSize">
            <summary>
            Gets the number of existing keys in both stores
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.DbScan(Garnet.server.ArgSlice,System.Boolean,System.Int64,System.Int64@,System.Collections.Generic.List{System.Byte[]}@,System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Iterates the set of keys in the main store.
            </summary>
            <param name="patternB">The pattern to apply for filtering</param>
            <param name="allKeys">When true the filter is ommited</param>
            <param name="cursor">The value of the cursor in the command request</param>
            <param name="storeCursor">Value of the cursor returned</param>
            <param name="Keys">The list of keys from the stores</param>
            <param name="count">The size of the batch of keys</param>
            <param name="type">Type of key to filter out</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.IterateMainStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Iterate the contents of the main store
            </summary>
            <typeparam name="TScanFunctions"></typeparam>
            <param name="scanFunctions"></param>
            <param name="untilAddress"></param>
            <param name="maxAddress"></param>
            <param name="cursor"></param>
            <param name="includeTombstones"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.IterateMainStore">
            <summary>
            Iterate the contents of the main store (pull based)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.IterateObjectStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Iterate the contents of the object store
            </summary>
            <typeparam name="TScanFunctions"></typeparam>
            <param name="scanFunctions"></param>
            <param name="untilAddress"></param>
            <param name="maxAddress"></param>
            <param name="cursor"></param>
            <param name="includeTombstones"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.IterateObjectStore">
            <summary>
            Iterate the contents of the object store (pull based)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ObjectScan(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Iterates over the items of a collection object using a cursor,
            a match pattern and count parameters
            </summary>
            <param name="key">The key of the sorted set</param>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.GetScratchBufferOffset">
            <summary>
            Retrieve the current scratch buffer offset.
            </summary>
            <returns>Current offset</returns>
        </member>
        <member name="M:Garnet.server.IGarnetReadApi.ResetScratchBuffer(System.Int32)">
            <summary>
            Resets the scratch buffer to the given offset.
            </summary>
            <param name="offset">Offset to reset to</param>
            <returns>True if successful, else false</returns>
        </member>
        <member name="T:Garnet.server.IGarnetWatchApi">
            <summary>
            Garnet Watch API
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetWatchApi.WATCH(Garnet.server.ArgSlice,Garnet.server.StoreType)">
            <summary>
            WATCH
            </summary>
            <param name="key"></param>
            <param name="type"></param>
        </member>
        <member name="M:Garnet.server.IGarnetWatchApi.WATCH(System.Byte[],Garnet.server.StoreType)">
            <summary>
            WATCH
            </summary>
            <param name="key"></param>
            <param name="type"></param>
        </member>
        <member name="T:Garnet.server.ArgSlice">
            <summary>
            Represents contiguous region of arbitrary _pinned_ memory.
            </summary>
            <remarks>
            SAFETY: This type is used to represent arguments that are assumed to point to pinned memory.
            </remarks>
        </member>
        <member name="M:Garnet.server.ArgSlice.#ctor(System.Byte*,System.Int32)">
            <summary>
            Create new ArgSlice from given pointer and length
            </summary>
        </member>
        <member name="M:Garnet.server.ArgSlice.#ctor(Tsavorite.core.SpanByte@)">
            <summary>
            Create new ArgSlice from given SpanByte (without metadata header)
            </summary>
        </member>
        <member name="P:Garnet.server.ArgSlice.Length">
            <summary>
            Get length of ArgSlice
            </summary>
        </member>
        <member name="P:Garnet.server.ArgSlice.ReadOnlySpan">
            <summary>
            Get slice as ReadOnlySpan
            </summary>
        </member>
        <member name="P:Garnet.server.ArgSlice.Span">
            <summary>
            Get slice as Span
            </summary>
        </member>
        <member name="P:Garnet.server.ArgSlice.SpanByte">
            <summary>
            Get slice as SpanByte
            </summary>
        </member>
        <member name="M:Garnet.server.ArgSlice.ToArray">
            <summary>
            Copies the contents of this slice into a new array.
            </summary>
        </member>
        <member name="M:Garnet.server.ArgSlice.ToString">
            <summary>
            Decodes the contents of this slice as ASCII into a new string.
            </summary>
            <returns>A string ASCII decoded string from the slice.</returns>
        </member>
        <member name="M:Garnet.server.ArgSlice.FromPinnedSpan(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a <see cref="T:Garnet.server.ArgSlice"/> from the given <paramref name="span"/>.
            </summary>
            <remarks>
            SAFETY: The <paramref name="span"/> MUST point to pinned memory.
            </remarks>
        </member>
        <member name="M:Garnet.server.ArgSlice.Equals(Garnet.server.ArgSlice)">
            <summary>
            Check for equality to the provided argSlice
            </summary>
            <param name="argSlice"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ArgSliceComparer">
            <summary>
            ArgSlice Comparer
            </summary>
        </member>
        <member name="F:Garnet.server.ArgSliceComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Garnet.server.ArgSliceComparer.Equals(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ArgSliceComparer.GetHashCode(Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.ArgSliceUtils">
            <summary>
            ArgSlice utils
            </summary>
        </member>
        <member name="M:Garnet.server.ArgSliceUtils.HashSlot(Garnet.server.ArgSlice@)">
            <summary>
            Compute hash slot of given ArgSlice
            </summary>
        </member>
        <member name="T:Garnet.server.ArgSliceVector">
            <summary>
            Vector of ArgSlices
            </summary>
            <param name="maxItemNum"></param>
        </member>
        <member name="M:Garnet.server.ArgSliceVector.#ctor(System.Int32)">
            <summary>
            Vector of ArgSlices
            </summary>
            <param name="maxItemNum"></param>
        </member>
        <member name="M:Garnet.server.ArgSliceVector.TryAddItem(System.Span{System.Byte})">
            <summary>
            Try to add ArgSlice
            </summary>
            <param name="item"></param>
            <returns>True if it succeeds to add ArgSlice, false if maxCount has been reached.</returns>
        </member>
        <member name="M:Garnet.server.ArgSliceVector.Clear">
            <summary>
            Clear ArgSliceVector
            </summary>
        </member>
        <member name="T:Garnet.server.ScratchBufferAllocator">
             <summary>
             <see cref="T:Garnet.server.ScratchBufferAllocator"/> is responsible for allocating sufficient memory and copying data into a buffer
             and returning an <see cref="T:Garnet.server.ArgSlice"/> to the caller.
             Whenever the current buffer runs out of space, a new buffer is allocated, without copying the previous buffer data.
             The previous allocated buffers are kept rooted in a stack by the manager, so that each <see cref="T:Garnet.server.ArgSlice"/> that wasn't explicitly
             rewound is not going to be GCed.
            
             The manager is meant to be called from a single-threaded context (i.e. one manager per session).
             Each call to CreateArgSlice will copy the data to the current or new buffer that could contain the data in its entirety,
             so rewinding the <see cref="T:Garnet.server.ArgSlice"/> (i.e. releasing the memory) should be called in reverse order to assignment.
             
             Note: Use <see cref="T:Garnet.server.ScratchBufferBuilder"/> if you need all data to remain in a continuous chunk of memory (which is not promised by
             <see cref="T:Garnet.server.ScratchBufferAllocator"/>) and you do not need to reuse previously returned <see cref="T:Garnet.server.ArgSlice"/> structs
             (as consequent allocations may cause them to point to GCed areas in memory).
             </summary>
        </member>
        <member name="T:Garnet.server.ScratchBufferAllocator.ScratchBuffer">
            <summary>
            <see cref="T:Garnet.server.ScratchBufferAllocator.ScratchBuffer"/> represents a buffer managed by <see cref="T:Garnet.server.ScratchBufferAllocator"/>
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferAllocator.ScratchBuffer.scratchBuffer">
            <summary>
            Session-local scratch buffer to hold temporary arguments in transactions and GarnetApi
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferAllocator.ScratchBuffer.scratchBufferHead">
            <summary>
            Pointer to head of scratch buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferAllocator.ScratchBuffer.scratchBufferOffset">
            <summary>
            Current offset in scratch buffer
            </summary>
        </member>
        <member name="P:Garnet.server.ScratchBufferAllocator.ScratchBuffer.Length">
            <summary>
            Length of the entire scratch buffer
            </summary>
        </member>
        <member name="P:Garnet.server.ScratchBufferAllocator.ScratchBuffer.IsDefault">
            <summary>
            True if buffer was not yet allocated
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.ScratchBuffer.Initialize(System.Int32)">
            <summary>
            Initializes the scratch buffer to a specified length
            </summary>
            <param name="length">The length of the buffer</param>
        </member>
        <member name="P:Garnet.server.ScratchBufferAllocator.ScratchBufferOffset">
            <summary>
            Combined offset in all managed scratch buffers
            </summary>
        </member>
        <member name="P:Garnet.server.ScratchBufferAllocator.TotalLength">
            <summary>
            Total length of all currently managed buffers
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an instance of <see cref="T:Garnet.server.ScratchBufferAllocator"/>
            </summary>
            <param name="minSizeBuffer">Min size that can be allocated for a single buffer (Default: 2)</param>
            <param name="maxInitialCapacity">Max size of previously allocated unused buffer to keep upon reset (Default: no limit)</param>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.Reset">
            <summary>
            Reset all scratch buffers managed by the <see cref="T:Garnet.server.ScratchBufferAllocator"/>.
            Loses all <see cref="T:Garnet.server.ArgSlice"/>s created on the scratch buffers.
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.RewindScratchBuffer(Garnet.server.ArgSlice@)">
            <summary>
            Rewind (pop) the last entry of the current scratch buffer (rewinding the current scratch buffer offset),
            if it contains the given <see cref="T:Garnet.server.ArgSlice"/>
            </summary>
            <param name="slice">The <see cref="T:Garnet.server.ArgSlice"/> to rewind</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.CreateArgSlice(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create an <see cref="T:Garnet.server.ArgSlice"/> from the given ReadOnlySpan
            </summary>
            <param name="bytes">Input bytes</param>
            <returns>Created <see cref="T:Garnet.server.ArgSlice"/></returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.CreateArgSlice(System.String)">
            <summary>
            Create an <see cref="T:Garnet.server.ArgSlice"/> in UTF8 format from the given string
            </summary>
            <param name="str">Input string</param>
            <returns>Created <see cref="T:Garnet.server.ArgSlice"/></returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferAllocator.CreateArgSlice(System.Int32)">
            <summary>
            Create an <see cref="T:Garnet.server.ArgSlice"/> of specified length, leaves contents as is
            </summary>
            <param name="length">Length of slice</param>
            <returns>Created <see cref="T:Garnet.server.ArgSlice"/></returns>
        </member>
        <member name="T:Garnet.server.ScratchBufferBuilder">
             <summary>
             <see cref="T:Garnet.server.ScratchBufferBuilder"/> is responsible for building a single buffer containing data
             supplied by sequential calls to CreateArgSlice.
             Whenever the current buffer runs out of space, a new buffer is allocated and the previous buffer's data is the copied over.
             The previous allocated buffers are then potentially GCed so any <see cref="T:Garnet.server.ArgSlice"/>s returned prior to any calls to
             CreateArgSlice may be pointing to non-allocated space.
            
             The builder is meant to be called from a single-threaded context (i.e. one builder per session).
             Each call to CreateArgSlice will copy the data to the current or new buffer that could contain the data in its entirety,
             so rewinding the <see cref="T:Garnet.server.ArgSlice"/> (i.e. releasing the memory) should be called in reverse order to assignment.
             
             Note: Use <see cref="T:Garnet.server.ScratchBufferAllocator"/> if you do not need all data to remain in a continuous chunk of memory
             and you do not want previously returned <see cref="T:Garnet.server.ArgSlice"/> structs to potentially point to non-allocated memory.
             </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferBuilder.scratchBuffer">
            <summary>
            Session-local scratch buffer to hold temporary arguments in transactions and GarnetApi
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferBuilder.scratchBufferHead">
            <summary>
            Pointer to head of scratch buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferBuilder.scratchBufferOffset">
            <summary>
            Current offset in scratch buffer
            </summary>
        </member>
        <member name="P:Garnet.server.ScratchBufferBuilder.ScratchBufferOffset">
            <summary>Current offset in scratch buffer</summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.Reset">
            <summary>
            Reset scratch buffer - loses all ArgSlice instances created on the scratch buffer
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.FullBuffer">
            <summary>
            Return the full buffer managed by this <see cref="T:Garnet.server.ScratchBufferBuilder"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.RewindScratchBuffer(Garnet.server.ArgSlice@)">
            <summary>
            Rewind (pop) the last entry of scratch buffer (rewinding the current scratch buffer offset),
            if it contains the given ArgSlice
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.ResetScratchBuffer(System.Int32)">
            <summary>
            Resets scratch buffer offset to the specified offset.
            </summary>
            <param name="offset">Offset to reset to</param>
            <returns>True if successful, else false</returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.CreateArgSlice(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create ArgSlice in scratch buffer, from given ReadOnlySpan
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.MoveOffset(System.Int32)">
            <summary>
            Shift the scratch buffer offset
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.CreateArgSlice(System.String)">
            <summary>
            Create ArgSlice in UTF8 format in scratch buffer, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.FormatScratchAsResp(System.Int32,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Create an ArgSlice that includes a header of specified size, followed by RESP Bulk-String formatted versions of the specified ArgSlice values (arg1 and arg2)
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.FormatScratchAsResp(System.Int32,Garnet.server.ArgSlice)">
            <summary>
            Create an ArgSlice that includes a header of specified size, followed by RESP Bulk-String formatted versions of the specified ArgSlice value arg1
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.FormatScratch(System.Int32,Garnet.server.ArgSlice)">
            <summary>
            Create an ArgSlice that includes a header of specified size, followed by the specified ArgSlice (arg)
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.CreateArgSlice(System.Int32)">
            <summary>
            Create an ArgSlice of specified length, leaves contents as is
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.ViewRemainingArgSlice(System.Int32)">
            <summary>
            View remaining scratch space (of specified minimum length) as an ArgSlice
            Does NOT move the offset forward
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.FormatScratch(System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>
            Create an ArgSlice that includes a header of specified size, followed by the specified Memory
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.StartCommand(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Start a RESP array to hold a command and arguments.
            
            Fill it with <paramref name="argCount"/> calls to <see cref="M:Garnet.server.ScratchBufferBuilder.WriteNullArgument"/> and/or <see cref="M:Garnet.server.ScratchBufferBuilder.WriteArgument(System.ReadOnlySpan{System.Byte})"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.WriteNullArgument">
            <summary>
            Use to fill a RESP array with arguments after a call to <see cref="M:Garnet.server.ScratchBufferBuilder.StartCommand(System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.WriteArgument(System.ReadOnlySpan{System.Byte})">
            <summary>
            Use to fill a RESP array with arguments after a call to <see cref="M:Garnet.server.ScratchBufferBuilder.StartCommand(System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.GetRespFormattedStringLength(Garnet.server.ArgSlice)">
            <summary>
            Get length of a RESP Bulk-String formatted version of the specified ArgSlice
            RESP format: $[size]\r\n[value]\r\n
            Total size: 1 + [number of digits in the size value] + 2 + [size of value] + 2
            </summary>
            <param name="slice"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.GetSliceFromTail(System.Int32)">
            <summary>
            Returns a new <see cref="T:Garnet.server.ArgSlice"/>
            with the <paramref name="length"/> bytes of the buffer;
            these are the most recently added bytes.
            </summary>
            <param name="length">Length for the new slice</param>
            <remarks>This is called by functions that add multiple items to the buffer,
            after all items have been added and all reallocations have been done.
            </remarks>
        </member>
        <member name="M:Garnet.server.ScratchBufferBuilder.GrowBuffer(System.Nullable{System.Int32})">
            <summary>
            Force backing buffer to grow.
            
            <paramref name="copyLengthOverride"/> provides a way to force a chunk at the start of the
            previous buffer be copied into the new buffer, even if this <see cref="T:Garnet.server.ScratchBufferBuilder"/>
            doesn't consider that chunk in use.
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Aad.IssuerSigningTokenProvider">
            <summary>
            Provides signing tokens from AAD authority for token validation purposes.
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.Aad.IssuerSigningTokenProvider.SigningTokens">
            <summary>
            The issuer signing keys
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Aad.IssuerSigningTokenProvider.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing">Flag to run disposal logic</param>
        </member>
        <member name="M:Garnet.server.Auth.Aad.IssuerSigningTokenProvider.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Aad.IssuerSigningTokenProvider.Create(System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Creates an instance of IssuerSigningTokenProvider.
            </summary>
            <param name="authority">The AAD authority</param>
            <param name="logger">The logger</param>
        </member>
        <member name="M:Garnet.server.Auth.GarnetAadAuthenticator.IsUserNameAuthorized(System.Collections.Generic.IDictionary{System.String,System.String},System.ReadOnlySpan{System.Byte})">
            <summary>
            Validates the username for OID or Group claim. A given token issued to client object maybe part of a
            AAD Group or an ObjectID incase of Application. We validate for OID first and then all groups.
            </summary>
            <param name="claims"> token claims mapping </param>
            <param name="userName"> input username </param>
        </member>
        <member name="F:Garnet.server.Auth.GarnetACLAuthenticator._acl">
            <summary>
            The Access Control List to authenticate users against
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.GarnetACLAuthenticator._logger">
            <summary>
            Logger to use to output log messages to
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.GarnetACLAuthenticator._userHandle">
            <summary>
            If authenticated, contains a reference to the authenticated user. Otherwise null.
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.GarnetACLAuthenticator.#ctor(Garnet.server.ACL.AccessControlList,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Initializes a new ACLAuthenticator instance.
            </summary>
            <param name="accessControlList">Access control list to authenticate against</param>
            <param name="logger">The logger to use</param>
        </member>
        <member name="P:Garnet.server.Auth.GarnetACLAuthenticator.CanAuthenticate">
            <summary>
            Indicates that this user can authenticate with passed credentials.
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.GarnetACLAuthenticator.IsAuthenticated">
            <summary>
            Check if the user is authorized to execute commands.
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.GarnetACLAuthenticator.HasACLSupport">
            <summary>
            ACL authenticator is can use ACL.
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.GarnetACLAuthenticator.Authenticate(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Authenticate the given user/password combination.
            </summary>
            <param name="password">Password to authenticate with.</param>
            <param name="username">Username to authenticate with. If empty, will authenticate default user.</param>
            <returns>true if authentication was successful</returns>
        </member>
        <member name="M:Garnet.server.Auth.GarnetACLAuthenticator.GetUserHandle">
            <summary>
            Returns the <see cref="T:Garnet.server.ACL.UserHandle"/> of the currently authorized user.
            </summary>
            <returns>Authorized user's <see cref="T:Garnet.server.ACL.UserHandle"/> or null if not authorized</returns>
        </member>
        <member name="M:Garnet.server.Auth.GarnetACLAuthenticator.GetAccessControlList">
            <summary>
            Return a reference to the access control list used by the authenticator.
            
            XXX: There should only be one AccessControlList for the whole server. Make ACL singleton.
            </summary>
            <returns>The access control list used by this authenticator</returns>
        </member>
        <member name="F:Garnet.server.Auth.GarnetAclWithAadAuthenticator._garnetAuthenticator">
            <summary>
            Authenticator to validate username and password.
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.GarnetAclWithAadAuthenticator.AuthenticateInternal(Garnet.server.ACL.UserHandle,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Authenticate the given user/password combination.
            </summary>
            <param name="userHandle"> User details to use for authentication.</param>
            <param name="password">Password to authenticate with.</param>
            <param name="username">Username to authenticate with. If empty, will authenticate default user.</param>
            <returns>true if authentication was successful</returns>
        </member>
        <member name="M:Garnet.server.Auth.GarnetAclWithPasswordAuthenticator.AuthenticateInternal(Garnet.server.ACL.UserHandle,System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Authenticate the given user/password combination.
            </summary>
            <param name="userHandle"> User details to use for authentication.</param>
            <param name="password">Password to authenticate with.</param>
            <param name="username">Username to authenticate with. If empty, will authenticate default user.</param>
            <returns>true if authentication was successful</returns>
        </member>
        <member name="T:Garnet.server.Auth.GarnetPasswordAuthenticator">
            <summary>
            Authenticator that uses a single fixed password.
            XXX: Deprecated. Should be replaced by ACL authenticator.
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.IGarnetAuthenticator">
            <summary>
            Garnet authenticator interface
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.IGarnetAuthenticator.IsAuthenticated">
            <summary>
            Is current caller authenticated
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.IGarnetAuthenticator.CanAuthenticate">
            <summary>
            Can authenticator authenticate
            </summary>
        </member>
        <member name="P:Garnet.server.Auth.IGarnetAuthenticator.HasACLSupport">
            <summary>
            Whether this authenticator can be used with the ACL
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.IGarnetAuthenticator.Authenticate(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Authenticate the incoming username and password from AUTH command. Username is optional
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.AadAuthenticationSettings">
            <summary>
            AAD auth settings
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AadAuthenticationSettings.#ctor(System.String[],System.String[],System.String[],Garnet.server.Auth.Aad.IssuerSigningTokenProvider,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="authorizedAppIds">Allowed app Ids</param>
            <param name="audiences">Allowed audiences</param>
            <param name="issuers">Allowed issuers</param>
            <param name="signingTokenProvider">Signing token provider</param>
            <param name="validateUsername"> whether to validate username or not. </param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AadAuthenticationSettings.CreateAuthenticator(Garnet.server.StoreWrapper)">
            <summary>
            Creates an AAD auth authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AadAuthenticationSettings.Dispose(System.Boolean)">
            <summary>
            Dispose impl
            </summary>
            <param name="disposing">Flag to run disposal logic</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AadAuthenticationSettings.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.AclAuthenticationAadSettings">
            <summary>
            ACL authentication with AAD settings
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationAadSettings.#ctor(System.String,System.String,Garnet.server.Auth.Settings.AadAuthenticationSettings)">
            <summary>
            Creates and initializes new ACL authentication settings
            </summary>
            <param name="aclConfigurationFile">Location of the ACL configuration file</param>
            <param name="defaultPassword">Optional default password, if not defined through aclConfigurationFile</param>
            <param name="aadAuthenticationSettings"> AAD settings used for authentication </param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationAadSettings.CreateAuthenticatorInternal(Garnet.server.StoreWrapper)">
            <summary>
            Creates an ACL authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="T:Garnet.server.Auth.Settings.AclAuthenticationPasswordSettings">
            <summary>
            ACL authentication with AAD settings.
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationPasswordSettings.#ctor(System.String,System.String)">
            <summary>
            Creates and initializes new ACL authentication settings
            </summary>
            <param name="aclConfigurationFile">Location of the ACL configuration file</param>
            <param name="defaultPassword">Optional default password, if not defined through aclConfigurationFile</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationPasswordSettings.CreateAuthenticatorInternal(Garnet.server.StoreWrapper)">
            <summary>
            Creates an ACL authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="T:Garnet.server.Auth.Settings.AclAuthenticationSettings">
            <summary>
            ACL authentication settings
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.AclAuthenticationSettings.AclConfigurationFile">
            <summary>
            Location of a the ACL configuration file to load users from
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.AclAuthenticationSettings.DefaultPassword">
            <summary>
            Default user password, in case aclConfiguration file is undefined or does not specify default password
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationSettings.#ctor(System.String,System.String)">
            <summary>
            Creates and initializes new ACL authentication settings
            </summary>
            <param name="aclConfigurationFile">Location of the ACL configuration file</param>
            <param name="defaultPassword">Optional default password, if not defined through aclConfigurationFile</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationSettings.CreateAuthenticator(Garnet.server.StoreWrapper)">
            <summary>
            Creates an ACL authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationSettings.CreateAuthenticatorInternal(Garnet.server.StoreWrapper)">
            <summary>
            Creates the internal implementation specific ACL authenticator.
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with. </param>
            <returns> IGarnetAuthenticator instance </returns>
        </member>
        <member name="M:Garnet.server.Auth.Settings.AclAuthenticationSettings.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.GarnetAuthenticationMode">
            <summary>
            Authentication mode
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.GarnetAuthenticationMode.NoAuth">
            <summary>
            No auth - Garnet accepts any and all connections
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.GarnetAuthenticationMode.Password">
            <summary>
            Password - Garnet accepts connections with correct connection string
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.GarnetAuthenticationMode.Aad">
            <summary>
            AAD - Garnet accepts connection with correct AAD principal
            In AAD mode, token may expire. Clients are expected to periodically refresh token with Garnet by running AUTH command.
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.GarnetAuthenticationMode.ACL">
            <summary>
            ACL - Garnet validates new connections and commands against configured ACL users and access rules.
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.GarnetAuthenticationMode.AclWithAad">
            <summary>
            ACL mode using Aad token instead of password. Here username is expected to be ObjectId or a valid Group's Object Id and token will be validated for claims.
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.IAuthenticationSettings">
            <summary>
            Authentication settings
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.IAuthenticationSettings.CreateAuthenticator(Garnet.server.StoreWrapper)">
            <summary>
            Create an authenticator using the current settings.
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="T:Garnet.server.Auth.Settings.ConnectionProtectionOption">
            <summary>
            Certain commands can be set at configuration to be limited to a particular connection type.
            They can be blocked for all connections, allowed only for local connections or be allowed for all connections.
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.ConnectionProtectionOption.No">
            <summary>
            Block for all connections.
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.ConnectionProtectionOption.Local">
            <summary>
             Allow only for local connections.
            </summary>
        </member>
        <member name="F:Garnet.server.Auth.Settings.ConnectionProtectionOption.Yes">
            <summary>
            Allow for every connection including remote connections.
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.NoAuthSettings">
            <summary>
            No auth settings
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.NoAuthSettings.CreateAuthenticator(Garnet.server.StoreWrapper)">
            <summary>
            Creates a no auth authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.NoAuthSettings.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Garnet.server.Auth.Settings.PasswordAuthenticationSettings">
            <summary>
            Password auth settings
            </summary>
        </member>
        <member name="M:Garnet.server.Auth.Settings.PasswordAuthenticationSettings.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="pwd">The password</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.PasswordAuthenticationSettings.CreateAuthenticator(Garnet.server.StoreWrapper)">
            <summary>
            Creates a password auth authenticator
            </summary>
            <param name="storeWrapper">The main store the authenticator will be associated with.</param>
        </member>
        <member name="M:Garnet.server.Auth.Settings.PasswordAuthenticationSettings.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Garnet.server.ByteArrayWrapper">
            <summary>
            Specialized key type for storing byte arrays (pinned and unpinned).
            </summary>
        </member>
        <member name="M:Garnet.server.ByteArrayWrapper.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.ByteArrayWrapperComparer">
            <summary>
            Byte array equality comparer
            </summary>
        </member>
        <member name="F:Garnet.server.ByteArrayWrapperComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Garnet.server.ByteArrayWrapperComparer.Equals(Garnet.server.ByteArrayWrapper,Garnet.server.ByteArrayWrapper)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ByteArrayWrapperComparer.GetHashCode(Garnet.server.ByteArrayWrapper)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.ClientType">
            <summary>
            Type option for CLIENT|LIST and CLIENT|KILL commands.
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.Invalid">
            <summary>
            Default invalid case.
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.NORMAL">
            <summary>
            Normal client connections, including MONITOR parked connections.
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.MASTER">
            <summary>
            Connection from a MASTER cluster node to current node.
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.REPLICA">
            <summary>
            Connection from a REPLICA cluster node to current node.
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.PUBSUB">
            <summary>
            Connection which is dedicated to listening for PUBLISH data (Resp2 only).
            </summary>
        </member>
        <member name="F:Garnet.server.ClientType.SLAVE">
            <summary>
            Equivalent to <see cref="F:Garnet.server.ClientType.REPLICA"/>.
            
            Separate value as SLAVE is not permitted on new commands, but is still supported
            for older commands.
            </summary>
        </member>
        <member name="M:Garnet.server.CheckpointMetadata.ToString">
            <summary>
            ToString implementation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ClusterPreferredEndpointType">
            <summary>
            Use IP address for cluster redirection(MOVED/ASK) messages
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterPreferredEndpointType.Ip">
            <summary>
            ex -MOVED 12182 127.0.0.1:7000
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterPreferredEndpointType.Hostname">
            <summary>
            ex -MOVED 12182 localhost:7000
            if hostname is not exist
            ex -MOVED 12182 ?:7000
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterPreferredEndpointType.Unknown">
            <summary>
            ex -MOVED 12182 ?:7000
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.readOnly">
            <summary>
            Whether this is a read only command
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.sessionAsking">
            <summary>
            Whether ASKING is enabled for this command
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.firstKey">
            <summary>
            Offset of first key in the ArgSlice buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.lastKey">
            <summary>
            Offset of the last key in the ArgSlice buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.step">
            <summary>
            The step, or increment, between the first key and the position of the next key
            </summary>
        </member>
        <member name="F:Garnet.server.ClusterSlotVerificationInput.keyNumOffset">
            <summary>
            Offset of key num if any
            </summary>
        </member>
        <member name="T:Garnet.server.IClusterFactory">
            <summary>
            Cluster factory
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterFactory.CreateCheckpointManager(Tsavorite.core.INamedDeviceFactoryCreator,Tsavorite.core.ICheckpointNamingScheme,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create checkpoint manager
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterFactory.CreateClusterProvider(Garnet.server.StoreWrapper)">
            <summary>
            Create cluster provider
            </summary>
        </member>
        <member name="T:Garnet.server.IClusterProvider">
            <summary>
            Cluster provider
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.CreateClusterSession(Garnet.server.TransactionManager,Garnet.server.Auth.IGarnetAuthenticator,Garnet.server.ACL.UserHandle,Garnet.server.GarnetSessionMetrics,Garnet.server.GarnetApi{Tsavorite.core.BasicContext{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,Garnet.server.RawStringInput,Tsavorite.core.SpanByteAndMemory,System.Int64,Garnet.server.MainSessionFunctions,Tsavorite.core.StoreFunctions{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,Tsavorite.core.SpanByteComparer,Tsavorite.core.SpanByteRecordDisposer},Tsavorite.core.SpanByteAllocator{Tsavorite.core.StoreFunctions{Tsavorite.core.SpanByte,Tsavorite.core.SpanByte,Tsavorite.core.SpanByteComparer,Tsavorite.core.SpanByteRecordDisposer}}},Tsavorite.core.BasicContext{System.Byte[],Garnet.server.IGarnetObject,Garnet.server.ObjectInput,Garnet.server.GarnetObjectStoreOutput,System.Int64,Garnet.server.ObjectSessionFunctions,Tsavorite.core.StoreFunctions{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.ByteArrayKeyComparer,Tsavorite.core.DefaultRecordDisposer{System.Byte[],Garnet.server.IGarnetObject}},Tsavorite.core.GenericAllocator{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.StoreFunctions{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.ByteArrayKeyComparer,Tsavorite.core.DefaultRecordDisposer{System.Byte[],Garnet.server.IGarnetObject}}}}},Garnet.networking.INetworkSender,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create cluster session
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterProvider.AllowDataLoss">
            <summary>
            Are we allowed to incur AOF data loss: { using null AOF device } OR { main memory replication AND no on-demand checkpoints }
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.FlushConfig">
            <summary>
            Flush config
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetGossipStats(System.Boolean)">
            <summary>
            Get gossip stats
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetReplicationInfo">
            <summary>
            Get replication info
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetBufferPoolStats">
            <summary>
            Get buffer poolt stats
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetPrimaryInfo">
            <summary>
            Get info on primary from replica perspective.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetReplicaInfo">
            <summary>
            Get info on replicas from primary perspective.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.PurgeBufferPool(Garnet.server.ManagerType)">
            <summary>
            Purger buffer pool for provided manager
            </summary>
            <param name="managerType"></param>
        </member>
        <member name="M:Garnet.server.IClusterProvider.ExtractKeySpecs(Garnet.server.RespCommandsInfo,Garnet.server.RespCommand,Garnet.server.SessionParseState@,Garnet.server.ClusterSlotVerificationInput@)">
            <summary>
            Extract key specs
            </summary>
            <param name="commandInfo"></param>
            <param name="cmd"></param>
            <param name="csvi"></param>
        </member>
        <member name="M:Garnet.server.IClusterProvider.ClusterPublish(Garnet.server.RespCommand,System.Span{System.Byte}@,System.Span{System.Byte}@)">
            <summary>
            Issue a cluster publish message to remote nodes
            </summary>
            <param name="cmd"></param>
            <param name="channel"></param>
            <param name="message"></param>
        </member>
        <member name="M:Garnet.server.IClusterProvider.IsPrimary">
            <summary>
            Is Primary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.IsReplica">
            <summary>
            Is replica
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.IsReplica(System.String)">
            <summary>
            Returns true if the given nodeId is a replica, according to the current cluster configuration.
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.OnCheckpointInitiated(System.Int64@)">
            <summary>
            On checkpoint initiated
            </summary>
            <param name="CheckpointCoveredAofAddress"></param>
        </member>
        <member name="M:Garnet.server.IClusterProvider.Recover">
            <summary>
            Recover the cluster
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.ResetGossipStats">
            <summary>
            Reset gossip stats
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.SafeTruncateAOF(System.Boolean,System.Int64,System.Guid,System.Guid)">
            <summary>
            Safe truncate AOF
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.SafeTruncateAOF(System.Int64)">
            <summary>
            Safe truncate AOF until address
            </summary>
            <param name="truncateUntil"></param>
        </member>
        <member name="M:Garnet.server.IClusterProvider.Start">
            <summary>
            Start cluster operations
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.UpdateClusterAuth(System.String,System.String)">
            <summary>
            Update cluster auth (atomically)
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetCheckpointInfo">
            <summary>
            Get checkpoint info
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.GetRunId">
            <summary>
            RunID to identify checkpoint history
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterProvider.PreventRoleChange">
            <summary>
            Call to prevent this node from changing its current role.
            
            If this returns true, must be followed by a single call to 
            <see cref="M:Garnet.server.IClusterProvider.AllowRoleChange"/>
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterProvider.AllowRoleChange">
            <summary>
            After a successful call to <see cref="M:Garnet.server.IClusterProvider.PreventRoleChange"/>, 
            allows the node to change roles again.
            </summary>
        </member>
        <member name="T:Garnet.server.IClusterSession">
            <summary>
            Cluster RESP session
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterSession.RemoteNodeId">
            <summary>
            If the current session is being used by a remote cluster node, the id that was last presented during a GOSSIP message.
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterSession.ReadWriteSession">
            <summary>
            Type of session
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterSession.IsReplicating">
            <summary>
            If the current session has seen an APPENDLOG command.
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterSession.Server">
             <summary>
             If set, commands can use this to enumerate details about the server or other sessions.
            
             It is not guaranteed to be set.
             </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.SetReadOnlySession">
            <summary>
            Make this cluster session a read-only session
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.SetReadWriteSession">
            <summary>
            Make this cluster session a read-write session
            </summary>
        </member>
        <member name="P:Garnet.server.IClusterSession.LocalCurrentEpoch">
            <summary>
            Local current epoch
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.AcquireCurrentEpoch">
            <summary>
            Acquire epoch
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.ReleaseCurrentEpoch">
            <summary>
            Release epoch
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.ProcessClusterCommands(Garnet.server.RespCommand,Garnet.server.SessionParseState@,System.Byte*@,System.Byte*@)">
            <summary>
            Process cluster commands
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.ResetCachedSlotVerificationResult">
            <summary>
            Reset cached slot verification result
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.NetworkIterativeSlotVerify(Garnet.server.ArgSlice,System.Boolean,System.Byte)">
            <summary>
            Verification method that works iteratively by caching the verification result between calls.
            NOTE: Caller must call ResetCachedSlotVerificationResult appropriately
            </summary>
            <param name="keySlice"></param>
            <param name="readOnly"></param>
            <param name="SessionAsking"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterSession.WriteCachedSlotVerificationMessage(Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Write cached slot verification message to output
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Garnet.server.IClusterSession.NetworkKeyArraySlotVerify(System.Span{Garnet.server.ArgSlice},System.Boolean,System.Byte,System.Byte*@,System.Byte*@,System.Int32)">
            <summary>
            Key array slot verify (write result to network)
            </summary>
        </member>
        <member name="M:Garnet.server.IClusterSession.NetworkMultiKeySlotVerify(Garnet.server.SessionParseState@,Garnet.server.ClusterSlotVerificationInput@,System.Byte*@,System.Byte*@)">
            <summary>
            Array slot verify (write result to network)
            </summary>
            <param name="parseState"></param>
            <param name="csvi"></param>
            <param name="dcurr"></param>
            <param name="dend"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterSession.NetworkMultiKeySlotVerifyNoResponse(Garnet.server.SessionParseState@,Garnet.server.ClusterSlotVerificationInput@,System.Byte*@,System.Byte*@)">
            <summary>
            Array slot verify with no response
            </summary>
            <param name="parseState"></param>
            <param name="csvi"></param>
            <param name="dcurr"></param>
            <param name="dend"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IClusterSession.SetUserHandle(Garnet.server.ACL.UserHandle)">
            <summary>
            Sets the <see cref="T:Garnet.server.ACL.UserHandle"/> currently authenticated in this session (used for permission checks)
            </summary>
        </member>
        <member name="F:Garnet.server.RoleInfo.replication_offset">
            <summary>
            Replication offset using string store.
            </summary>
        </member>
        <member name="F:Garnet.server.RoleInfo.replication_lag">
            <summary>
            Replication offset lag. 
            </summary>
        </member>
        <member name="F:Garnet.server.RoleInfo.replication_state">
            <summary>
            Replication state.
            ROLE command uses "connect", "connecting", "sync" and "connected".
            Metrics use "online" and "offline". 
            </summary>
        </member>
        <member name="F:Garnet.server.RoleInfo.address">
            <summary>
            Address of instance. 
            </summary>
        </member>
        <member name="F:Garnet.server.RoleInfo.port">
            <summary>
            Port of instance.
            </summary>
        </member>
        <member name="M:Garnet.server.RoleInfo.ToString">
            <summary>
            Printout for Metrics.
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Garnet.server.StoreType">
            <summary>
            Store type to operate on. Garnet keeps data in two stores, main store
            for raw strings and object store for data structures such as sorted set, 
            hash, list.
            </summary>
        </member>
        <member name="F:Garnet.server.StoreType.None">
            <summary>
            No store specified
            </summary>
        </member>
        <member name="F:Garnet.server.StoreType.Main">
            <summary>
            Main (raw string) store
            </summary>
        </member>
        <member name="F:Garnet.server.StoreType.Object">
            <summary>
            Object store
            </summary>
        </member>
        <member name="F:Garnet.server.StoreType.All">
            <summary>
            All stores
            </summary>
        </member>
        <member name="T:Garnet.server.CommandType">
            <summary>
            Type of custom command
            </summary>
        </member>
        <member name="F:Garnet.server.CommandType.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:Garnet.server.CommandType.ReadModifyWrite">
            <summary>
            Read-modify-write
            </summary>
        </member>
        <member name="T:Garnet.server.CustomCommandManager">
            <summary>
            Custom command manager
            </summary>
        </member>
        <member name="F:Garnet.server.CustomCommandManager.CustomTypeIdStartOffset">
            <summary>
            Offset from which custom type IDs start in the GarnetObjectType enum
            </summary>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.#ctor">
            <summary>
            Create new custom command manager
            </summary>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Register(System.String,Garnet.server.CommandType,Garnet.server.CustomRawStringFunctions,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs,System.Int64)">
            <summary>
            Register custom raw-string command
            </summary>
            <param name="name">Name of command</param>
            <param name="type">Command type</param>
            <param name="customFunctions">Custom raw-string functions</param>
            <param name="commandInfo">Command info of command</param>
            <param name="commandDocs">Command docs of command</param>
            <param name="expirationTicks">Command expiration in ticks</param>
            <returns>Command ID</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Register(System.String,System.Func{Garnet.server.CustomTransactionProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Register custom transaction
            </summary>
            <param name="name">Name of transaction</param>
            <param name="proc">Delegate for creating transaction</param>
            <param name="commandInfo">Command info of transaction</param>
            <param name="commandDocs">Command docs of transaction</param>
            <returns>Command ID</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.RegisterType(Garnet.server.CustomObjectFactory)">
            <summary>
            Register custom object type
            </summary>
            <param name="factory">Factory for creating custom object</param>
            <returns>Type ID</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Register(System.String,Garnet.server.CommandType,Garnet.server.CustomObjectFactory,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs,Garnet.server.CustomObjectFunctions)">
            <summary>
            Register custom object command
            </summary>
            <param name="name">Name of command</param>
            <param name="commandType">Command type</param>
            <param name="factory">Factory for creating custom object</param>
            <param name="commandInfo">Command info for custom command</param>
            <param name="commandDocs">Command docs for custom command</param>
            <param name="customObjectFunctions">Custom object functions</param>
            <returns>Object type ID and sub-command ID</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Register(System.String,System.Func{Garnet.server.CustomProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Register custom procedure
            </summary>
            <param name="name">Name of custom procedure</param>
            <param name="customProcedure">Delegate for creating custom procedure</param>
            <param name="commandInfo">Command info of custom procedure</param>
            <param name="commandDocs">Command docs of custom procedure</param>
            <returns>Command ID</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.RegisterModule(Garnet.server.ModuleBase,System.String[],Microsoft.Extensions.Logging.ILogger,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Register module
            </summary>
            <param name="module">Module to register</param>
            <param name="moduleArgs">Module arguments</param>
            <param name="logger">Logger</param>
            <param name="errorMessage">Error message</param>
            <returns>True if module registered successfully</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryAddModule(Garnet.server.ModuleLoadContext)">
            <summary>
            Try to add a module to the modules map (should only be called by ModuleRegistrar)
            </summary>
            <param name="moduleLoadContext">Module load context</param>
            <returns>True if module was added successfully (i.e. its name doesn't already exist)</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomProcedure(System.Int32,Garnet.server.CustomProcedureWrapper@)">
            <summary>
            Try to retrieve a custom procedure wrapper by procedure ID (should only be called by CustomCommandManagerSession)
            </summary>
            <param name="id">Procedure ID</param>
            <param name="value">Retrieved custom procedure</param>
            <returns>True if custom procedure found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomTransactionProcedure(System.Int32,Garnet.server.CustomTransaction@)">
            <summary>
            Try to retrieve a custom transaction by transaction ID (should only be called by CustomCommandManagerSession)
            </summary>
            <param name="id">Transaction ID</param>
            <param name="value">Retrieved custom transaction</param>
            <returns>True if custom transaction found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomCommand(System.Int32,Garnet.server.CustomRawStringCommand@)">
            <summary>
            Try to retrieve a custom raw string command by command ID
            </summary>
            <param name="id">Command ID</param>
            <param name="value">Retrieved command</param>
            <returns>True if command found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomObjectCommand(System.Int32,Garnet.server.CustomObjectCommandWrapper@)">
            <summary>
            Try to retrieve a custom object command by command ID
            </summary>
            <param name="id">Command ID</param>
            <param name="value">Retrieved command</param>
            <returns>True if command found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomObjectSubCommand(System.Int32,System.Int32,Garnet.server.CustomObjectCommand@)">
            <summary>
            Try to retrieve a custom object sub-command command by command ID and sub-command ID
            </summary>
            <param name="id">Command ID</param>
            <param name="subId">Sub-command ID</param>
            <param name="value">Retrieved command</param>
            <returns>True if command found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomRawStringCommand@)">
            <summary>
            Get a custom raw-string command by name
            </summary>
            <param name="command">The command name to match</param>
            <param name="cmd">The matching command</param>
            <returns>True if command name matched an existing command</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomTransaction@)">
            <summary>
            Get a custom transaction by name
            </summary>
            <param name="command">The transaction name to match</param>
            <param name="cmd">The matching transaction</param>
            <returns>True if transaction name matched an existing transaction</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomObjectCommand@)">
            <summary>
            Get a custom object command by name
            </summary>
            <param name="command">The command name to match</param>
            <param name="cmd">The matching command</param>
            <returns>True if command name matched an existing command</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomProcedureWrapper@)">
            <summary>
            Get a custom procedure by name
            </summary>
            <param name="command">The procedure name to match</param>
            <param name="cmd">The matching procedure</param>
            <returns>True if procedure name matched an existing procedure</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomCommandInfo(System.String,Garnet.server.RespCommandsInfo@)">
            <summary>
            Get custom command info by name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsInfo">The matching command info</param>
            <returns>True if command info was found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.TryGetCustomCommandDocs(System.String,Garnet.server.RespCommandDocs@)">
            <summary>
            Get custom command docs by name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsDocs">The matching command docs</param>
            <returns>True if command docs was found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.GetAllCustomCommandsInfos">
            <summary>
            Get all custom command infos
            </summary>
            <returns>Map between custom command name and custom command info</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.GetAllCustomCommandsDocs">
            <summary>
            Get all custom command docs
            </summary>
            <returns>Map between custom command name and custom command docs</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.GetCustomCommandInfoCount">
            <summary>
            Get count of all custom command infos
            </summary>
            <returns>Count</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.GetCustomRespCommand(System.Int32)">
            <summary>
            Get RespCommand enum by command ID
            </summary>
            <param name="id">Command ID</param>
            <returns>Matching RespCommand</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManager.GetCustomGarnetObjectType(System.Int32)">
            <summary>
            Get GarnetObjectType enum by object type ID
            </summary>
            <param name="id">Object type ID</param>
            <returns>Matching GarnetObjectType</returns>
        </member>
        <member name="T:Garnet.server.CustomCommandManagerSession">
            <summary>
            Session-specific access to custom command data held by CustomCommandManager
            For both custom procedures and custom transactions, this class maintains a cached instance of the transaction / procedure that can be called directly per-session
            This class also maintains a cache of custom command info and docs to avoid the cost of synchronization when calling CustomCommandManager
            </summary>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetCustomProcedure(System.Int32,Garnet.server.RespServerSession)">
            <summary>
            Get a custom procedure by ID
            </summary>
            <param name="id">The procedure ID</param>
            <param name="respServerSession">The current session</param>
            <returns>The per-session instance of the procedure</returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetCustomTransactionProcedure(System.Int32,Garnet.server.RespServerSession,Garnet.server.TransactionManager,Garnet.server.ScratchBufferAllocator,System.Int32@)">
            <summary>
            Get a custom transaction procedure by ID
            </summary>
            <param name="id">The transaction ID</param>
            <param name="respServerSession">The current session</param>
            <param name="txnManager">txnManager</param>
            <param name="scratchBufferAllocator">scratchBufferAllocator</param>
            <param name="arity">The arity of the transaction</param>
            <returns>The per-session instance of the transaction</returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomRawStringCommand@)">
            <summary>
            Get a custom raw-string command by name
            </summary>
            <param name="command">The command name to match</param>
            <param name="cmd">The matching command</param>
            <returns>True if command name matched an existing command</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomTransaction@)">
            <summary>
            Get a custom transaction by name
            </summary>
            <param name="command">The transaction name to match</param>
            <param name="cmd">The matching transaction</param>
            <returns>True if transaction name matched an existing transaction</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomObjectCommand@)">
            <summary>
            Get a custom object command by name
            </summary>
            <param name="command">The command name to match</param>
            <param name="cmd">The matching command</param>
            <returns>True if command name matched an existing command</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.Match(System.ReadOnlySpan{System.Byte},Garnet.server.CustomProcedureWrapper@)">
            <summary>
            Get a custom procedure by name
            </summary>
            <param name="command">The procedure name to match</param>
            <param name="cmd">The matching procedure</param>
            <returns>True if procedure name matched an existing procedure</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.TryGetCustomCommandInfo(System.String,Garnet.server.RespCommandsInfo@)">
            <summary>
            Get custom command info by name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsInfo">The matching command info</param>
            <returns>True if command info was found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.TryGetCustomCommandDocs(System.String,Garnet.server.RespCommandDocs@)">
            <summary>
            Get custom command docs by name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsDocs">The matching command docs</param>
            <returns>True if command docs was found</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetAllCustomCommandsInfos">
            <summary>
            Get all custom command infos
            </summary>
            <returns>Map between custom command name and custom command info</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetAllCustomCommandsDocs">
            <summary>
            Get all custom command docs
            </summary>
            <returns>Map between custom command name and custom command docs</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetCustomCommandInfoCount">
            <summary>
            Get count of all custom command infos
            </summary>
            <returns>Count</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetCustomRespCommand(System.Int32)">
            <summary>
            Get RespCommand enum by command ID
            </summary>
            <param name="id">Command ID</param>
            <returns>Matching RespCommand</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandManagerSession.GetCustomGarnetObjectType(System.Int32)">
            <summary>
            Get GarnetObjectType enum by object type ID
            </summary>
            <param name="id">Object type ID</param>
            <returns>Matching GarnetObjectType</returns>
        </member>
        <member name="T:Garnet.server.Custom.RegisterArgsBase">
            <summary>
            Base custom command / transaction registration arguments
            </summary>
        </member>
        <member name="P:Garnet.server.Custom.RegisterArgsBase.Name">
            <summary>
            Custom command / transaction name
            </summary>
        </member>
        <member name="P:Garnet.server.Custom.RegisterArgsBase.NumParams">
            <summary>
            Number of parameters required by custom command / transaction
            </summary>
        </member>
        <member name="P:Garnet.server.Custom.RegisterArgsBase.CommandInfo">
            <summary>
            RESP command info
            </summary>
        </member>
        <member name="P:Garnet.server.Custom.RegisterArgsBase.CommandDocs">
            <summary>
            RESP command docs
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCmdArgs">
            <summary>
            Custom command registration arguments
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterTxnArgs">
            <summary>
            Custom transaction registration arguments
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomCommandProviderFactory">
            <summary>
            Factory for registration providers
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.IRegisterCustomCommandProvider">
            <summary>
            Registration provider interface
            </summary>
        </member>
        <member name="M:Garnet.server.Custom.IRegisterCustomCommandProvider.Register(Garnet.server.CustomCommandManager)">
            <summary>
            Register custom command instance
            </summary>
            <param name="customCommandManager">CustomCommandManager used to register custom command instance</param>
        </member>
        <member name="F:Garnet.server.Custom.RegisterCustomCommandProviderBase.SupportedCustomCommandBaseTypesLazy">
            <summary>
            All supported custom command types 
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomCommandProviderBase`2">
            <summary>
            Base registration provider
            </summary>
            <typeparam name="T">Type of custom command / transaction</typeparam>
            <typeparam name="TArgs">Type of arguments required to register command / transaction</typeparam>
        </member>
        <member name="P:Garnet.server.Custom.RegisterCustomCommandProviderBase`2.RegisterArgs">
            <summary>
            Arguments required for command / transaction registration
            </summary>
        </member>
        <member name="P:Garnet.server.Custom.RegisterCustomCommandProviderBase`2.Instance">
            <summary>
            Instance of custom command class
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomCmdProvider`1">
            <summary>
            Base custom command registration provider
            </summary>
            <typeparam name="T">Type of custom command</typeparam>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomTxnProvider`1">
            <summary>
            Base custom transaction registration provider
            </summary>
            <typeparam name="T">Type of custom transaction</typeparam>
        </member>
        <member name="T:Garnet.server.Custom.RegisterRawStringFunctionProvider">
            <summary>
            RawStringFunction registration provider
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomObjectFactoryProvider">
            <summary>
            CustomObjectFactory registration provider
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomObjectCommandProvider">
            <summary>
            CustomObjectFactory registration provider
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.RegisterCustomTransactionProcedureProvider">
            <summary>
            TransactionProcedureProvider registration provider
            </summary>
        </member>
        <member name="T:Garnet.server.Custom.ObjectInputExtensions">
            <summary>
            Provides extension methods for handling object input.
            </summary>
        </member>
        <member name="M:Garnet.server.Custom.ObjectInputExtensions.TryGetExistOption(Garnet.server.ObjectInput@,System.Int32@,Garnet.server.ExistOptions@)">
            <summary>
            Tries to get the expire option from the input.
            </summary>
            <param name="input">The input object containing the command arguments.</param>
            <param name="offset">The current offset in the input arguments.</param>
            <param name="value">The parsed expire option if successful, otherwise <see cref="F:Garnet.server.ExistOptions.None"/>.</param>
            <returns>True if the expire option was successfully parsed, otherwise false.</returns>
        </member>
        <member name="T:Garnet.server.CustomCommandType">
            <summary>
            Type of custom command
            </summary>
        </member>
        <member name="F:Garnet.server.CustomCommandType.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:Garnet.server.CustomCommandType.ReadModifyWrite">
            <summary>
            Read-modify-write
            </summary>
        </member>
        <member name="M:Garnet.server.CustomCommandUtils.GetFirstArg(Garnet.server.ObjectInput@)">
            <summary>
            Get first arg from input
            </summary>
            <param name="input">Object store input</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.CustomCommandUtils.GetFirstArg(Garnet.server.RawStringInput@)">
            <summary>
            Get first arg from input
            </summary>
            <param name="input">Main store input</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.CustomCommandUtils.GetNextArg(Garnet.server.ObjectInput@,System.Int32@)">
            <summary>
            Get argument from input, at specified index (starting from 0)
            </summary>
            <param name="input">Object store input</param>
            <param name="idx">Current argument index in input</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomCommandUtils.GetNextArg(Garnet.server.RawStringInput@,System.Int32@)">
            <summary>
            Get argument from input, at specified index (starting from 0)
            </summary>
            <param name="input">Main store input</param>
            <param name="idx">Current argument index in input</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="T:Garnet.server.CustomObjectBase">
            <summary>
            Custom object abstract base class
            </summary>
        </member>
        <member name="F:Garnet.server.CustomObjectBase.type">
            <summary>
            Type of object
            </summary>
        </member>
        <member name="M:Garnet.server.CustomObjectBase.#ctor(System.Byte,System.Int64,System.Int64)">
            <summary>
            Base constructor
            </summary>
            <param name="type">Object type</param>
            <param name="size"></param>
        </member>
        <member name="M:Garnet.server.CustomObjectBase.#ctor(Garnet.server.CustomObjectBase)">
            <summary>
            Base copy constructor
            </summary>
            <param name="obj">Other object</param>
        </member>
        <member name="P:Garnet.server.CustomObjectBase.Type">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.CustomObjectBase.SerializeObject(System.IO.BinaryWriter)">
            <summary>
            Serialize to giver writer
            </summary>
        </member>
        <member name="M:Garnet.server.CustomObjectBase.CloneObject">
            <summary>
            Clone object (new instance of object shell)
            </summary>
        </member>
        <member name="M:Garnet.server.CustomObjectBase.Clone">
            <summary>
            Clone object (shallow copy)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.CustomObjectBase.DoSerialize(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.CustomObjectBase.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.CustomObjectBase.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.CustomObjectCommandWrapper">
            <summary>
            Custom object command wrapper
            </summary>
        </member>
        <member name="T:Garnet.server.CustomObjectFactory">
            <summary>
            Base class for creating custom objects
            </summary>
        </member>
        <member name="M:Garnet.server.CustomObjectFactory.Create(System.Byte)">
            <summary>
            Create new (empty) instance of custom object
            </summary>
        </member>
        <member name="M:Garnet.server.CustomObjectFactory.Deserialize(System.Byte,System.IO.BinaryReader)">
            <summary>
            Deserialize value object from given reader
            </summary>
            <param name="type"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.GetNextArg(Garnet.server.ObjectInput@,System.Int32@)">
            <summary>
            Get argument from input, at specified offset (starting from 0)
            </summary>
            <param name="input">Object Store input</param>
            <param name="offset">Current offset into input</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.GetNextString(Garnet.server.ObjectInput@,System.Int32@)">
            <summary>
            Get argument from input as string, at specified offset (starting from 0)
            </summary>
            <param name="input">Object Store input</param>
            <param name="offset">Current offset into input</param>
            <returns>Argument as a string</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.GetFirstArg(Garnet.server.ObjectInput@)">
            <summary>
            Get first arg from input
            </summary>
            <param name="input">Object Store input</param>
            <returns>First argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.NeedInitialUpdate(System.ReadOnlyMemory{System.Byte},Garnet.server.ObjectInput@,Garnet.common.RespMemoryWriter@)">
            <summary>
            Whether we need an initial update, given input, if item does not already exist in store
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="writer">Output</param>
            <returns>True if an initial update is needed, otherwise false</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.InitialUpdater(System.ReadOnlyMemory{System.Byte},Garnet.server.ObjectInput@,Garnet.server.IGarnetObject,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <summary>
            Create initial value, given key and input. Optionally generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="writer">Output</param>
            <param name="rmwInfo">Advanced arguments</param>
            <returns>True if done, false if we need to cancel the update</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.Updater(System.ReadOnlyMemory{System.Byte},Garnet.server.ObjectInput@,Garnet.server.IGarnetObject,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <summary>
            Update given value in place, given key and input. Optionally generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="writer">Output</param>
            <param name="rmwInfo">Advanced arguments</param>
            <returns>True if done, false if we have no space to update in place</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.Reader(System.ReadOnlyMemory{System.Byte},Garnet.server.ObjectInput@,Garnet.server.IGarnetObject,Garnet.common.RespMemoryWriter@,Tsavorite.core.ReadInfo@)">
            <summary>
            Read value, given key and input and generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="writer">Output</param>
            <param name="readInfo">Advanced arguments</param>
            <returns>True if done, false if not found</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.AbortWithWrongNumberOfArguments(Garnet.common.RespMemoryWriter@,System.String)">
            <summary>
            Aborts the execution of the current object store command and outputs
            an error message to indicate a wrong number of arguments for the given command.
            </summary>
            <param name="writer">The output buffer and its length.</param>
            <param name="cmdName">Name of the command that caused the error message.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.AbortWithErrorMessage(Garnet.common.RespMemoryWriter@,System.ReadOnlySpan{System.Byte})">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="writer">The output buffer and its length.</param>
            <param name="errorMessage">Error message to print to result stream.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.AbortWithErrorMessage(Garnet.common.RespMemoryWriter@,System.String)">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="writer">The output buffer and its length.</param>
            <param name="errorMessage">Error message to print to result stream.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.CustomObjectFunctions.AbortWithSyntaxError(Garnet.common.RespMemoryWriter@)">
            <summary>
            Aborts the execution of the current object store command and outputs a syntax error message.
            </summary>
            <param name="writer">The output buffer and its length.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="T:Garnet.server.CustomProcedureBase">
            <summary>
            Base class for custom procedures
            </summary>
        </member>
        <member name="P:Garnet.server.CustomProcedureBase.MemoryPool">
            <summary>
            Shared memory pool used by procedures
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteSimpleString(System.ValueTuple{System.Buffers.IMemoryOwner{System.Byte},System.Int32}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Create output as simple string, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteSimpleString(Garnet.common.MemoryResult{System.Byte}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Create output as simple string, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteBulkStringArray(Garnet.common.MemoryResult{System.Byte}@,Garnet.server.ArgSlice[])">
            <summary>
            Create output as an array of bulk strings, from given array of ArgSlice values
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteBulkStringArray(Garnet.common.MemoryResult{System.Byte}@,System.Collections.Generic.List{Garnet.server.ArgSlice})">
            <summary>
            Create output as an array of bulk strings, from given array of ArgSlice values
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteBulkString(Garnet.common.MemoryResult{System.Byte}@,System.Span{System.Byte})">
            <summary>
            Create output as bulk string, from given Span
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteBulkString(System.ValueTuple{System.Buffers.IMemoryOwner{System.Byte},System.Int32}@,System.Span{System.Byte})">
            <summary>
            Create output as bulk string, from given Span
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteNullBulkString(System.ValueTuple{System.Buffers.IMemoryOwner{System.Byte},System.Int32}@)">
            <summary>
            Create null output as bulk string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteError(System.ValueTuple{System.Buffers.IMemoryOwner{System.Byte},System.Int32}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Create output as error message, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.WriteError(Garnet.common.MemoryResult{System.Byte}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Create output as error message, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.GetNextArg(Garnet.server.SessionParseState@,System.Int32@)">
            <summary>
            Get argument from parse state, at specified index (starting from 0)
            </summary>
            <param name="parseState">Current parse state</param>
            <param name="idx">Current argument index in parse state</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.GetNextArg(Garnet.server.CustomProcedureInput@,System.Int32@)">
            <summary>
            Get argument from input, at specified index (starting from 0)
            </summary>
            <param name="procInput">Procedure input</param>
            <param name="idx">Current argument index in parse state</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.ParseCustomRawStringCommand(System.String,Garnet.server.CustomRawStringCommand@)">
            <summary>Parse custom raw string command</summary>
            <param name="cmd">Command name</param>
            <param name="rawStringCommand">Parsed raw string command</param>
            <returns>True if command found, false otherwise</returns>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.ParseCustomObjectCommand(System.String,Garnet.server.CustomObjectCommand@)">
            <summary>Parse custom object command</summary>
            <param name="cmd">Command name</param>
            <param name="objectCommand">Parsed object command</param>
            <returns>True if command found, false othrewise</returns>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.ExecuteCustomRawStringCommand``1(``0,Garnet.server.CustomRawStringCommand,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice@)">
            <summary>Execute a specific custom raw string command</summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="garnetApi"></param>
            <param name="rawStringCommand">Custom raw string command to execute</param>
            <param name="key">Key param</param>
            <param name="input">Args to the command</param>
            <param name="output">Output from the command</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.CustomProcedureBase.ExecuteCustomObjectCommand``1(``0,Garnet.server.CustomObjectCommand,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice@)">
            <summary>Execute a specific custom object command</summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="garnetApi"></param>
            <param name="objectCommand">Custom object command to execute</param>
            <param name="key">Key parameter</param>
            <param name="input">Args to the command</param>
            <param name="output">Output from the command</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Garnet.server.CustomProcedure">
            <summary>
            Base class for custom command
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedure.Execute``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Custom command implementation
            </summary>
            <param name="garnetApi"></param>
            <param name="procInput"></param>
            <param name="output"></param>
        </member>
        <member name="T:Garnet.server.CustomRawStringFunctions">
            <summary>
            Base class for custom functions on raw strings
            </summary>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.GetNextArg(Garnet.server.RawStringInput@,System.Int32@)">
            <summary>
            Get argument from input, at specified offset (starting from 0)
            </summary>
            <param name="input">Input as ReadOnlySpan of byte</param>
            <param name="offset">Current offset into input</param>
            <returns>Argument as a span</returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.GetFirstArg(Garnet.server.RawStringInput@)">
            <summary>
            Get first arg from input
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.NeedInitialUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,Garnet.common.RespMemoryWriter@)">
            <summary>
            Whether we need an initial update, given input, if item does not already exist in store
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="writer">Output</param>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.NeedCopyUpdate(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@)">
            <summary>
            Whether we need to need to perform an update, given old value and input
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="oldValue">Old value</param>
            <param name="writer">Output</param>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.GetInitialLength(Garnet.server.RawStringInput@)">
            <summary>
            Length of initial value, given input
            </summary>
            <param name="input">Input</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.GetLength(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@)">
            <summary>
            Length of updated value, given old value and input
            </summary>
            <param name="value">Old value</param>
            <param name="input">Input</param>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.InitialUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <summary>
            Create initial value, given key and input. Optionally generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="writer">Output</param>
            <param name="rmwInfo">Advanced arguments</param>
            <returns>True if done, false if we need to cancel the update</returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.InPlaceUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.Span{System.Byte},System.Int32@,Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <summary>
            Update given value in place, given key and input. Optionally generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="valueLength">New value length (should be no larger than current length)</param>
            <param name="writer">Output</param>
            <param name="rmwInfo">Advanced arguments</param>
            <returns>True if done, false if we have no space to update in place</returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.CopyUpdater(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},System.Span{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.RMWInfo@)">
            <summary>
            Update to new value in new location, given key, input, and old value. Optionally generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="oldValue">Old value</param>
            <param name="newValue">New value</param>
            <param name="writer">Output</param>
            <param name="rmwInfo">Advanced arguments</param>
            <returns>True if done, false if we have no space to update in place</returns>
        </member>
        <member name="M:Garnet.server.CustomRawStringFunctions.Reader(System.ReadOnlySpan{System.Byte},Garnet.server.RawStringInput@,System.ReadOnlySpan{System.Byte},Garnet.common.RespMemoryWriter@,Tsavorite.core.ReadInfo@)">
            <summary>
            Read value, given key and input and generate output for command.
            </summary>
            <param name="key">Key</param>
            <param name="input">Input</param>
            <param name="value">Value</param>
            <param name="writer">Output</param>
            <param name="readInfo">Advanced arguments</param>
            <returns>True if done, false if not found</returns>
        </member>
        <member name="T:Garnet.server.RespServerSession">
            <summary>
            Server session for RESP protocol - basic commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - ACL Commands
            </summary>
            <summary>
            Server session for RESP protocol - admin commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - array commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - basic commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - basic commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - ETag associated commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - sorted set
            </summary>
            <summary>
            Server session for RESP protocol - client commands are in this file
            </summary>
            <summary>
            Server session for RESP protocol - sorted set
            </summary>
            <summary>
             Set - RESP specific operations
            </summary>
            <summary>
            Sorted set methods with network layer access
            </summary>
            <summary>
            Server session for RESP protocol - command definitions and fast parsing
            </summary>
            <summary>
            Server session for RESP protocol - pub/sub commands are in this file
            </summary>
            <summary>
            RESP server session
            </summary>
            <summary>
            RESP server session
            </summary>
            <summary>
            RESP server session
            </summary>
            <summary>
            Server session for RESP protocol - Transaction commands are in this file
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryCustomRawStringCommand``1(Garnet.server.RespCommand,System.Int64,Garnet.server.CommandType,``0@)">
            <summary>
            Custom command
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryCustomObjectCommand``1(Garnet.server.GarnetObjectType,System.Byte,Garnet.server.CommandType,``0@)">
            <summary>
            Custom object command
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ParseCustomRawStringCommand(System.String,Garnet.server.CustomRawStringCommand@)">
            <summary>Parse custom raw string command</summary>
            <param name="cmd">Command name</param>
            <param name="customCommand">Parsed raw string command</param>
            <returns>True if command found, false otherwise</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ParseCustomObjectCommand(System.String,Garnet.server.CustomObjectCommand@)">
            <summary>Parse custom object command</summary>
            <param name="cmd">Command name</param>
            <param name="customObjCommand">Parsed object command</param>
            <returns>True if command found, false othrewise</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.InvokeCustomRawStringCommand``1(``0@,Garnet.server.CustomRawStringCommand,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice@)">
            <summary>Execute a specific custom raw string command</summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <param name="customCommand">Custom raw string command to execute</param>
            <param name="key">Key param</param>
            <param name="args">Args to the command</param>
            <param name="output">Output from the command</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.InvokeCustomObjectCommand``1(``0@,Garnet.server.CustomObjectCommand,Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice@)">
            <summary>Execute a specific custom object command</summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <param name="customObjCommand">Custom object command to execute</param>
            <param name="key">Key parameter</param>
            <param name="args">Args to the command</param>
            <param name="output">Output from the command</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryEVALSHA">
            <summary>
            EVALSHA sha1 numkeys [key [key ...]] [arg [arg ...]]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryEVAL">
            <summary>
            EVAL script numkeys [key [key ...]] [arg [arg ...]]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkScriptExists">
            <summary>
            SCRIPT|EXISTS
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkScriptFlush">
            <summary>
            SCRIPT|FLUSH
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkScriptLoad">
            <summary>
            SCRIPT|LOAD
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.CheckLuaEnabled">
            <summary>
            Returns true if Lua is enabled.
            
            Otherwise writes out an error and returns false.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryExecuteScript(System.Int32,Garnet.server.LuaRunner)">
            <summary>
            Invoke the execution of a server-side Lua script.
            
            Returns false if the <see cref="T:Garnet.server.LuaRunner"/> should be discarded rather than reused.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkLatencyHelp">
            <summary>
            Processes LATENCY HELP subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkLatencyHistogram">
            <summary>
            Processes LATENCY HISTOGRAM subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkLatencyReset">
            <summary>
            Processes LATENCY RESET subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSlowLogHelp">
            <summary>
            Processes SLOWLOG HELP subcommand.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSlowLogGet">
            <summary>
            Processes SLOWLOG GET subcommand.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSlowLogLen">
            <summary>
            Processes SLOWLOG LEN subcommand.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSlowLogReset">
            <summary>
            Processes SLOWLOG RESET subcommand.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclList">
            <summary>
            Processes ACL LIST subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclUsers">
            <summary>
            Processes ACL USERS subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclCat">
            <summary>
            Processes ACL CAT subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclSetUser">
            <summary>
            Processes ACL SETUSER subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclDelUser">
            <summary>
            Processes ACL DELUSER subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclWhoAmI">
            <summary>
            Processes ACL WHOAMI subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclLoad">
            <summary>
            Processes ACL LOAD subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclSave">
            <summary>
            Processes ACL SAVE subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclGenPass">
            <summary>
            Processes ACL GENPASS subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAclGetUser">
            <summary>
            Processes ACL GETUSER subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.CheckScriptPermissions(Garnet.server.RespCommand)">
            <summary>
            For sessions that are hosting scripting calls, checks that the parsed command is runnable.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.CheckACLPermissions(Garnet.server.RespCommand)">
            <summary>
            Performs permission checks for the current user and the given command.
            (NOTE: This function does not check keyspaces)
            </summary>
            <param name="cmd">Command be processed</param>
            <returns>True if the command execution is allowed to continue, otherwise false.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.OnACLOrNoScriptFailure(Garnet.server.RespServerSession,Garnet.server.RespCommand)">
            <summary>
            Handle ACL or NoScript failures.
            
            Failing should be rare, and is not important for performance so hide this behind
            a method call to keep icache pressure down
            </summary>
            <param name="self"></param>
            <param name="cmd"></param>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryRegisterCustomCommands(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Garnet.server.Custom.RegisterArgsBase}},Garnet.server.CustomCommandManager,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Register all custom commands / transactions
            </summary>
            <param name="binaryPaths">Binary paths from which to load assemblies</param>
            <param name="cmdInfoPath">Path of JSON file containing RespCommandsInfo for custom commands</param>
            <param name="cmdDocsPath">Path of JSON file containing RespCommandDocs for custom commands</param>
            <param name="classNameToRegisterArgs">Mapping between class names to register and arguments required for registration</param>
            <param name="customCommandManager">CustomCommandManager instance used to register commands</param>
            <param name="errorMessage">If method returned false, contains ASCII encoded generic error string; otherwise <c>default</c></param>
            <returns>A boolean value indicating whether registration of the custom commands was successful.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkRegisterCs(Garnet.server.CustomCommandManager)">
            <summary>
            REGISTERCS - Registers one or more custom commands / transactions
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMITAOF">
            <summary>
            COMMITAOF [DBID]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSAVE">
            <summary>
            SAVE [DBID]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkEXPDELSCAN">
            <summary>
            EXPDELSCAN [DBID]
            Scan the mutable region and delete all expired keys.
            This is meant to be able to let users do on-demand expiration, and even build their own schedulers
            for calling expiration based on their known workload patterns.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkLASTSAVE">
            <summary>
            LASTSAVE [DBID]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkBGSAVE">
            <summary>
            BGSAVE [SCHEDULE] [DBID]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkMGET``1(``0@)">
            <summary>
            MGET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkMSET``1(``0@)">
            <summary>
            MSET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkMSETNX``1(``0@)">
            <summary>
            MSETNX
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSELECT">
            <summary>
            SELECT
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSWAPDB">
            <summary>
            SWAPDB index1 index2
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.WriteOutputForScan(System.Int64,System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Writes the keys in the cursor to the output
            </summary>
            <param name="cursorValue">Cursor value to write to the output</param>
            <param name="keys">Keys to write to the output</param>
        </member>
        <member name="F:Garnet.server.RespServerSession.useAsync">
            <summary>
            Whether async mode is turned on for the session
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.asyncStarted">
            <summary>
            How many async operations are started and completed
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.asyncCompleted">
            <summary>
            How many async operations are started and completed
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.asyncWaiter">
            <summary>
            Async waiter for async operations
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.asyncWaiterCancel">
            <summary>
            Cancellation token source for async waiter
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.asyncDone">
            <summary>
            Semaphore for barrier command to wait for async operations to complete
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETPending``1(``0@)">
            <summary>
            Handle a async network GET command that goes pending
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
        </member>
        <member name="M:Garnet.server.RespServerSession.AsyncGetProcessor``1(``0)">
            <summary>
            Background processor for async IO continuations. This is created only when async is turned on for the session.
            It handles all the IO completions and takes over the network sender to send async responses when ready.
            Note that async responses are not guaranteed to be in the same order that they are issued.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGET``1(``0@)">
            <summary>
            GET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETEX``1(``0@)">
            <summary>
            GET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETAsync``1(``0@)">
            <summary>
            GET - async version
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGET_SG``1(``0@)">
            <summary>
            GET - scatter gather version
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSET``1(``0@)">
            <summary>
            SET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETSET``1(``0@)">
            <summary>
            GETSET
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSetRange``1(``0@)">
            <summary>
            SETRANGE
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSETEX``1(System.Boolean,``0@)">
            <summary>
            SETEX
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSETNX``1(System.Boolean,``0@)">
            <summary>
            SETNX
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSETEXNX``1(``0@)">
            <summary>
            SET EX NX [WITHETAG]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkIncrement``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Increment (INCRBY, DECRBY, INCR, DECR)
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkIncrementByFloat``1(``0@)">
            <summary>
            Increment by float (INCRBYFLOAT)
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkAppend``1(``0@)">
            <summary>
            APPEND command - appends value at the end of existing string
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkPING">
            <summary>
            PING
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkASKING">
            <summary>
            ASKING
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkQUIT">
            <summary>
            QUIT
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkFLUSHDB">
            <summary>
            FLUSHDB [ASYNC|SYNC] [UNSAFETRUNCATELOG]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkFLUSHALL">
            <summary>
            FLUSHALL [ASYNC|SYNC] [UNSAFETRUNCATELOG]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkREADONLY">
            <summary>
            Mark this session as readonly session
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkREADWRITE">
            <summary>
            Mark this session as readwrite
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSTRLEN``1(``0@)">
            <summary>
            Returns the length of the string value stored at key. An -1 is returned when key is not found
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.WriteCOMMANDResponse">
            <summary>
            Common bits of COMMAND and COMMAND INFO implementation
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND">
            <summary>
            Processes COMMAND command.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND_COUNT">
            <summary>
            Processes COMMAND COUNT subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND_DOCS">
            <summary>
            Processes COMMAND DOCS subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND_INFO">
            <summary>
            Processes COMMAND INFO subcommand.
            </summary>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND_GETKEYS">
            <summary>
            Processes COMMAND GETKEYS subcommand.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCOMMAND_GETKEYSANDFLAGS">
            <summary>
            Processes COMMAND GETKEYSANDFLAGS subcommand.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkASYNC">
            <summary>
            ASYNC [ON|OFF|BARRIER]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ProcessHelloCommand(System.Nullable{System.Byte},System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.String)">
            <summary>
            Process the HELLO command
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.FlushDb(Garnet.server.RespCommand)">
            <summary>
            Common logic for FLUSHDB and FLUSHALL
            </summary>
            <param name="cmd">RESP command (FLUSHDB / FLUSHALL)</param>
        </member>
        <member name="M:Garnet.server.RespServerSession.WriteClientInfo(Garnet.server.IClusterProvider,System.Text.StringBuilder,Garnet.server.RespServerSession,System.Int64)">
             <summary>
             Writes a string describing the given session into the string builder.
             Does not append a new line.
            
             Not all Redis fields are written as they do not all have Garnet equivalents.
             </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETWITHETAG``1(``0@)">
            <summary>
            GETWITHETAG key 
            Given a key get the value and it's ETag
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETIFNOTMATCH``1(``0@)">
            <summary>
            GETIFNOTMATCH key etag
            Given a key and an etag, return the value and it's etag.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkDELIFGREATER``1(``0@)">
            <summary>
            DELIFGREATER key etag
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSETIFMATCH``1(``0@)">
            <summary>
            SETIFMATCH key val etag [EX|PX] [expiry] [NOGET]
            Sets a key value pair with the given etag only if (1) the etag given in the request matches the already existing etag ;
            or (2) there was no existing value; or (3) the existing value was not associated with any etag and the sent Etag was 0.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSETIFGREATER``1(``0@)">
            <summary>
            SETIFGREATER key val etag [EX|PX] [expiry] [NOGET]
            Sets a key value pair with the given etag only if (1) the etag given in the request is greater than the already existing etag ;
            or (2) there was no existing value; or (3) the existing value was not associated with any etag.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkStringSetBit``1(``0@)">
            <summary>
            Sets or clears the bit at offset in the given key.
            The bit is either set or cleared depending on value, which can be either 0 or 1.
            When key does not exist, a new key is created.The key is grown to make sure it can hold a bit at offset.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkStringGetBit``1(``0@)">
            <summary>
            Returns the bit value at offset in the key stored.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkStringBitCount``1(``0@)">
            <summary>
            Count the number of set bits in a key. 
            It can be specified an interval for counting, passing the start and end arguments.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkStringBitPosition``1(``0@)">
            <summary>
            Returns the position of the first bit set to 1 or 0 in a key.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkStringBitOperation``1(Garnet.server.BitmapOperation,``0@)">
            <summary>
            Performs bitwise operations on multiple strings and store the result.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.StringBitField``1(``0@)">
            <summary>
            Performs arbitrary bitfield integer operations on strings.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.StringBitFieldReadOnly``1(``0@)">
            <summary>
            Performs arbitrary read-only bitfield integer operations
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTLIST">
            <summary>
            CLIENT LIST
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTINFO">
            <summary>
            CLIENT INFO
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTKILL">
            <summary>
            CLIENT KILL
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTGETNAME">
            <summary>
            CLIENT GETNAME
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTSETNAME">
            <summary>
            CLIENT SETNAME
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTSETINFO">
            <summary>
            CLIENT SETINFO
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkCLIENTUNBLOCK">
            <summary>
            CLIENT UNBLOCK
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.HyperLogLogAdd``1(``0@)">
            <summary>
            Adds one element to the HyperLogLog data structure stored at the variable name specified.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HyperLogLogLength``1(``0@)">
            <summary>
            Returns the approximated cardinality computed by the HyperLogLog data structure stored at the specified key,
            or 0 if the key does not exist.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.HyperLogLogMerge``1(``0@)">
            <summary>
            Merge multiple HyperLogLog values into an unique value that will approximate the cardinality 
            of the union of the observed Sets of the source HyperLogLog structures.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.RDB_VERSION">
            <summary>
            RDB format version
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkRESTORE``1(``0@)">
            <summary>
            RESTORE
            </summary>
            <param name="storageApi"></param>
            <typeparam name="TGarnetApi"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkDUMP``1(``0@)">
            <summary>
            DUMP 
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkRENAME``1(``0@)">
            <summary>
            TryRENAME
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkRENAMENX``1(``0@)">
            <summary>
            TryRENAMENX
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkGETDEL``1(``0@)">
            <summary>
            GETDEL command processor
            </summary>
            <typeparam name="TGarnetApi"> Garnet API type </typeparam>
            <param name="garnetApi"> Garnet API reference </param>
            <returns> True if successful, false otherwise </returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkEXISTS``1(``0@)">
            <summary>
            EXISTS multiple keys
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkEXPIRE``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Set a timeout on a key.
            EXPIRE key seconds [NX | XX | GT | LT]
            PEXPIRE key milliseconds [NX | XX | GT | LT]
            EXPIREAT key unix-time-seconds [NX | XX | GT | LT]
            PEXPIREAT key unix-time-milliseconds [NX | XX | GT | LT]
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command">Indicates which command to use.</param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkPERSIST``1(``0@)">
            <summary>
            PERSIST command
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi">The Garnet API instance</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkTTL``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns the remaining time to live of a key that has a timeout.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command">either if the call is for tll or pttl command</param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkEXPIRETIME``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Get the absolute Unix timestamp at which the given key will expire.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command">either if the call is for EXPIRETIME or PEXPIRETIME command</param>
            <param name="storageApi"></param>
            <returns>Returns the absolute Unix timestamp (since January 1, 1970) in seconds or milliseconds at which the given key will expire.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashSet``1(Garnet.server.RespCommand,``0@)">
            <summary>
            HashSet/HSET key field value [field value ...]: Sets the specified field(s) to their respective value(s) in the hash stored at key.
            Values of specified fields that exist in the hash are overwritten.
            If key doesn't exist, a new hash is created.
            HashSetWhenNotExists/HSETNX key field value: Sets only if field does not yet exist. A new hash is created if it does not exists.
            If field exists the operation has no effect.
            HMSET key field value [field value ...](deprecated) Same effect as HSET
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashGet``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashGetAll``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns all fields and values of the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashGetMultiple``1(Garnet.server.RespCommand,``0@)">
            <summary>
            HashGetMultiple: Returns the values associated with the specified fields in the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashRandomField``1(Garnet.server.RespCommand,``0@)">
            <summary>
            HashRandomField: Returns a random field from the hash value stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashLength``1(``0@)">
            <summary>
            Returns the number of fields contained in the hash key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashStrLength``1(``0@)">
            <summary>
            Returns the string length of the value associated with field in the hash stored at key. If the key or the field do not exist, 0 is returned.
            </summary>
            <param name="storageApi"></param>
            <typeparam name="TGarnetApi"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashDelete``1(``0@)">
            <summary>
            Removes the specified fields from the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashExists``1(``0@)">
            <summary>
            Returns if field exists in the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashKeys``1(Garnet.server.RespCommand,``0@)">
            <summary>
            HashKeys: Returns all field names in the hash key.
            HashVals: Returns all values in the hash key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashIncrement``1(Garnet.server.RespCommand,``0@)">
            <summary>
            HashIncrement: Increments the number stored at field in the hash stored at key by increment.
            HashIncrementByFloat: Increment the specified field of a hash stored at key, and representing a floating point number, by the specified increment.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashExpire``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Sets an expiration time for a field in the hash stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.HashTimeToLive``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns the time to live (TTL) for the specified fields in the hash stored at the given key.
            </summary>
            <typeparam name="TGarnetApi">The type of the storage API.</typeparam>
            <param name="command">The RESP command indicating the type of TTL operation.</param>
            <param name="storageApi">The storage API instance to interact with the underlying storage.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <exception cref="T:Garnet.common.GarnetException">Thrown when the object store is disabled.</exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListPush``1(Garnet.server.RespCommand,``0@)">
            <summary>
            LPUSH key element[element...]
            RPUSH key element [element ...]
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListPop``1(Garnet.server.RespCommand,``0@)">
            <summary>
            LPOP key [count]
            RPOP key [count]
            </summary>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListPosition``1(``0@)">
            <summary>
            The command returns the index of matching elements inside a Redis list.
            By default, when no options are given, it will scan the list from head to tail, looking for the first match of "element".
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListPopMultiple``1(``0@)">
            <summary>
            LMPOP numkeys key [key ...] LEFT | RIGHT [COUNT count]
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListBlockingPopPush">
            <summary>
            BRPOPLPUSH
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListLength``1(``0@)">
            <summary>
            LLEN key
            Gets the length of the list stored at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListTrim``1(``0@)">
            <summary>
            LTRIM key start stop
            Trim an existing list so it only contains the specified range of elements.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListRange``1(``0@)">
            <summary>
            Gets the specified elements of the list stored at key.
            LRANGE key start stop
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListIndex``1(``0@)">
            <summary>
            Returns the element at index.
            LINDEX key index
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListInsert``1(``0@)">
            <summary>
            Inserts a new element in the list stored at key either before or after a value pivot
            LINSERT key BEFORE|AFTER pivot element
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListRemove``1(``0@)">
            <summary>
            LREM key count element
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListMove``1(``0@)">
            <summary>
            LMOVE source destination [LEFT | RIGHT] [LEFT | RIGHT]
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListRightPopLeftPush``1(``0@)">
            <summary>
            RPOPLPUSH source destination
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListMove``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.OperationDirection,Garnet.server.OperationDirection,System.Byte[]@,``0@,Garnet.server.GarnetStatus@)">
            <summary>
            LMOVE source destination LEFT|RIGHT LEFT|RIGHT
            RPOPLPUSH source destination
            </summary>
            <param name="sourceKey"></param>
            <param name="destinationKey"></param>
            <param name="sourceDirection"></param>
            <param name="destinationDirection"></param>
            <param name="node"></param>
            <param name="storageApi"></param>
            <param name="garnetStatus"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListSet``1(``0@)">
            <summary>
            Sets the list element at index to element
            LSET key index element
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ListBlockingPopMultiple">
            <summary>
            BLMPOP timeout numkeys key [key ...] LEFT|RIGHT [COUNT count]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithWrongNumberOfArguments(System.String)">
            <summary>
            Aborts the execution of the current object store command and outputs
            an error message to indicate a wrong number of arguments for the given command.
            </summary>
            <param name="cmdName">Name of the command that caused the error message.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithWrongNumberOfArgumentsOrUnknownSubcommand(System.String,System.String)">
            <summary>
            Aborts the execution of the current object store command and outputs
            an error message to indicate an unknown subcommand or wrong number of arguments for the given command.
            </summary>
            <param name="subCommand">Name of the subcommand that caused the error message.</param>
            <param name="cmdName">Name of the command that caused the error message.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithErrorMessage(System.ReadOnlySpan{System.Byte})">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message
            </summary>
            <param name="errorMessage">Error message to print to result stream</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithErrorMessage(System.String,System.Object)">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="format">The format string for the error message.</param>
            <param name="arg0">The first argument to format.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithErrorMessage(System.String,System.Object,System.Object)">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="format">The format string for the error message.</param>
            <param name="arg0">The first argument to format.</param>
            <param name="arg1">The second argument to format.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithErrorMessage(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="format">The format string for the error message.</param>
            <param name="arg0">The first argument to format.</param>
            <param name="arg1">The second argument to format.</param>
            <param name="arg2">The third argument to format.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AbortWithErrorMessage(System.String,System.Object[])">
            <summary>
            Aborts the execution of the current object store command and outputs a given error message.
            </summary>
            <param name="format">The format string for the error message.</param>
            <param name="args">The arguments to format.</param>
            <returns>true if the command was completely consumed, false if the input on the receive buffer was incomplete.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetAdd``1(``0@)">
            <summary>
             Add the specified members to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetIntersect``1(``0@)">
            <summary>
            Returns the members of the set resulting from the intersection of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="storageApi"></param>
            <typeparam name="TGarnetApi"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetIntersectStore``1(``0@)">
            <summary>
            This command is equal to SINTER, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetIntersectLength``1(``0@)">
            <summary>
            Returns the cardinality of the intersection between multiple sets.
            </summary>
            <param name="storageApi"></param>
            <typeparam name="TGarnetApi"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetUnion``1(``0@)">
            <summary>
            Returns the members of the set resulting from the union of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="storageApi"></param>
            <typeparam name="TGarnetApi"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetUnionStore``1(``0@)">
            <summary>
            This command is equal to SUNION, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetRemove``1(``0@)">
            <summary>
            Remove the specified members from the set.
            Specified members that are not a member of this set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetLength``1(``0@)">
            <summary>
            Returns the number of elements of the set.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetMembers``1(``0@)">
            <summary>
            Returns all members of the set at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetPop``1(``0@)">
            <summary>
            Removes and returns one or more random members from the set at key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetMove``1(``0@)">
            <summary>
            Moves a member from a source set to a destination set.
            If the move was performed, this command returns 1.
            If the member was not found in the source set, or if no operation was performed, this command returns 0.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetRandomMember``1(``0@)">
            <summary>
            When called with just the key argument, return a random element from the set value stored at key.
            If the provided count argument is positive, return an array of distinct elements.
            The array's length is either count or the set's cardinality (SCARD), whichever is lower.
            If called with a negative count, the behavior changes and the command is allowed to return the same element multiple times.
            In this case, the number of returned elements is the absolute value of the specified count.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SetDiff``1(``0@)">
            <summary>
            Returns the members of the set resulting from the difference between the first set and all the successive sets.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ObjectScan``1(Garnet.server.GarnetObjectType,``0@)">
            <summary>
            Iterates over the associated items of a key,
            using a pattern to match and count to limit how many items to return.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="objectType">SortedSet, Hash or Set type</param>
            <param name="storageApi">The storageAPI object</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetAdd``1(``0@)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key.
            Current members get the score updated and reordered.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetRemove``1(``0@)">
            <summary>
            Removes the specified members from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetLength``1(``0@)">
            <summary>
            Returns the sorted set cardinality (number of elements) of the sorted set
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetRange``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key, using byscore, bylex and rev modifiers.
            Min and max are range boundaries, where 0 is the first element, 1 is the next element and so on.
            There can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetScore``1(``0@)">
            <summary>
            Returns the score of member in the sorted set at key.
            If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetScores``1(``0@)">
            <summary>
            Returns the score of member in the sorted set at key.
            If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetPop``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Removes and returns the first element from the sorted set stored at key,
            with the scores ordered from low to high (min) or high to low (max).
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetMPop``1(``0@)">
            <summary>
            Removes and returns up to count members from the first non-empty sorted set key from the list of keys.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetCount``1(``0@)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetLengthByValue``1(Garnet.server.RespCommand,``0@)">
            <summary>
            ZLEXCOUNT: Returns the number of elements in the sorted set with a value between min and max.
            When all the elements in a sorted set have the same score,
            this command forces lexicographical ordering.
            ZREMRANGEBYLEX: Removes all elements in the sorted set between the
            lexicographical range specified by min and max.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetIncrement``1(``0@)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment.
            If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0).
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetRank``1(Garnet.server.RespCommand,``0@)">
            <summary>
            ZRANK: Returns the rank of member in the sorted set, the scores in the sorted set are ordered from low to high
            ZREVRANK: Returns the rank of member in the sorted set, with the scores ordered from high to low
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetRemoveRange``1(Garnet.server.RespCommand,``0@)">
            <summary>
            ZREMRANGEBYRANK: Removes all elements in the sorted set stored at key with rank between start and stop.
            Both start and stop are 0 -based indexes with 0 being the element with the lowest score.
            ZREMRANGEBYSCORE: Removes all elements in the sorted set stored at key with a score between min and max (inclusive by default).
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetRandomMember``1(``0@)">
            <summary>
            Returns a random element from the sorted set key.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetDifference``1(``0@)">
            <summary>
             Computes a difference operation  between the first and all successive sorted sets
             and returns the result to the client.
             The total number of input keys is specified.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetDifferenceStore``1(``0@)">
            <summary>
             Computes a difference operation  between the first and all successive sorted sets and store
             and returns the result to the client.
             The total number of input keys is specified.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetIntersect``1(``0@)">
            <summary>
            Computes an intersection operation between multiple sorted sets
            and returns the result to the client.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetIntersectLength``1(``0@)">
            <summary>
            Returns the cardinality of the intersection between multiple sorted sets.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetIntersectStore``1(``0@)">
            <summary>
            Computes an intersection operation between multiple sorted sets and store
            the result in the destination key.
            The total number of input keys is specified.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetUnion``1(``0@)">
            <summary>
             Computes a union operation between multiple sorted sets and returns the result to the client.
             The total number of input keys is specified.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetUnionStore``1(``0@)">
            <summary>
            Computes a union operation between multiple sorted sets and stores the result in destination.
            Returns the number of elements in the resulting sorted set at destination.
            </summary>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetBlockingPop(Garnet.server.RespCommand)">
            <summary>
            BZPOPMIN/BZPOPMAX key [key ...] timeout
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetBlockingMPop">
            <summary>
            BZMPOP timeout numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetExpire``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Sets an expiration time for a member in the SortedSet stored at key.
            ZEXPIRE key seconds [NX | XX | GT | LT] MEMBERS nummembers member [member ...]
            ZPEXPIRE key milliseconds [NX | XX | GT | LT] MEMBERS nummembers member [member ...]
            ZEXPIREAT key unix-time-seconds [NX | XX | GT | LT] MEMBERS nummembers member [member ...]
            ZPEXPIREAT key unix-time-milliseconds [NX | XX | GT | LT] MEMBERS nummembers member [member ...]
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetTimeToLive``1(Garnet.server.RespCommand,``0@)">
            <summary>
            Returns the time to live (TTL) for the specified members in the SortedSet stored at the given key.
            ZTTL key MEMBERS nummembers member [member ...]
            ZPTTL key MEMBERS nummembers member [member ...]
            ZEXPIRETIME key MEMBERS nummembers member [member ...]
            ZPEXPIRETIME key MEMBERS nummembers member [member ...]
            </summary>
            <typeparam name="TGarnetApi">The type of the storage API.</typeparam>
            <param name="command">The RESP command indicating the type of TTL operation.</param>
            <param name="storageApi">The storage API instance to interact with the underlying storage.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <exception cref="T:Garnet.common.GarnetException">Thrown when the object store is disabled.</exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.SortedSetPersist``1(``0@)">
            <summary>
            Removes the expiration time from the specified members in the sorted set stored at the given key.
            ZPERSIST key MEMBERS nummembers member [member ...]
            </summary>
            <typeparam name="TGarnetApi">The type of the storage API.</typeparam>
            <param name="storageApi">The storage API instance to interact with the underlying storage.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <exception cref="T:Garnet.common.GarnetException">Thrown when the object store is disabled.</exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.GeoAdd``1(``0@)">
            <summary>
            Adds the specified geospatial items (longitude, latitude, name) to the specified key.
            Data is stored into the key as a sorted set.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.GeoCommands``1(Garnet.server.RespCommand,``0@)">
            <summary>
            GEOHASH: Returns valid Geohash strings representing the position of one or more elements in a geospatial data of the sorted set.
            GEODIST: Returns the distance between two members in the geospatial index represented by the sorted set.
            GEOPOS: Returns the positions (longitude,latitude) of all the specified members in the sorted set.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.GeoSearchCommands``1(Garnet.server.RespCommand,``0@)">
            <summary>
            GEOSEARCH: Returns the members of a sorted set populated with geospatial data, which are within the borders of the area specified by a given shape.
            GEOSEARCHSTORE: Store the the members of a sorted set populated with geospatial data, which are within the borders of the area specified by a given shape.
            GEORADIUS: Return or store the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUS_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUSBYMEMBER: Return or store the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            GEORADIUSBYMEMBER_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            </summary>
            <typeparam name="TGarnetApi"></typeparam>
            <param name="command"></param>
            <param name="storageApi"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.FastParseInlineCommand(System.Int32@)">
            <summary>
            Fast-parses command type for inline RESP commands, starting at the current read head in the receive buffer
            and advances read head.
            </summary>
            <param name="count">Outputs the number of arguments stored with the command.</param>
            <returns>RespCommand that was parsed or RespCommand.NONE, if no command was matched in this pass.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.FastParseCommand(System.Int32@)">
            <summary>
            Fast-parses for command type, starting at the current read head in the receive buffer
            and advances the read head to the position after the parsed command.
            </summary>
            <param name="count">Outputs the number of arguments stored with the command</param>
            <returns>RespCommand that was parsed or RespCommand.NONE, if no command was matched in this pass.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.FastParseArrayCommand(System.Int32@,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Fast parsing function for common command names.
            Parses the receive buffer starting from the current read head and advances it to the end of
            the parsed command/subcommand name.
            </summary>
            <param name="count">Reference to the number of remaining tokens in the packet. Will be reduced to number of command arguments.</param>
            <returns>The parsed command name.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SlowParseCommand(System.Int32@,System.ReadOnlySpan{System.Byte}@,System.Boolean@)">
            <summary>
            Parses the receive buffer, starting from the current read head, for all command names that are
            not covered by FastParseArrayCommand() and advances the read head to the end of the command name.
            
            NOTE: Assumes the input command names have already been converted to upper-case.
            </summary>
            <param name="count">Reference to the number of remaining tokens in the packet. Will be reduced to number of command arguments.</param>
            <param name="specificErrorMsg">If the command could not be parsed, will be non-empty if a specific error message should be returned.</param>
            <param name="success">True if the input RESP string was completely included in the buffer, false if we couldn't read the full command name.</param>
            <returns>The parsed command name.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.AttemptSkipLine">
            <summary>
            Attempts to skip to the end of the line ("\r\n") under the current read head.
            </summary>
            <returns>True if string terminator was found and readHead and endReadHead was changed, otherwise false. </returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.ParseRespCommandBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            Try to parse a command out of a provided buffer.
            
            Useful for when we have a command to validate somewhere, but aren't actually running it.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.FuzzParseCommandBuffer(System.ReadOnlySpan{System.Byte},Garnet.server.RespCommand@)">
            <summary>
            Version of <see cref="M:Garnet.server.RespServerSession.ParseRespCommandBuffer(System.ReadOnlySpan{System.Byte})"/> for fuzzing.
            
            Expects (and allows) partial commands.
            
            Returns true if a command was succesfully parsed
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ParseCommand(System.Boolean,System.Boolean@)">
            <summary>
            Parses the command from the given input buffer.
            </summary>
            <param name="writeErrorOnFailure">If true, when a parsing error occurs an error response will written.</param>
            <param name="success">Whether processing should continue or a parsing error occurred (e.g. out of tokens).</param>
            <returns>Command parsed from the input buffer.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.Publish(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespServerSession.PatternPublish(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkPUBLISH(Garnet.server.RespCommand)">
            <summary>
            PUBLISH
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.GetSessionMetrics">
            <summary>
            Get a copy of sessionMetrics
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.GetLatencyMetrics">
            <summary>
            Get a copy of latencyMetrics
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ResetLatencyMetrics(Garnet.common.LatencyMetricsType)">
            <summary>
            Reset latencyMetrics for eventType
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ResetAllLatencyMetrics">
            <summary>
            Reset all latencyMetrics
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.recvBufferPtr">
            <summary>
            Pointer to the (fixed) receive buffer
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.readHead">
            <summary>
            Current readHead. On successful parsing, this is left at the start of
            the command payload for use by legacy operators.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.endReadHead">
            <summary>
            End of the current command, after successful parsing.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.storageSession">
            <summary>
            Current database session items
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession._userHandle">
            <summary>
            The user currently authenticated in this session
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.SessionAsking">
            <summary>
            Clients must enable asking to make node respond to requests on slots that are being imported.
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.Server">
             <summary>
             If set, commands can use this to enumerate details about the server or other sessions.
            
             It is not guaranteed to be set.
             </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.clusterSession">
            <summary>
            Cluster session
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.currentCustomTransaction">
            <summary>
            Current custom transaction to be executed in the session.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.currentCustomRawStringCommand">
            <summary>
            Current custom command to be executed in the session.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.currentCustomObjectCommand">
            <summary>
            Current custom object command to be executed in the session.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.currentCustomProcedure">
            <summary>
            Current custom command to be executed in the session.
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.respProtocolVersion">
            <summary>
            RESP protocol version (RESP2 is the default)
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.clientName">
            <summary>
            Client name for the session
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.clientLibName">
            <summary>
            Name of the client library.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.clientLibVersion">
            <summary>
            Version of the client library.
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.waitForAofBlocking">
            <summary>
            Flag indicating whether any of the commands in one message
            requires us to block on AOF before sending response over the network
            </summary>
        </member>
        <member name="F:Garnet.server.RespServerSession.sessionScriptCache">
            <summary>
            A per-session cache for storing lua scripts
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.Id">
            <summary>
            Identifier for session - used for CLIENT and related commands.
            </summary>
        </member>
        <member name="P:Garnet.server.RespServerSession.CreationTicks">
            <summary>
            <see cref="P:System.Environment.TickCount64"/> when this <see cref="T:Garnet.server.RespServerSession"/> was created.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.#ctor(System.Int64,Garnet.networking.INetworkSender,Garnet.server.StoreWrapper,Garnet.server.SubscribeBroker,Garnet.server.Auth.IGarnetAuthenticator,System.Boolean,Garnet.server.IClusterProvider)">
            <summary>
            Create a new RESP server session
            </summary>
            <param name="id"></param>
            <param name="networkSender"></param>
            <param name="storeWrapper"></param>
            <param name="subscribeBroker"></param>
            <param name="authenticator"></param>
            <param name="enableScripts"></param>
            <param name="clusterProvider"></param>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.RespServerSession.#ctor">
            <summary>
            Just for fuzzing and testing purposes, do not use otherwise.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.GetDatabaseSessionsSnapshot">
            <summary>
            Get all active database sessions
            </summary>
            <returns>Array of active database sessions</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.UpdateRespProtocolVersion(System.Byte)">
            <summary>
            Update RESP protocol version used by session
            </summary>
            <param name="_respProtocolVersion"></param>
        </member>
        <member name="M:Garnet.server.RespServerSession.AuthenticateUser(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Tries to authenticate the given username/password and updates the user associated with this server session.
            </summary>
            <param name="username">Name of the user to authenticate.</param>
            <param name="password">Password to authenticate with.</param>
            <returns>True if the session has been authenticated successfully, false if the user could not be authenticated.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.EnterAndGetResponseObject">
            <summary>
            For testing purposes, call <see cref="M:Garnet.networking.INetworkSender.EnterAndGetResponseObject(System.Byte*@,System.Byte*@)"/> and update state accordingly.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.ExitAndReturnResponseObject">
            <summary>
            For testing purposes, call <see cref="M:Garnet.networking.INetworkSender.ExitAndReturnResponseObject"/> and update state accordingly.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryKill">
             <summary>
             Attempt to kill this session.
            
             Returns true if this call actually kills the underlying network connection.
            
             Subsequent calls will return false.
             </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.DebugSend(System.Byte*)">
            <summary>
            Debug version - send one byte at a time
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.TrySwitchActiveDatabaseSession(System.Int32)">
            <summary>
            Set the current database session
            </summary>
            <param name="dbId">Database ID of the current session</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.TrySwapDatabaseSessions(System.Int32,System.Int32)">
            <summary>
            Swap between two database sessions
            </summary>
            <param name="dbId1">Database ID of first session</param>
            <param name="dbId2">Database ID of second session</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.TryGetOrSetDatabaseSession(System.Int32,System.Boolean@,System.Int32)">
            <summary>
            Try to retrieve or create a new database session by DB ID
            </summary>
            <param name="dbId">Database ID of the session</param>
            <param name="success">True if successful</param>
            <param name="dbIdForSessionCreation">Database ID session creation (defaults to dbId, this option is used for SWAPDB only)</param>
            <returns>Reference to the retrieved or created database session</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.CreateDatabaseSession(System.Int32)">
            <summary>
            Create a new database session
            </summary>
            <param name="dbId">Database ID</param>
            <returns>New database session</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.SwitchActiveDatabaseSession(Garnet.server.GarnetDatabaseSession)">
            <summary>
            Switch current active database session
            </summary>
            <param name="dbSession">Database Session</param>
        </member>
        <member name="M:Garnet.server.RespServerSession.ProcessOutput(Tsavorite.core.SpanByteAndMemory)">
            <summary>
            Writes current output object
            </summary>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkKeyArraySlotVerify(System.Span{Garnet.server.ArgSlice},System.Boolean,System.Int32)">
            <summary>
            This method is used to verify slot ownership for provided array of key argslices.
            </summary>
            <param name="keys">Array of key ArgSlice</param>
            <param name="readOnly">Whether caller is going to perform a readonly or read/write operation</param>
            <param name="count">Key count if different than keys array length</param>
            <returns>True when ownership is verified, false otherwise</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.CanServeSlot(Garnet.server.RespCommand)">
            <summary>
            Validate if this command can be served based on the current slot assignment
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkMULTI">
            <summary>
            MULTI
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkSKIP(Garnet.server.RespCommand)">
            <summary>
            Skip the commands, first phase of the transactions processing.
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkDISCARD">
            <summary>
            DISCARD
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.CommonWATCH(Garnet.server.StoreType)">
            <summary>
            Common implementation of various WATCH commands and subcommands.
            </summary>
            <param name="type">Store type that's bein gwatch</param>
            <returns>true if parsing succeeded correctly, false if not all tokens could be consumed and further processing is necessary.</returns>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkWATCH_MS">
            <summary>
            WATCH MS key [key ..]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkWATCH_OS">
            <summary>
            WATCH OS key [key ..]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkWATCH">
            <summary>
            Watch key [key ...]
            </summary>
        </member>
        <member name="M:Garnet.server.RespServerSession.NetworkUNWATCH">
            <summary>
            UNWATCH
            </summary>
        </member>
        <member name="T:Garnet.server.CustomTransactionProcedure">
            <summary>
            Base class for transaction definition
            </summary>
        </member>
        <member name="P:Garnet.server.CustomTransactionProcedure.FailFastOnKeyLockFailure">
            <summary>
            If enabled, transaction fails fast on key locking failure instead of waiting on lock
            </summary>
        </member>
        <member name="P:Garnet.server.CustomTransactionProcedure.KeyLockTimeout">
            <summary>
            Timeout for acquiring key locks. 100 ms by default
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.AddKey(Garnet.server.ArgSlice,Tsavorite.core.LockType,System.Boolean)">
            <summary>
            Add specified key to the locking set
            </summary>
            <param name="key"></param>
            <param name="type"></param>
            <param name="isObject"></param>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.RewindScratchBuffer(Garnet.server.ArgSlice@)">
            <summary>
            Rewind (pop) the last entry of scratch buffer (rewinding the current scratch buffer offset),
            if it contains the given ArgSlice
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.CreateArgSlice(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create ArgSlice in scratch buffer, from given ReadOnlySpan
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.CreateArgSlice(System.String)">
            <summary>
            Create ArgSlice in UTF8 format in scratch buffer, from given string
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.Prepare``1(``0,Garnet.server.CustomProcedureInput@)">
            <summary>
            Prepare phase: define read/write set
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.Main``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Main transaction: allowed to read and write (locks are already taken) and produce output
            </summary>
        </member>
        <member name="M:Garnet.server.CustomTransactionProcedure.Finalize``1(``0,Garnet.server.CustomProcedureInput@,Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Finalize transaction: runs after the transactions commits/aborts, allowed to read and write (non-transactionally) with per-key locks and produce output
            NOTE: Finalize is considered post transaction processing and therefore is not executed at recovery time. Instead, the individual Tsavorite commands are logged and replayed through the AOF.
            If you are not using AOF for persistence then this is implementation detail you can ignore.
            </summary>
        </member>
        <member name="T:Garnet.server.ExpandableMap`1">
            <summary>
            This struct defines a map of items of type T whose keys are a specified range of IDs (can be descending / ascending)
            The size of the underlying array containing the items doubles in size as needed.
            This struct is thread-safe, note that it does not support re-setting an already set item.
            </summary>
            <typeparam name="T">Type of item to store</typeparam>
        </member>
        <member name="F:Garnet.server.ExpandableMap`1.mapLock">
            <summary>
            Reader-writer lock for the underlying item array pointer
            </summary>
        </member>
        <member name="P:Garnet.server.ExpandableMap`1.Map">
            <summary>
            The underlying array containing the items
            </summary>
        </member>
        <member name="P:Garnet.server.ExpandableMap`1.ActualSize">
            <summary>
            The actual size of the map
            i.e. the max index of an inserted item + 1 (not the size of the underlying array)
            </summary>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of ExpandableMap
            </summary>
            <param name="minSize">Initial size of underlying array</param>
            <param name="minId">The minimal item ID value</param>
            <param name="maxId">The maximal item ID value (can be smaller than minId for descending order of IDs)</param>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Try to get item by ID
            </summary>
            <param name="id">Item ID</param>
            <param name="value">Item value</param>
            <returns>True if item found</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TrySetValueByRef(System.Int32,`0@)">
            <summary>
            Try to set item by ID
            </summary>
            <param name="id">Item ID</param>
            <param name="value">Item value</param>
            <returns>True if assignment succeeded</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TrySetValue(System.Int32,`0)">
            <summary>
            Try to set item by ID
            </summary>
            <param name="id">Item ID</param>
            <param name="value">Item value</param>
            <returns>True if assignment succeeded</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.Exists(System.Int32)">
            <summary>
            Checks if ID is mapped to a value in underlying array
            </summary>
            <param name="id">Item ID</param>
            <returns>True if ID exists</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TryGetFirstId(System.Func{`0,System.Boolean},System.Int32@)">
            <summary>
            Find first ID in map of item that fulfills specified predicate
            </summary>
            <param name="predicate">Predicate</param>
            <param name="id">ID if found, otherwise -1</param>
            <returns>True if ID found</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TryGetNextId(System.Int32@)">
            <summary>
            Get next item ID for assignment with atomic incrementation of underlying index
            </summary>
            <param name="id">Item ID</param>
            <returns>True if item ID available</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TryUpdateActualSize(System.Int32)">
            <summary>
            Try to update the actual size of the map based on the inserted item ID
            </summary>
            <param name="id">The inserted item ID</param>
            <returns>True if actual size should be updated (or was updated if noUpdate is false)</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMap`1.TrySetValueUnsafe(System.Int32,`0@,System.Boolean)">
            <summary>
            Try to set item by ID
            This method should only be called from a thread-safe context
            </summary>
            <param name="id">Item ID</param>
            <param name="value">Item value</param>
            <param name="noExpansion">True if should not attempt to expand the underlying array</param>
            <returns>True if assignment succeeded</returns>
        </member>
        <member name="T:Garnet.server.ExpandableMapExtensions">
            <summary>
            Extension methods for ExpandableMap
            </summary>
        </member>
        <member name="M:Garnet.server.ExpandableMapExtensions.MatchCommand``1(Garnet.server.ExpandableMap{``0},System.ReadOnlySpan{System.Byte},``0@)">
            <summary>
            Match command name with existing commands in map and return first matching instance
            </summary>
            <typeparam name="T">Type of command</typeparam>
            <param name="eMap">Current instance of ExpandableMap</param>
            <param name="cmd">Command name to match</param>
            <param name="value">Value of command found</param>
            <returns>True if command found</returns>
        </member>
        <member name="M:Garnet.server.ExpandableMapExtensions.MatchSubCommand``1(Garnet.server.ExpandableMap{``0},System.ReadOnlySpan{System.Byte},Garnet.server.CustomObjectCommand@)">
            <summary>
            Match sub-command name with existing sub-commands in map and return first matching instance
            </summary>
            <typeparam name="T">Type of command</typeparam>
            <param name="eMap">Current instance of ExpandableMap</param>
            <param name="cmd">Sub-command name to match</param>
            <param name="value">Value of sub-command found</param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ICustomCommand">
            <summary>
            Interface for custom commands
            </summary>
        </member>
        <member name="P:Garnet.server.ICustomCommand.Name">
            <summary>
            Name of command
            </summary>
        </member>
        <member name="T:Garnet.server.DatabaseManagerBase">
            <summary>
            Base class for logical database management
            </summary>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.DefaultDatabase">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.DatabaseCount">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.MaxDatabaseId">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TryGetOrAddDatabase(System.Int32,System.Boolean@,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TryPauseCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ResumeCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.RecoverCheckpoint(System.Boolean,System.Boolean,System.Boolean,Garnet.server.CheckpointMetadata)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TakeCheckpoint(System.Boolean,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TakeCheckpoint(System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TakeOnDemandCheckpointAsync(System.DateTimeOffset,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TaskCheckpointBasedOnAofSizeLimitAsync(System.Int64,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.CommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.CommitToAofAsync(System.Int32,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.WaitForCommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.RecoverAOF">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ReplayAOF(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.DoCompaction(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.GrowIndexesIfNeeded(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ExecuteObjectCollection">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ExpiredKeyDeletionScan">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.StartObjectSizeTrackers(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.Reset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ResetRevivificationStats">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.EnqueueCommit(Garnet.server.AofEntryType,System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.GetDatabasesSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TryGetDatabase(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.FlushDatabase(System.Boolean,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.FlushAllDatabases(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TrySwapDatabases(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.CreateFunctionsState(System.Int32,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.Clone(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.MainStore">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.ObjectStore">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.AppendOnlyFile">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.LastSaveTime">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.ObjectStoreSizeTracker">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.DatabaseManagerBase.VersionMap">
            <inheritdoc/>
        </member>
        <member name="F:Garnet.server.DatabaseManagerBase.StoreWrapper">
            <summary>
            Store Wrapper
            </summary>
        </member>
        <member name="F:Garnet.server.DatabaseManagerBase.CreateDatabaseDelegate">
            <summary>
            Delegate for creating a new logical database
            </summary>
        </member>
        <member name="F:Garnet.server.DatabaseManagerBase.Logger">
            <summary>
            The main logger instance associated with the database manager.
            </summary>
        </member>
        <member name="F:Garnet.server.DatabaseManagerBase.LoggerFactory">
            <summary>
            The logger factory used to create logger instances
            </summary>
        </member>
        <member name="F:Garnet.server.DatabaseManagerBase.Disposed">
            <summary>
            True if instance has been previously disposed
            </summary>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.RecoverDatabaseCheckpoint(Garnet.server.GarnetDatabase,System.Int64@,System.Int64@)">
            <summary>
            Recover single database from checkpoint
            </summary>
            <param name="db">Database to recover</param>
            <param name="storeVersion">Store version</param>
            <param name="objectStoreVersion">Object store version</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TakeCheckpointAsync(Garnet.server.GarnetDatabase,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Asynchronously checkpoint a single database
            </summary>
            <param name="db">Database to checkpoint</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>Tuple of store tail address and object store tail address</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.TryPauseCheckpoints(Garnet.server.GarnetDatabase)">
            <summary>
            Try to take checkpointing lock for specified database
            </summary>
            <param name="db">Database to checkpoint</param>
            <returns>True if acquired a lock</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ResumeCheckpoints(Garnet.server.GarnetDatabase)">
            <summary>
            Release existing checkpointing lock for 
            </summary>
            <param name="db">Database to checkpoint</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.RecoverDatabaseAOF(Garnet.server.GarnetDatabase)">
            <summary>
            Recover a single database from AOF
            </summary>
            <param name="db">Database to recover</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ReplayDatabaseAOF(Garnet.server.AofProcessor,Garnet.server.GarnetDatabase,System.Int64)">
            <summary>
            Replay AOF for specified database
            </summary>
            <param name="aofProcessor">AOF processor</param>
            <param name="db">Database to replay</param>
            <param name="untilAddress">Tail address</param>
            <returns>Tail address</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ResetDatabase(Garnet.server.GarnetDatabase)">
            <summary>
            Reset database
            </summary>
            <param name="db">Database to reset</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.EnqueueDatabaseCommit(Garnet.server.GarnetDatabase,Garnet.server.AofEntryType,System.Int64)">
            <summary>
            Enqueue AOF commit for single database
            </summary>
            <param name="db">Database to enqueue commit for</param>
            <param name="entryType">AOF entry type</param>
            <param name="version">Store version</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.FlushDatabase(Garnet.server.GarnetDatabase,System.Boolean,System.Boolean)">
            <summary>
            Flush a single database
            </summary>
            <param name="db">Database to flush</param>
            <param name="unsafeTruncateLog">Truncate log</param>
            <param name="truncateAof">Truncate AOF log</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.GrowIndexesIfNeeded(Garnet.server.GarnetDatabase)">
            <summary>
            Grow store indexes for specified database, if necessary
            </summary>
            <param name="db">Database to grow store indexes for</param>
            <returns>True if both store indexes are maxed out</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ExecuteObjectCollection(Garnet.server.GarnetDatabase,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Executes a store-wide object collect operation for the specified database
            </summary>
            <param name="db">Database for object collection</param>
            <param name="logger">Logger</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ExpiredKeyDeletionScan(Garnet.server.GarnetDatabase)">
            <summary>
            Execute a store-wide expired key deletion scan operation for the specified database
            </summary>
            <param name="db">Database</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.DoCompaction(Garnet.server.GarnetDatabase,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Run compaction on specified database
            </summary>
            <param name="db">Database to run compaction on</param>
            <param name="logger">Logger</param>
            <param name="isFromCheckpoint">True if called from checkpointing, false if called from background task</param>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.GrowIndexIfNeeded(Garnet.server.StoreType,System.Int64,System.Int64,System.Func{System.Int64},System.Action)">
            <summary>
            Grows index if current size is smaller than max size.
            Decision is based on whether overflow bucket allocation is more than a threshold which indicates a contention
            in the index leading many allocations to the same bucket.
            </summary>
            <param name="storeType"></param>
            <param name="indexMaxSize"></param>
            <param name="overflowCount"></param>
            <param name="indexSizeRetriever"></param>
            <param name="growAction"></param>
            <returns>True if index has reached its max size</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.InitiateCheckpointAsync(Garnet.server.GarnetDatabase,System.Boolean,Tsavorite.core.CheckpointType,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Asynchronously initiate a single database checkpoint
            </summary>
            <param name="db">Database to checkpoint</param>
            <param name="full">True if full checkpoint should be initiated</param>
            <param name="checkpointType">Type of checkpoint</param>
            <param name="tryIncremental">Try to store as incremental delta over last snapshot</param>
            <param name="logger">Logger</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.ExpiredKeyDeletionScan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.DatabaseManagerBase.CollectHybridLogStats">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.DatabaseManagerFactory">
            <summary>
            Factory class for creating new instances of IDatabaseManager
            </summary>
        </member>
        <member name="M:Garnet.server.DatabaseManagerFactory.CreateDatabaseManager(Garnet.server.GarnetServerOptions,Garnet.server.StoreWrapper.DatabaseCreatorDelegate,Garnet.server.StoreWrapper,System.Boolean)">
            <summary>
            Create a new instance of IDatabaseManager
            </summary>
            <param name="serverOptions">Garnet server options</param>
            <param name="createDatabaseDelegate">Delegate for creating a new logical database</param>
            <param name="storeWrapper">Store wrapper instance</param>
            <param name="createDefaultDatabase">True if database manager should create a default database instance (default: true)</param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.IDatabaseManager">
            <summary>
            Interface for logical database management
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.DefaultDatabase">
            <summary>
            Default database (DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.MainStore">
            <summary>
            Store (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.ObjectStore">
            <summary>
            Object store (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.AppendOnlyFile">
            <summary>
            AOF (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.LastSaveTime">
            <summary>
            Last save time (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.ObjectStoreSizeTracker">
            <summary>
            Object store size tracker (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.VersionMap">
            <summary>
            Version map (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.DatabaseCount">
            <summary>
            Number of current logical databases
            </summary>
        </member>
        <member name="P:Garnet.server.IDatabaseManager.MaxDatabaseId">
            <summary>
            Current max database ID
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TryGetOrAddDatabase(System.Int32,System.Boolean@,System.Boolean@)">
            <summary>
            Try to get or add a new database
            </summary>
            <param name="dbId">Database ID</param>
            <param name="success">Database was found or added successfully</param>
            <param name="added">True if database was added</param>
            <returns>Retrieved or added database</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TryPauseCheckpoints(System.Int32)">
            <summary>
            Mark the beginning of a checkpoint by taking and a lock to avoid concurrent checkpointing
            </summary>
            <param name="dbId">ID of database to lock</param>
            <returns>True if lock acquired</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ResumeCheckpoints(System.Int32)">
            <summary>
            Release checkpoint task lock
            </summary>
            <param name="dbId">ID of database to unlock</param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.RecoverCheckpoint(System.Boolean,System.Boolean,System.Boolean,Garnet.server.CheckpointMetadata)">
            <summary>
            Recover checkpoint
            </summary>
            <param name="replicaRecover"></param>
            <param name="recoverMainStoreFromToken"></param>
            <param name="recoverObjectStoreFromToken"></param>
            <param name="metadata"></param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TakeCheckpoint(System.Boolean,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Take checkpoint of all active databases if checkpointing is not in progress
            </summary>
            <param name="background">True if method can return before checkpoint is taken</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>False if another checkpointing process is already in progress</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TakeCheckpoint(System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Take checkpoint of specified database ID if checkpointing is not in progress
            </summary>
            <param name="background">True if method can return before checkpoint is taken</param>
            <param name="dbId">ID of database to checkpoint</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>False if another checkpointing process is already in progress</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TakeOnDemandCheckpointAsync(System.DateTimeOffset,System.Int32)">
            <summary>
            Take a checkpoint if no checkpoint was taken after the provided time offset
            </summary>
            <param name="entryTime">Time offset</param>
            <param name="dbId">ID of database to checkpoint (default: DB 0)</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TaskCheckpointBasedOnAofSizeLimitAsync(System.Int64,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Take a checkpoint of all active databases whose AOF size has reached a specified limit
            </summary>
            <param name="aofSizeLimit">AOF size limit</param>
            <param name="token">Cancellation token</param>
            <param name="logger">Logger</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.CommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Commit to AOF for all active databases
            </summary>
            <param name="token">Cancellation token</param>
            <param name="logger">Logger</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.CommitToAofAsync(System.Int32,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Commit to AOF for specified database
            </summary>
            <param name="dbId">ID of database to commit</param>
            <param name="token">Cancellation token</param>
            <param name="logger">Logger</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.WaitForCommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Wait for commit to AOF for all active databases
            </summary>
            <param name="token">Cancellation token</param>
            <param name="logger">Logger</param>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.RecoverAOF">
            <summary>
            Recover AOF
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ReplayAOF(System.Int64)">
            <summary>
            When replaying AOF we do not want to write AOF records again.
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.DoCompaction(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Do compaction
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.GrowIndexesIfNeeded(System.Threading.CancellationToken)">
            <summary>
            Grows indexes of both main store and object store for all active databases if current size is too small
            </summary>
            <returns>True if indexes are maxed out</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ExecuteObjectCollection">
            <summary>
            Executes a store-wide object collect operation
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ExpiredKeyDeletionScan">
            <summary>
            Executes a store-wide expired key deletion scan operation
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.StartObjectSizeTrackers(System.Threading.CancellationToken)">
            <summary>
            Start object size trackers for all active databases
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.Reset(System.Int32)">
            <summary>
            Reset
            </summary>
            <param name="dbId">Database ID</param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ResetRevivificationStats">
            <summary>
            Resets the revivification stats.
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.EnqueueCommit(Garnet.server.AofEntryType,System.Int64,System.Int32)">
            <summary>
            Append a checkpoint commit to the AOF
            </summary>
            <param name="entryType"></param>
            <param name="version"></param>
            <param name="dbId"></param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.GetDatabasesSnapshot">
            <summary>
            Get a snapshot of all active databases
            </summary>
            <returns>Array of active databases</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TryGetDatabase(System.Int32,System.Boolean@)">
            <summary>
            Get database DB ID
            </summary>
            <param name="dbId">DB Id</param>
            <param name="found">True if database was found</param>
            <returns>Retrieved database</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.FlushDatabase(System.Boolean,System.Int32)">
            <summary>
            Flush database with specified ID
            </summary>
            <param name="unsafeTruncateLog">Truncate log</param>
            <param name="dbId">Database ID</param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.FlushAllDatabases(System.Boolean)">
            <summary>
            Flush all active databases 
            </summary>
            <param name="unsafeTruncateLog">Truncate log</param>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.TrySwapDatabases(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Try to swap between two database instances
            </summary>
            <param name="dbId1">First database ID</param>
            <param name="dbId2">Second database ID</param>
            <param name="token">Cancellation token</param>
            <returns>True if swap successful</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.Clone(System.Boolean)">
            <summary>
            Create a shallow copy of the IDatabaseManager instance and copy databases to the new instance
            </summary>
            <param name="enableAof">True if AOF should be enabled in the clone</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.CreateFunctionsState(System.Int32,System.Byte)">
            <summary>
            Create a database functions state
            </summary>
            <param name="dbId">Database ID</param>
            <returns>Functions state</returns>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.ExpiredKeyDeletionScan(System.Int32)">
            <summary>
            On Demand Expired Keys collection, for a db given its ID
            </summary>
        </member>
        <member name="M:Garnet.server.IDatabaseManager.CollectHybridLogStats">
            <summary>
            Collect and return an array mapping db Id to its stats
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.MultiDatabaseManager">
            <summary>
            Multiple logical database management
            </summary>
        </member>
        <member name="P:Garnet.server.MultiDatabaseManager.DefaultDatabase">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.MultiDatabaseManager.DatabaseCount">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.MultiDatabaseManager.MaxDatabaseId">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.RecoverCheckpoint(System.Boolean,System.Boolean,System.Boolean,Garnet.server.CheckpointMetadata)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TakeCheckpoint(System.Boolean,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TakeCheckpoint(System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TakeOnDemandCheckpointAsync(System.DateTimeOffset,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TaskCheckpointBasedOnAofSizeLimitAsync(System.Int64,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.CommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.CommitToAofAsync(System.Int32,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.WaitForCommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.RecoverAOF">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.ReplayAOF(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.DoCompaction(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.GrowIndexesIfNeeded(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.ExecuteObjectCollection">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.ExpiredKeyDeletionScan">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.StartObjectSizeTrackers(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.Reset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.ResetRevivificationStats">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.GetDatabasesSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TrySwapDatabases(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.Clone(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.CreateFunctionsState(System.Int32,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryGetOrAddDatabase(System.Int32,System.Boolean@,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryPauseCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.ResumeCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryGetDatabase(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.FlushDatabase(System.Boolean,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.FlushAllDatabases(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryGetDatabasesContentReadLock(System.Threading.CancellationToken)">
            <summary>
            Continuously try to take a databases content read lock
            </summary>
            <param name="token">Cancellation token</param>
            <returns>True if lock acquired</returns>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryGetDatabasesContentWriteLock(System.Threading.CancellationToken)">
            <summary>
            Continuously try to take a databases content write lock
            </summary>
            <param name="token">Cancellation token</param>
            <returns>True if lock acquired</returns>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryGetSavedDatabaseIds(System.String,System.String,System.Int32[]@)">
            <summary>
            Retrieves saved database IDs from parent checkpoint / AOF path
            e.g. if path contains directories: baseName, baseName_1, baseName_2, baseName_10
            DB IDs 0,1,2,10 will be returned
            </summary>
            <param name="path">Parent path</param>
            <param name="baseName">Base name of directories containing database-specific checkpoints / AOFs</param>
            <param name="dbIds">DB IDs extracted from parent path</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TryAddDatabase(System.Int32,Garnet.server.GarnetDatabase)">
            <summary>
            Try to add a new database
            </summary>
            <param name="dbId">Database ID</param>
            <param name="db">Database</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.HandleDatabaseAdded(System.Int32)">
            <summary>
            Handle a new database added
            </summary>
            <param name="dbId">ID of database added</param>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.CopyDatabases(Garnet.server.IDatabaseManager,System.Boolean)">
            <summary>
            Copy active databases from specified IDatabaseManager instance
            </summary>
            <param name="src">Source IDatabaseManager</param>
            <param name="enableAof">Enable AOF in copied databases</param>
        </member>
        <member name="M:Garnet.server.MultiDatabaseManager.TakeDatabasesCheckpointAsync(System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Asynchronously checkpoint multiple databases and wait for all to complete
            </summary>
            <param name="dbIdsCount">Number of databases to checkpoint (first dbIdsCount indexes from dbIdsToCheckpoint)</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>False if checkpointing already in progress</returns>
        </member>
        <member name="T:Garnet.server.SingleDatabaseManager">
            <summary>
            Single logical database management
            </summary>
        </member>
        <member name="P:Garnet.server.SingleDatabaseManager.DefaultDatabase">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.SingleDatabaseManager.DatabaseCount">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TryGetOrAddDatabase(System.Int32,System.Boolean@,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.RecoverCheckpoint(System.Boolean,System.Boolean,System.Boolean,Garnet.server.CheckpointMetadata)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TryPauseCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.ResumeCheckpoints(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TakeCheckpoint(System.Boolean,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TakeCheckpoint(System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TakeOnDemandCheckpointAsync(System.DateTimeOffset,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TaskCheckpointBasedOnAofSizeLimitAsync(System.Int64,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.CommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.CommitToAofAsync(System.Int32,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.WaitForCommitToAofAsync(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.RecoverAOF">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.ReplayAOF(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.DoCompaction(System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.GrowIndexesIfNeeded(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.ExecuteObjectCollection">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.ExpiredKeyDeletionScan">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.StartObjectSizeTrackers(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.Reset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.ResetRevivificationStats">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.EnqueueCommit(Garnet.server.AofEntryType,System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TryGetDatabase(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.FlushDatabase(System.Boolean,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.FlushAllDatabases(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.TrySwapDatabases(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.Clone(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.SingleDatabaseManager.CreateFunctionsState(System.Int32,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.ExpirationWithOption">
            <summary>
            A struct that holds an expiration timestamp in .NET ticks and an ExpireOption enum.
            Holding a timestamp in this struct will cause a conversion to coarse ticks (4-bit shift), which is a 1600ns resolution.
            </summary>
        </member>
        <member name="M:Garnet.server.ExpirationWithOption.#ctor(System.Int64,Garnet.server.ExpireOption)">
            <summary>
            Initializes a new instance of the <see cref="T:Garnet.server.ExpirationWithOption"/> struct.
            </summary>
            <param name="expirationTimeInTicks">Expiration timestamp in .NET ticks</param>
            <param name="expireOption">Expire option</param>
        </member>
        <member name="M:Garnet.server.ExpirationWithOption.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Garnet.server.ExpirationWithOption"/> struct.
            </summary>
            <param name="word">Long value encoding an expiration timestamp in .NET ticks and an ExpireOption enum</param>
        </member>
        <member name="M:Garnet.server.ExpirationWithOption.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Garnet.server.ExpirationWithOption"/> struct.
            </summary>
            <param name="wordHead">Head of long value encoding an expiration timestamp in .NET ticks and an ExpireOption enum</param>
            <param name="wordTail">Tail of long value encoding an expiration timestamp in .NET ticks and an ExpireOption enum</param>
        </member>
        <member name="P:Garnet.server.ExpirationWithOption.ExpirationTimeInTicks">
            <summary>
            Expiration timestamp in .NET ticks
            </summary>
        </member>
        <member name="P:Garnet.server.ExpirationWithOption.ExpireOption">
            <summary>
            Expiration option
            </summary>
        </member>
        <member name="P:Garnet.server.ExpirationWithOption.Word">
            <summary>
            Encoded expiration timestamp in .NET ticks and ExpireOption enum
            </summary>
        </member>
        <member name="P:Garnet.server.ExpirationWithOption.WordHead">
            <summary>
            Head of encoded expiration timestamp in .NET ticks and ExpireOption enum
            </summary>
        </member>
        <member name="P:Garnet.server.ExpirationWithOption.WordTail">
            <summary>
            Tail of encoded expiration timestamp in .NET ticks and ExpireOption enum
            </summary>
        </member>
        <member name="T:Garnet.server.ExpireOption">
            <summary>
            Expire option
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.NX">
            <summary>
            Set expiry only when the key has no expiry
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.XX">
            <summary>
            Set expiry only when the key has an existing expiry 
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.GT">
            <summary>
            Set expiry only when the new expiry is greater than current one
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.LT">
            <summary>
            Set expiry only when the new expiry is less than current one
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.XXGT">
            <summary>
            Set expiry only when the key has an existing expiry and the new expiry is greater than current one
            </summary>
        </member>
        <member name="F:Garnet.server.ExpireOption.XXLT">
            <summary>
            Set expiry only when the key has an existing expiry and the new expiry is less than current one
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetCheckpointManager">
            <summary>
            Garnet checkpoint manager, inherits from Tsavorite's DeviceLogCommitCheckpointManager
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetCheckpointManager.#ctor(Tsavorite.core.INamedDeviceFactoryCreator,Tsavorite.core.ICheckpointNamingScheme,System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create new instance of Garnet checkpoint manager
            </summary>
            <param name="deviceFactoryCreator">Factory for getting devices</param>
            <param name="checkpointNamingScheme">Checkpoint naming helper</param>
            <param name="removeOutdated">Remove older Tsavorite log commits</param>
            <param name="fastCommitThrottleFreq">FastCommit throttle frequency - use only in FastCommit mode</param>
            <param name="logger">Logger</param>
        </member>
        <member name="M:Garnet.server.GarnetCheckpointManager.GetCookie">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.GarnetDatabase">
            <summary>
            Represents a logical database in Garnet
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.DefaultVersionMapSize">
            <summary>
            Default size for version map
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.Id">
            <summary>
            Database ID
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.MainStore">
            <summary>
            Main Store
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.ObjectStore">
            <summary>
            Object Store
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.Epoch">
            <summary>
            Epoch instance used by server
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.StateMachineDriver">
            <summary>
            Common state machine driver used by Garnet
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.ObjectStoreSizeTracker">
            <summary>
            Size Tracker for Object Store
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.AofDevice">
            <summary>
            Device used for AOF logging
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.AppendOnlyFile">
            <summary>
            AOF log
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabase.VersionMap">
            <summary>
            Version map
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.LastSaveStoreTailAddress">
            <summary>
            Tail address of main store log at last save
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.LastSaveObjectStoreTailAddress">
            <summary>
            Tail address of object store log at last save
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.LastSaveTime">
            <summary>
            Last time checkpoint of database was taken
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.MainStoreIndexMaxedOut">
            <summary>
            True if database's main store index has maxed-out
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.ObjectStoreIndexMaxedOut">
            <summary>
            True if database's object store index has maxed-out
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.CheckpointingLock">
            <summary>
            Reader-Writer lock for database checkpointing
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.ObjectStoreCollectionDbStorageSession">
            <summary>
            Storage session intended for store-wide object collection operations
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.MainStoreExpiredKeyDeletionDbStorageSession">
            <summary>
            Storage session intended for main-store expired key deletion operations
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetDatabase.ObjectStoreExpiredKeyDeletionDbStorageSession">
            <summary>
            Storage session intended for object-store expired key deletion operations
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetDatabase.Dispose">
            <summary>
            Dispose method
            </summary>
        </member>
        <member name="T:Garnet.server.GlobUtils">
            <summary>
            Glob utils
            </summary>
        </member>
        <member name="M:Garnet.server.GlobUtils.Match(System.Byte*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <summary>
            Glob-style ASCII pattern matching
            </summary>
            <returns>Whether match was found</returns>
        </member>
        <member name="T:Garnet.server.RespInputFlags">
            <summary>
            Flags used by append-only file (AOF/WAL)
            The byte representation only use the last 3 bits of the byte since the lower 5 bits of the field used to store the flag stores other data in the case of Object types.
            In the case of a Rawstring, the last 4 bits are used for flags, and the other 4 bits are unused of the byte.
            NOTE: This will soon be expanded as a part of a breaking change to make WithEtag bit compatible with object store as well.
            </summary>
        </member>
        <member name="F:Garnet.server.RespInputFlags.WithEtag">
            <summary>
            Flag indicating an operation intending to add an etag for a RAWSTRING command.
            </summary>
        </member>
        <member name="F:Garnet.server.RespInputFlags.SetGet">
            <summary>
            Flag indicating a SET operation that returns the previous value (for strings).
            </summary>
        </member>
        <member name="F:Garnet.server.RespInputFlags.Deterministic">
            <summary>
            Deterministic
            </summary>
        </member>
        <member name="F:Garnet.server.RespInputFlags.Expired">
            <summary>
            Expired
            </summary>
        </member>
        <member name="T:Garnet.server.RespInputHeader">
            <summary>
            Common input header for Garnet
            </summary>
        </member>
        <member name="F:Garnet.server.RespInputHeader.Size">
            <summary>
            Size of header
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.#ctor(Garnet.server.RespCommand,Garnet.server.RespInputFlags)">
            <summary>
            Create a new instance of RespInputHeader
            </summary>
            <param name="cmd">Command</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Garnet.server.RespInputHeader.#ctor(Garnet.server.GarnetObjectType,Garnet.server.RespInputFlags)">
            <summary>
            Create a new instance of RespInputHeader
            </summary>
            <param name="type">Object type</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Garnet.server.RespInputHeader.SetHeader(System.UInt16,System.Byte)">
            <summary>
            Set RESP input header
            </summary>
            <param name="cmd">Command</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Garnet.server.RespInputHeader.SetExpiredFlag">
            <summary>
            Set expiration flag, used for log replay
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.SetSetGetFlag">
            <summary>
            Set "SetGet" flag, used to get the old value of a key after conditionally setting it
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.SetWithEtagFlag">
            <summary>
            Set "WithEtag" flag for the input header
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.CheckWithEtagFlag">
            <summary>
            Check if the WithEtag flag is set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespInputHeader.NotSetGetNorCheckWithEtag">
            <summary>
            Check that neither SetGet nor WithEtag flag is set
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.CheckExpiry(System.Int64)">
            <summary>
            Check if record is expired, either deterministically during log replay,
            or based on current time in normal operation.
            </summary>
            <param name="expireTime">Expiration time</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespInputHeader.CheckSetGetFlag">
            <summary>
            Check the SetGet flag
            </summary>
        </member>
        <member name="M:Garnet.server.RespInputHeader.ToPointer">
            <summary>
            Gets a pointer to the top of the header
            </summary>
            <returns>Pointer</returns>
        </member>
        <member name="P:Garnet.server.RespInputHeader.SpanByte">
            <summary>
            Get header as SpanByte
            </summary>
        </member>
        <member name="P:Garnet.server.RespInputHeader.Length">
            <summary>
            Get header length
            </summary>
        </member>
        <member name="T:Garnet.server.ObjectInput">
            <summary>
            Header for Garnet Object Store inputs
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectInput.header">
            <summary>
            Common input header for Garnet
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectInput.arg1">
            <summary>
            Argument for generic usage by command implementation
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectInput.arg2">
            <summary>
            Argument for generic usage by command implementation
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectInput.parseState">
            <summary>
            Session parse state
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectInput.#ctor(Garnet.server.RespInputHeader,System.Int32,System.Int32)">
            <summary>
            Create a new instance of ObjectInput
            </summary>
            <param name="header">Input header</param>
            <param name="arg1">First general-purpose argument</param>
            <param name="arg2">Second general-purpose argument</param>
        </member>
        <member name="M:Garnet.server.ObjectInput.#ctor(Garnet.server.RespInputHeader,Garnet.server.SessionParseState@,System.Int32,System.Int32)">
            <summary>
            Create a new instance of ObjectInput
            </summary>
            <param name="header">Input header</param>
            <param name="parseState">Parse state</param>
            <param name="arg1">First general-purpose argument</param>
            <param name="arg2">Second general-purpose argument</param>
        </member>
        <member name="M:Garnet.server.ObjectInput.#ctor(Garnet.server.RespInputHeader,Garnet.server.SessionParseState@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new instance of ObjectInput
            </summary>
            <param name="header">Input header</param>
            <param name="parseState">Parse state</param>
            <param name="startIdx">First command argument index in parse state</param>
            <param name="arg1">First general-purpose argument</param>
            <param name="arg2">Second general-purpose argument</param>
        </member>
        <member name="P:Garnet.server.ObjectInput.SerializedLength">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectInput.CopyTo(System.Byte*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectInput.DeserializeFrom(System.Byte*)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RawStringInput">
            <summary>
            Header for Garnet Main Store inputs
            </summary>
        </member>
        <member name="F:Garnet.server.RawStringInput.header">
            <summary>
            Common input header for Garnet
            </summary>
        </member>
        <member name="F:Garnet.server.RawStringInput.arg1">
            <summary>
            Argument for generic usage by command implementation
            </summary>
        </member>
        <member name="F:Garnet.server.RawStringInput.parseState">
            <summary>
            Session parse state
            </summary>
        </member>
        <member name="M:Garnet.server.RawStringInput.#ctor(Garnet.server.RespCommand,Garnet.server.RespInputFlags,System.Int64)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="cmd">Command</param>
            <param name="flags">Flags</param>
            <param name="arg1">General-purpose argument</param>
        </member>
        <member name="M:Garnet.server.RawStringInput.#ctor(System.UInt16,System.Byte,System.Int64)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="cmd">Command</param>
            <param name="flags">Flags</param>
            <param name="arg1">General-purpose argument</param>
        </member>
        <member name="M:Garnet.server.RawStringInput.#ctor(Garnet.server.RespCommand,Garnet.server.SessionParseState@,System.Int64,Garnet.server.RespInputFlags)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="cmd">Command</param>
            <param name="parseState">Parse state</param>
            <param name="arg1">General-purpose argument</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Garnet.server.RawStringInput.#ctor(Garnet.server.RespCommand,Garnet.server.SessionParseState@,System.Int32,System.Int64,Garnet.server.RespInputFlags)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="cmd">Command</param>
            <param name="parseState">Parse state</param>
            <param name="startIdx">First command argument index in parse state</param>
            <param name="arg1">General-purpose argument</param>
            <param name="flags">Flags</param>
        </member>
        <member name="P:Garnet.server.RawStringInput.SerializedLength">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RawStringInput.CopyTo(System.Byte*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RawStringInput.DeserializeFrom(System.Byte*)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.CustomProcedureInput">
            <summary>
            Header for Garnet CustomProcedure inputs
            </summary>
        </member>
        <member name="F:Garnet.server.CustomProcedureInput.parseState">
            <summary>
            Session parse state
            </summary>
        </member>
        <member name="P:Garnet.server.CustomProcedureInput.RespVersion">
            <summary>
            RESP version of the session currently executing.
            
            Will be 2 or 3.
            </summary>
        </member>
        <member name="M:Garnet.server.CustomProcedureInput.#ctor(Garnet.server.SessionParseState@,System.Byte)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="parseState">Parse state</param>
            <param name="respVersion">RESP version for the session</param>
        </member>
        <member name="M:Garnet.server.CustomProcedureInput.#ctor(Garnet.server.SessionParseState@,System.Int32,System.Byte)">
            <summary>
            Create a new instance of RawStringInput
            </summary>
            <param name="parseState">Parse state</param>
            <param name="startIdx">First command argument index in parse state</param>
            /// <param name="respVersion">RESP version for the session</param>
        </member>
        <member name="P:Garnet.server.CustomProcedureInput.SerializedLength">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.CustomProcedureInput.CopyTo(System.Byte*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.CustomProcedureInput.DeserializeFrom(System.Byte*)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.ObjectOutputHeader">
            <summary>
            Object output header (sometimes used as footer)
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectOutputHeader.Size">
            <summary>
            Expected size of this object
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectOutputHeader.result1">
            <summary>
            Some result of operation (e.g., number of items added successfully)
            </summary>
        </member>
        <member name="T:Garnet.server.LogCompactionType">
            <summary>
            Type of log compaction
            </summary>
        </member>
        <member name="F:Garnet.server.LogCompactionType.None">
            <summary>
            No compaction (default)
            </summary>
        </member>
        <member name="F:Garnet.server.LogCompactionType.Shift">
            <summary>
            Shift the begin address without compacting active records (data loss)
            Take a checkpoint to actually delete files from disk.
            </summary>
        </member>
        <member name="F:Garnet.server.LogCompactionType.ShiftForced">
            <summary>
            Shift the begin address without compacting active records (data loss)
            Immediately deletes files - do not use if you plan to recover after failure.
            </summary>
        </member>
        <member name="F:Garnet.server.LogCompactionType.Scan">
            <summary>
            Scan from untilAddress to read-only address to check for record liveness checking - no data loss
            (to delete actual data files from disk, take a checkpoint after compaction)
            </summary>
        </member>
        <member name="F:Garnet.server.LogCompactionType.Lookup">
            <summary>
            Lookup each record in compaction range, for record liveness checking using hash chain - no data loss
            (to delete actual data files from disk, take a checkpoint after compaction)
            </summary>
        </member>
        <member name="T:Garnet.server.ILuaAllocator">
            <summary>
            Common interface for Lua allocators.
            
            Lua itself has a somewhat esoteric alloc interface,
            this maps to something akin to malloc/free/realloc though
            with some C# niceties.
            
            Note that all returned references must be pinned, as Lua is not aware
            of the .NET GC.
            </summary>
        </member>
        <member name="M:Garnet.server.ILuaAllocator.EnterInfallibleAllocationRegion">
            <summary>
            Enter a region where allocations cannot fail.
            
            Must be paired with a call to <see cref="M:Garnet.server.ILuaAllocator.TryExitInfallibleAllocationRegion"/>, which indicates if
            an OOM should be raised.
            </summary>
        </member>
        <member name="M:Garnet.server.ILuaAllocator.TryExitInfallibleAllocationRegion">
            <summary>
            Exit a previously entered infallible allocation region.
            
            If an allocation occurred that SHOULD have failed, false is returned.
            </summary>
        </member>
        <member name="M:Garnet.server.ILuaAllocator.AllocateNew(System.Int32,System.Boolean@)">
            <summary>
            Allocate a new chunk of memory of at least <paramref name="sizeBytes"/> size.
            
            Note that 0-sized allocations MUST succeed and MUST return a non-null reference.
            A 0-sized allocation will NOT be dereferenced.
            
            If it cannot be satisfied, <paramref name="failed"/> must be set to false.
            </summary>
        </member>
        <member name="M:Garnet.server.ILuaAllocator.Free(System.Byte@,System.Int32)">
            <summary>
            Free an allocation previously obtained from <see cref="M:Garnet.server.ILuaAllocator.AllocateNew(System.Int32,System.Boolean@)"/>
            or <see cref="M:Garnet.server.ILuaAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)"/>.
            
            <paramref name="sizeBytes"/> will match sizeBytes or newSizeBytes, respectively, that
            was passed when the allocation was obtained.
            </summary>
        </member>
        <member name="M:Garnet.server.ILuaAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Resize an existing allocation.
            
            Data up to <paramref name="newSizeBytes"/> must be preserved.
            
            <paramref name="start"/> will be a previously obtained, non-null, allocation.
            <paramref name="oldSizeBytes"/> will be the sizeBytes or newSizeBytes that was passed when the allocaiton was obtained.
            
            This should resize in place if possible.
            
            If in place resizeing is not possible, the previously allocation will be freed if this method succeeds.
            
            If this allocation cannot be satisifed, <paramref name="failed"/> must be set to false.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaLimitedManagedAllocator">
            <summary>
            Provides a mapping of Lua allocations onto the POH.
            
            Pre-allocates the full maximum allocation.
            </summary>
            <remarks>
            This is a really naive allocator, just has a free list tracked with pointers in block headers.
            
            The hope is that Lua's GC keeps the actual use of this down substantially.
            
            A small optimization is trying to keep a big free block at the head of the free list.
            </remarks>
        </member>
        <member name="F:Garnet.server.LuaLimitedManagedAllocator.LuaAllocMinSizeBytes">
            <summary>
            Minimum size we'll round all Lua allocs up to.
            
            Based on largest "normal" type Lua will allocate and the needs of <see cref="T:Garnet.server.LuaLimitedManagedAllocator.BlockHeader"/>.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaLimitedManagedAllocator.BlockHeader">
            <summary>
            Represents a block of memory in this mapper.
            
            Blocks always have a size of at least <see cref="F:Garnet.server.LuaLimitedManagedAllocator.LuaAllocMinSizeBytes"/>.
            
            Blocks are either free or in use:
             - if free, <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytesRaw"/> will be positive.
             - if in use, <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytesRaw"/> will be negative.
             
            If free, the block is in a doublely linked list of free blocks.
             - <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRefRaw"/> is undefined if block is in use, 0 if block is tail of list, and ref (as long) to next block otherwise
             - <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRefRaw"/> is undefined if block is in use, 0 if block is head of list, and ref (as long) to previous block otherwise
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytesRaw">
            <summary>
            Size of the block - always valid.
            
            If negative, block is in use.
            
            If you don't already know the state of the block, use <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytes"/>.
            If you do, use this as it elides a conditional.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRefRaw">
            <summary>
            Ref of previous block if this block is in the free list.
            
            Only valid if the block is free.
            
            Most reads should go through <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRef"/> or <see cref="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetPrevFreeBlockRef"/>.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRefRaw">
            <summary>
            Ref of next block if this block is in the free list.
            
            Only valid if block is free.
            
            Most reads should go through <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRef"/> or <see cref="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetNextFreeBlockRef"/>.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.IsFree">
            <summary>
            True if block is free.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.IsInUse">
            <summary>
            True if block is in use.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytes">
            <summary>
            Size of the block in bytes.
            
            Prefer to checking <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.SizeBytesRaw"/> directly, as it accounts for state bits.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRef">
            <summary>
            Ref (as a long) of the next block in the free list, if any.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRef">
            <summary>
            Ref of the previous block in the free list, if any.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.DataReference">
            <summary>
            Grab a reference to return to users.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.Data">
            <summary>
            For debugging purposes, all the data covered by this block.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.MarkFree">
            <summary>
            Mark block free.
            
            After this, the block can be placed in the free list.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.MarkInUse">
            <summary>
            Mark block in use.
            
            After this, the <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRef"/> and <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRef"/> properties cannot be accessed.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetNextFreeBlockRef">
            <summary>
            Get a reference to the next block in the free list, or a reference BEFORE <see cref="M:Garnet.server.LuaLimitedManagedAllocator.GetDataStartRef"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetPrevFreeBlockRef">
            <summary>
            Get a reference to the prev block in the free list, or a reference BEFORE <see cref="M:Garnet.server.LuaLimitedManagedAllocator.GetDataStartRef"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetNextAdjacentBlockRef(System.Byte@,System.Int32)">
            <summary>
            Get the block the comes after this one in data.
            
            If we're at the end of data, returns a a ref BEFORE <paramref name="dataStartRef"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.GetRefVal">
            <summary>
            Get a value that can be stashed in <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.PrevFreeBlockRefRaw"/> or <see cref="F:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.NextFreeBlockRefRaw"/>
            that refers to this block.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.AllocatedBytes">
            <summary>
            For testing purposes, how many bytes are allocated to Lua at the moment.
            
            This is how many bytes we've handed out, not the size of the backing array on the POH.
            
            Only available in DEBUG to avoid updating this in RELEASE builds.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.FreeBlockCount">
            <summary>
            For testing purposes, the number of blocks tracked in the free list.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaLimitedManagedAllocator.FirstBlockSizeBytes">
            <summary>
            For testing purposes, the size of the initial block.
            
            Does not care if the block is free or allocated.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.EnterInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.TryExitInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.AllocateNew(System.Int32,System.Boolean@)">
            <summary>
            Allocate a new chunk which can fit at least <paramref name="sizeBytes"/> of data.
            
            Sets <paramref name="failed"/> to true if the allocation failed.
            
            If the allocation failes, the returned ref will be null.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.Free(System.Byte@,System.Int32)">
            <summary>
            Return a chunk of memory previously acquired by <see cref="M:Garnet.server.LuaLimitedManagedAllocator.AllocateNew(System.Int32,System.Boolean@)"/> or
            <see cref="M:Garnet.server.LuaLimitedManagedAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)"/>.
            </summary>
            <param name="start">Previously returned (non-null) value.</param>
            <param name="sizeBytes">Size passed to last <see cref="M:Garnet.server.LuaLimitedManagedAllocator.AllocateNew(System.Int32,System.Boolean@)"/> or <see cref="M:Garnet.server.LuaLimitedManagedAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)"/> call.</param>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Akin to <see cref="M:Garnet.server.LuaLimitedManagedAllocator.AllocateNew(System.Int32,System.Boolean@)"/>, except reuses the original allocation given in <paramref name="start"/> if possible.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.ContainsRef(System.Byte@)">
            <summary>
            Returns true if this reference might have been handed out by this allocator.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.CheckCorrectness">
            <summary>
            Validate the allocator.
            
            For testing purposes only.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.TryCoalesceAllFreeBlocks">
            <summary>
            Do a very expensive pass attempting to coalesce free blocks as much as possible.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.AddToFreeList(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@)">
            <summary>
            Add a the given free block to the free list.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.RemoveFromFreeList(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@)">
            <summary>
            Removes the given block from the free list.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.MoveToHeadOfFreeList(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@)">
            <summary>
            Move this given block to the head of the free list.
            
            This assumes that <paramref name="block"/> is not already at the head of the free list, and <paramref name="freeList"/> is not
            empty.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.TryCoalesceSingleBlock(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,System.Int32@)">
            <summary>
            Attempt to coalesce a block with its adjacent block.
            
            <paramref name="block"/> can be free or allocated, but coalescing will only succeed
            if the adjacent block is free.
            
            <paramref name="newBlockSizeBytes"/> is set only if the return is true.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.SplitInUseBlock(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,System.Int32)">
            <summary>
            Split an in use block, such that the current block ends up with a size equal to <paramref name="curBlockUpdateSizeBytes"/>.
            
            Returns a reference to the NEW free block.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.SplitFreeBlock(System.Byte@,Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,System.Int32)">
            <summary>
            Split a free block such that the current block ends up with a size equal to <paramref name="curBlockUpdateSizeBytes"/>.
            
            Returns a reference to the NEW block.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.GetDataStartRef">
            <summary>
            Grab the start of the managed memory we're allocating out of.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.GetFreeList">
            <summary>
            Get the start of the free list.
            
            If the free list is empty, returns a null ref.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.GetBlockRef(System.Byte@,System.Byte@)">
            <summary>
            Turn a reference obtained from <see cref="P:Garnet.server.LuaLimitedManagedAllocator.BlockHeader.DataReference"/> back into a <see cref="T:Garnet.server.LuaLimitedManagedAllocator.BlockHeader"/> reference.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.UpdateDebugAllocatedBytes(System.Int32)">
            <summary>
            In DEBUG builds, keep track of how many bytes we've allocated for testing purposes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.SplitCommon(Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,System.Int32)">
            <summary>
            Common logic for splitting blocks.
            
            Block here can either be free or in use, so don't make any assumptionsin here.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.ShouldSplit(Garnet.server.LuaLimitedManagedAllocator.BlockHeader@,System.Int32)">
            <summary>
            Check if a block should be split if it's used to serve a claim of the given size.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.RoundToMinAlloc(System.Int32)">
            <summary>
            Turn requested bytes into the actual number of bytes we're going to reserve.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.IsValidBlockRef(Garnet.server.LuaLimitedManagedAllocator.BlockHeader@)">
            <summary>
            Check if <paramref name="blockRef"/> is valid.
            
            Pulled out to indicate intent, it's basically just a null check
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.InfallibleAllocate(System.Int32)">
            <summary>
            Allocate a new pinned byte[] and root it in <see cref="F:Garnet.server.LuaLimitedManagedAllocator.infallibleAllocations"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaLimitedManagedAllocator.IsInfallibleAllocation(System.Byte@)">
            <summary>
            Returns true if <paramref name="byteStart"/> points into an infallible allocations.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaManagedAllocator">
            <summary>
            Provides a mapping of Lua allocations on to the POH.
            
            Unlike <see cref="T:Garnet.server.LuaLimitedManagedAllocator"/>, allocations are not limited.
            </summary>
            <remarks>
            This is implemented in terms of <see cref="T:Garnet.server.LuaLimitedManagedAllocator"/> because
            it is expected to be ununusual to want allocations on the POH but unlimitted.
            </remarks>
        </member>
        <member name="M:Garnet.server.LuaManagedAllocator.EnterInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaManagedAllocator.TryExitInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaManagedAllocator.AllocateNew(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaManagedAllocator.Free(System.Byte@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaManagedAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.LuaOptions">
            <summary>
            Options for Lua scripting.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaOptions.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Construct options with default options.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaOptions.#ctor(Garnet.server.LuaMemoryManagementMode,System.String,System.TimeSpan,Garnet.server.LuaLoggingMode,System.Collections.Generic.IEnumerable{System.String},Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Construct options with specific settings.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaOptions.GetMemoryLimitBytes">
            <summary>
            Get the memory limit, if any, for each script invocation.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaMemoryManagementMode">
            <summary>
            Different Lua supported memory modes.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaMemoryManagementMode.Native">
            <summary>
            Uses default Lua allocator - .NET host is unaware of allocations.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaMemoryManagementMode.Tracked">
            <summary>
            Uses <see cref="T:System.Runtime.InteropServices.NativeMemory"/> and informs .NET host of the allocations.
            
            Limits are inexactly applied due to native memory allocation overhead.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaMemoryManagementMode.Managed">
            <summary>
            Places allocations on the POH using a naive, free-list based, allocator.
            
            Limits are pre-allocated when scripts runs, which can increase allocation pressure.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaLoggingMode">
            <summary>
            Behavior of redis.log(...) when called in a Lua script.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLoggingMode.Enable">
            <summary>
            Calls to redis.log(...) pass through and are record in Garnet's configered logging provider.
            
            redis.LOG_DEBUG is mapped to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/>.
            redis.LOG_VERBOSE is mapped to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>.
            redis.LOG_NOTICE is mapped to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/>.
            redis.LOG_WARNING is mapped to <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLoggingMode.Silent">
            <summary>
            Calls to redis.log(...) succeed, but do nothing.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaLoggingMode.Disable">
            <summary>
            Calls to redis.log(...) raise an error reporting logging is disabled.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaRunner">
            <summary>
            Creates the instance to run Lua scripts
            </summary>
        </member>
        <member name="T:Garnet.server.LuaRunner.IResponseAdapter">
            <summary>
            Adapter to allow us to write directly to the network
            when in Garnet and still keep script runner work.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.IResponseAdapter.RespProtocolVersion">
            <summary>
            What version of the RESP protocol to write responses out as.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.IResponseAdapter.BufferCur">
            <summary>
            Equivalent to the ref curr we pass into <see cref="T:Garnet.common.RespWriteUtils"/> methods.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.IResponseAdapter.BufferEnd">
            <summary>
            Equivalent to the end we pass into <see cref="T:Garnet.common.RespWriteUtils"/> methods.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.IResponseAdapter.SendAndReset">
            <summary>
            Equivalent to <see cref="M:Garnet.server.RespServerSession.SendAndReset"/>.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaRunner.RespResponseAdapter">
            <summary>
            Adapter <see cref="T:Garnet.server.RespServerSession"/> so script results go directly
            to the network.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.RespResponseAdapter.BufferCur">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.RespResponseAdapter.BufferEnd">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.RespResponseAdapter.RespProtocolVersion">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.LuaRunner.RespResponseAdapter.SendAndReset">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.LuaRunner.RunnerAdapter">
            <summary>
            For the runner, put output into an array.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.RunnerAdapter.BufferCur">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.RunnerAdapter.BufferEnd">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.RunnerAdapter.RespProtocolVersion">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.RunnerAdapter.Response">
            <summary>
            Gets a span that covers the responses as written so far.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RunnerAdapter.SendAndReset">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.LuaRunner.NeedsDispose">
            <summary>
            If an invocation ran into an error that has left the <see cref="T:Garnet.server.LuaRunner"/> in a bad (but legal) state, 
            returns true indicating the <see cref="T:Garnet.server.LuaRunner"/> should be recreated at the next convenience.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.#ctor(Garnet.server.LuaMemoryManagementMode,System.Nullable{System.Int32},Garnet.server.LuaLoggingMode,System.Collections.Generic.HashSet{System.String},System.ReadOnlyMemory{System.Byte},System.Boolean,Garnet.server.RespServerSession,Garnet.server.ScratchBufferNetworkSender,System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Creates a new runner with the source of the script
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.#ctor(Garnet.server.LuaOptions,System.String,System.Boolean,Garnet.server.RespServerSession,Garnet.server.ScratchBufferNetworkSender,System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Creates a new runner with the source of the script
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CompileForRunner">
            <summary>
            Compile script for running in a .NET host.
            
            Errors are raised as exceptions.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CompileForSession(Garnet.server.RespServerSession)">
            <summary>
            Compile script for a <see cref="T:Garnet.server.RespServerSession"/>.
            
            Any errors encountered are written out as Resp errors.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.ResetCompilation">
            <summary>
            Drops compiled function, just for benchmarking purposes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Dispose">
            <summary>
            Dispose the runner
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.LuaWrappedError(System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>
            We can't use Lua's normal error handling functions on Linux, so instead we go through wrappers.
            
            The last slot on the stack is used for an error message, the rest are filled with nils.
            
            Raising the error is handled (on the Lua side) with the error_wrapper_r# functions.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.LuaWrappedError(System.Int32,System.Int32)">
            <summary>
            We can't use Lua's normal error handling functions on Linux, so instead we go through wrappers.
            
            The last slot on the stack is used for an error message, the rest are filled with nils.
            
            Raising the error is handled (on the Lua side) with the error_wrapper_r# functions.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.ProcessRespResponse(System.Byte,System.Byte*,System.Int32)">
            <summary>
            Process a RESP(2|3)-formatted response.
            
            Pushes result onto Lua stack and returns 1, or raises an error and never returns.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RunForSession(System.Int32,Garnet.server.RespServerSession)">
            <summary>
            Runs the precompiled Lua function with the given outer session.
            
            Response is written directly into the <see cref="T:Garnet.server.RespServerSession"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RunForRunner(System.String[],System.String[])">
            <summary>
            Runs the precompiled Lua function with specified (keys, argv) state.
            
            Meant for use from a .NET host rather than in Garnet properly.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RunInTransaction``1(``0@)">
            <summary>
            Calls <see cref="M:Garnet.server.LuaRunner.RunCommon``1(``0@)"/> after setting up appropriate state for a transaction.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.ResetTimeout">
            <summary>
            Clear timeout state before running.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RequestTimeout">
            <summary>
            Request that the current execution of this <see cref="T:Garnet.server.LuaRunner"/> timeout.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.TryResetParameters(System.Int32,System.Int32,KeraLua.LuaStatus@)">
            <summary>
            Remove extra keys and args from KEYS and ARGV globals.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.TryRecreateKEYS(System.Int32)">
            <summary>
            Replace KEYS in sandbox_env with a new table with the given array capacity.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.TryRecreateARGV(System.Int32)">
            <summary>
            Replace ARGV in sandbox_env with a new table with the given array capacity.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RunCommon``1(``0@)">
            <summary>
            Runs the precompiled Lua function.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.WriteResponse``1(``0@)">
            <summary>
            Convert value on top of stack (if any) into a RESP# reply
            and write it out to <paramref name="resp" />.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.TryProbeSupport(System.String@)">
            <summary>
            Attempts a call into Lua libraries.
            
            If this fails, it's basically impossible for any other Lua functionality to work.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.InitializeNoScriptDetails">
            <summary>
            Construct a bitmap we can quickly check for NoScript commands in.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.LuaRunner.UnsafeCompileForRunner(System.IntPtr)">
            <summary>
            Actually compiles for runner.
            
            If you call this directly and Lua encounters an error, the process will crash.
            
            Call <see cref="M:Garnet.server.LuaRunner.CompileForRunner"/> instead.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.UnsafeCompileForSession(System.IntPtr)">
            <summary>
            Actually compiles for runner.
            
            If you call this directly and Lua encounters an error, the process will crash.
            
            Call <see cref="M:Garnet.server.LuaRunner.CompileForSession(Garnet.server.RespServerSession)"/> instead.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.UnsafeRunPreambleForRunner(System.IntPtr)">
            <summary>
            Setups a script to be run.
            
            If you call this directly and Lua encounters an error, the process will crash.
            
            Call <see cref="M:Garnet.server.LuaRunner.RunForRunner(System.String[],System.String[])"/> instead.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.UnsafeRunPreambleForSession(System.IntPtr)">
            <summary>
            Setups a script to be run.
            
            If you call this directly and Lua encounters an error, the process will crash.
            
            Call <see cref="M:Garnet.server.LuaRunner.RunForSession(System.Int32,Garnet.server.RespServerSession)"/> instead.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.NoSessionResponse(System.IntPtr)">
            <summary>
            Call somehow came in with no valid resp server session.
            
            This is used in benchmarking.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.GarnetCallWithTransaction(System.IntPtr)">
            <summary>
            Entry point for redis.call method from a Lua script (transactional mode)
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.GarnetCall(System.IntPtr)">
            <summary>
            Entry point for redis.call method from a Lua script (non-transactional mode)
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.RequestTimeout(System.IntPtr)">
            <summary>
            Registers a debug hook which forces a timeout.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.UnpackTrampoline(System.IntPtr)">
            <summary>
            Entry point for garnet_unpack_trampoline from a Lua script.
            
            This is an odd function, but is used to handle variable returns
            after error checking has occurred.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.SHA1Hex(System.IntPtr)">
            <summary>
            Entry point for redis.sha1hex method from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Log(System.IntPtr)">
            <summary>
            Entry point for redis.log(...) from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Atan2(System.IntPtr)">
            <summary>
            Entry point for math.atan2 from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Cosh(System.IntPtr)">
            <summary>
            Entry point for math.cosh from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Frexp(System.IntPtr)">
            <summary>
            Entry point for math.frexp from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Ldexp(System.IntPtr)">
            <summary>
            Entry point for math.ldexp from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Log10(System.IntPtr)">
            <summary>
            Entry point for math.log10 from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Pow(System.IntPtr)">
            <summary>
            Entry point for math.pow from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Sinh(System.IntPtr)">
            <summary>
            Entry point for math.sinh from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Tanh(System.IntPtr)">
            <summary>
            Entry point for math.sinh from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Maxn(System.IntPtr)">
            <summary>
            Entry point for table.maxn from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.LoadString(System.IntPtr)">
            <summary>
            Entry point for loadstring from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.BitToBit(System.IntPtr)">
            <summary>
            Entry point for bit.tobit from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.BitToHex(System.IntPtr)">
            <summary>
            Entry point for bit.tohex from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.BitBswap(System.IntPtr)">
            <summary>
            Entry point for bit.bswap from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.Bitop(System.IntPtr)">
            <summary>
            Entry point for garnet_bitop from a Lua script.
            
            Used to implement bit.bnot, bit.bor, bit.band, etc.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CJsonEncode(System.IntPtr)">
            <summary>
            Entry point for cjson.encode from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CJsonDecode(System.IntPtr)">
            <summary>
            Entry point for cjson.decode from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CMsgPackPack(System.IntPtr)">
            <summary>
            Entry point for cmsgpack.pack from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CMsgPackUnpack(System.IntPtr)">
            <summary>
            Entry point for cmsgpack.unpack from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.SetResp(System.IntPtr)">
            <summary>
            Entry point for redis.setresp(...) from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.AclCheckCommand(System.IntPtr)">
            <summary>
            Entry point for redis.acl_check_cmd(...) from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CompileCommon``1(System.IntPtr,``0@)">
            <summary>
            Compile script, writing errors out to given response.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.ProcessCommandFromScripting``1(System.IntPtr,``0@)">
            <summary>
            Entry point method for executing commands from a Lua Script
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.LuaNumberToBitValue(System.Double)">
            <summary>
            Converts a Lua number (ie. a double) into the expected 32-bit integer for
            bit operations.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.StructPack(System.IntPtr)">
            <summary>
            Entry point for struct.pack from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.StructUnpack(System.IntPtr)">
            <summary>
            Entry point for struct.unpack from a Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.StructSize(System.IntPtr)">
            <summary>
            Entry point for struct.size from a Lua script.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaRunner.LoaderBlockCache">
            <summary>
            Simple cache of allowed functions to loader block.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.LoaderBlockCache.#ctor(System.Collections.Generic.HashSet{System.String},System.ReadOnlyMemory{System.Byte})">
            <summary>
            Simple cache of allowed functions to loader block.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaRunner.LoaderBlock">
            <summary>
            Lua code loaded into VM more or less immediately.
            
            Bits of this get replaced by <see cref="M:Garnet.server.LuaRunner.PrepareLoaderBlockBytes(System.Collections.Generic.HashSet{System.String},Microsoft.Extensions.Logging.ILogger)"/>.
            </summary>
        </member>
        <member name="F:Garnet.server.LuaRunner.CachedLoaderBlock">
            <summary>
            Most recently generated loader block.
            
            Since this typically does not change, we keep it around for future sessions.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.PrepareLoaderBlockBytes(System.Collections.Generic.HashSet{System.String},Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Modifies <see cref="F:Garnet.server.LuaRunner.LoaderBlock"/> to account for <paramref name="allowedFunctions"/>, and converts to ops for future loading.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunner.CompileSource(System.ReadOnlySpan{System.Byte})">
            <summary>
            Take a chunk of Lua code and convert it to binary ops.
            
            These ops are faster to load into a runtime than parsing the whole source file again.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaRunner.ConstantStringRegistryIndexes">
            <summary>
            Just to DRY it up some, a holding type for all the constant strings we pre-load into
            the Lua VM.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Ok">
            <see cref="P:Garnet.server.CmdStrings.LUA_OK"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.OkLower">
            <see cref="P:Garnet.server.CmdStrings.LUA_ok"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Err">
            <see cref="P:Garnet.server.CmdStrings.LUA_err"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.NoSessionAvailable">
            <see cref="P:Garnet.server.CmdStrings.LUA_No_session_available"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.PleaseSpecifyRedisCall">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_Please_specify_at_least_one_argument_for_this_redis_lib_call"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrNoAuth">
            <see cref="P:Garnet.server.CmdStrings.RESP_ERR_NOAUTH"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrUnknown">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_Unknown_Redis_command_called_from_script"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrBadArg">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_Lua_redis_lib_command_arguments_must_be_strings_or_integers"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrWrongNumberOfArgs">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_wrong_number_of_arguments"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrRedisLogRequired">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_redis_log_requires_two_arguments_or_more"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrFirstArgMustBeNumber">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_First_argument_must_be_a_number_log_level"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrInvalidDebugLevel">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_Invalid_debug_level"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrInvalidCommand">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_Invalid_command_passed_to_redis_acl_check_cmd"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrRedisSetRespArg">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_redis_setresp_requires_one_argument"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrRespVersion">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_RESP_version_must_be_2_or_3"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ErrLoggingDisabled">
            <see cref="P:Garnet.server.CmdStrings.LUA_ERR_redis_log_disabled"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Double">
            <see cref="P:Garnet.server.CmdStrings.LUA_double"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Map">
            <see cref="P:Garnet.server.CmdStrings.LUA_map"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Set">
            <see cref="P:Garnet.server.CmdStrings.Lua_set"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BigNumber">
            <see cref="P:Garnet.server.CmdStrings.LUA_big_number"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.Format">
            <see cref="P:Garnet.server.CmdStrings.LUA_format"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.String">
            <see cref="P:Garnet.server.CmdStrings.LUA_string"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgATan2">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_atan2"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgCosh">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_cosh"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgFrexp">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_frexp"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgLdexp">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_ldexp"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgLog10">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_log10"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgPow">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_pow"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgSinh">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_sinh"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgTanh">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_tanh"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgMaxn">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_maxn"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgLoadString">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_loadstring"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgLoadStringNullByte">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_loadstring_null_byte"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgToBit">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_tobit"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgToHex">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_tohex"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgBSwap">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_bswap"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgBNot">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_bnot"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgEncode">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_encode"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgDecode">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_decode"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgPack">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_pack"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgUnpack">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_unpack"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgFormat">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_format"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgBOr">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_bor"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgBAnd">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_band"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgBXor">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_bxor" />
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgLShift">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_lshift"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgRShift">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_rshift"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgARShift">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_arshift"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgRol">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_rol"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.BadArgRor">
            <see cref="P:Garnet.server.CmdStrings.LUA_bad_arg_ror"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.UnexpectedJsonValueKind">
            <see cref="P:Garnet.server.CmdStrings.LUA_unexpected_json_value_kind"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.CannotSerialiseToJson">
            <see cref="P:Garnet.server.CmdStrings.LUA_cannot_serialise_to_json"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.UnexpectedError">
            <see cref="P:Garnet.server.CmdStrings.LUA_unexpected_error"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.CannotSerializeNesting">
            <see cref="P:Garnet.server.CmdStrings.LUA_cannot_serialise_excessive_nesting"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.UnableToFormatNumber">
            <see cref="P:Garnet.server.CmdStrings.LUA_unable_to_format_number"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.FoundTooManyNested">
            <see cref="P:Garnet.server.CmdStrings.LUA_found_too_many_nested"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ExpectedValueButFound">
            <see cref="P:Garnet.server.CmdStrings.LUA_expected_value_but_found_invalid"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.MissingBytesInInput">
            <see cref="P:Garnet.server.CmdStrings.LUA_missing_bytes_in_input"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.UnexpectedMsgPackSigil">
            <see cref="P:Garnet.server.CmdStrings.LUA_unexpected_msgpack_sigil"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.MsgPackStringTooLong">
            <see cref="P:Garnet.server.CmdStrings.LUA_msgpack_string_too_long"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.MsgPackArrayTooLong">
            <see cref="P:Garnet.server.CmdStrings.LUA_msgpack_array_too_long"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.MsgPackMapTooLong">
            <see cref="P:Garnet.server.CmdStrings.LUA_msgpack_map_too_long"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.InsufficientLuaStackSpace">
            <see cref="P:Garnet.server.CmdStrings.LUA_insufficient_lua_stack_space"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ParameterResetFailedMemory">
            <see cref="P:Garnet.server.CmdStrings.LUA_parameter_reset_failed_memory"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ParameterResetFailedSyntax">
            <see cref="P:Garnet.server.CmdStrings.LUA_parameter_reset_failed_syntax"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ParameterResetFailedRuntime">
            <see cref="P:Garnet.server.CmdStrings.LUA_parameter_reset_failed_runtime"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ParameterResetFailedOther">
            <see cref="P:Garnet.server.CmdStrings.LUA_parameter_reset_failed_other"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.OutOfMemory">
            <see cref="P:Garnet.server.CmdStrings.LUA_out_of_memory"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.LoadStringError">
            <see cref="P:Garnet.server.CmdStrings.LUA_load_string_error"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.AND">
            <see cref="P:Garnet.server.CmdStrings.LUA_AND"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.OR">
            <see cref="P:Garnet.server.CmdStrings.LUA_OR"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.XOR">
            <see cref="P:Garnet.server.CmdStrings.LUA_XOR"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.NOT">
            <see cref="P:Garnet.server.CmdStrings.LUA_NOT"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.DIFF">
            <see cref="P:Garnet.server.CmdStrings.LUA_DIFF"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.KEYS">
            <see cref="P:Garnet.server.CmdStrings.LUA_KEYS"/>
        </member>
        <member name="P:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ARGV">
            <see cref="P:Garnet.server.CmdStrings.LUA_ARGV"/>
        </member>
        <member name="M:Garnet.server.LuaRunner.ConstantStringRegistryIndexes.ConstantStringToRegistry(Garnet.server.LuaStateWrapper@,System.ReadOnlySpan{System.Byte})">
             <summary>
             Some strings we use a bunch, and copying them to Lua each time is wasteful
            
             So instead we stash them in the Registry and load them by index
             </summary>
        </member>
        <member name="T:Garnet.server.LuaRunnerTrampolines">
            <summary>
            Holds static functions for Lua-to-.NET interop.
            
            We annotate these as "unmanaged callers only" as a micro-optimization.
            See: https://devblogs.microsoft.com/dotnet/improvements-in-native-code-interop-in-net-5-0/#unmanagedcallersonly
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.SetCallbackContext(Garnet.server.LuaRunner)">
            <summary>
            Set a <see cref="T:Garnet.server.LuaRunner"/> that will be available in trampolines.
            
            This assumes the same thread is used to call into Lua.
            
            Call <see cref="M:Garnet.server.LuaRunnerTrampolines.ClearCallbackContext(Garnet.server.LuaRunner)"/> when finished to avoid extending
            the lifetime of the <see cref="T:Garnet.server.LuaRunner"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.ClearCallbackContext(Garnet.server.LuaRunner)">
            <summary>
            Clear a previously set 
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.FailOnException(System.Exception,System.String)">
            <summary>
            Called if the 'exceptions cannot be propogated back to Lua'-invariant is violated.
            
            In this case, we have no option but to crash.
            
            We do try and log a bit before then.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CompileForRunner(System.IntPtr)">
            <summary>
            Entry point for Lua PCall'ing into <see cref="M:Garnet.server.LuaRunner.UnsafeCompileForRunner(System.IntPtr)"/>.
            
            We need this indirection to allow Lua to detect and report internal and memory errors
            without crashing the process.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CompileForSession(System.IntPtr)">
            <summary>
            Entry point for Lua PCall'ing into <see cref="M:Garnet.server.LuaRunner.UnsafeCompileForSession(System.IntPtr)"/>.
            
            We need this indirection to allow Lua to detect and report internal and memory errors
            without crashing the process.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.RunPreambleForRunner(System.IntPtr)">
            <summary>
            Entry point for Lua PCall'ing into <see cref="M:Garnet.server.LuaRunner.UnsafeRunPreambleForRunner(System.IntPtr)"/>.
            
            We need this indirection to allow Lua to detect and report internal and memory errors
            without crashing the process.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.RunPreambleForSession(System.IntPtr)">
            <summary>
            Entry point for Lua PCall'ing into <see cref="M:Garnet.server.LuaRunner.UnsafeRunPreambleForSession(System.IntPtr)"/>.
            
            We need this indirection to allow Lua to detect and report internal and memory errors
            without crashing the process.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.GarnetCallNoSession(System.IntPtr)">
            <summary>
            Entry point for Lua calling back into Garnet via redis.call(...).
            
            This entry point is for when there isn't an active <see cref="T:Garnet.server.RespServerSession"/>.
            This should only happen during testing.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.GarnetCallWithTransaction(System.IntPtr)">
            <summary>
            Entry point for Lua calling back into Garnet via redis.call(...).
            
            This entry point is for when a transaction is in effect.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.GarnetCallNoTransaction(System.IntPtr)">
            <summary>
            Entry point for Lua calling back into Garnet via redis.call(...).
            
            This entry point is for when a transaction is not necessary.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.RequestTimeout(System.IntPtr,System.IntPtr)">
            <summary>
            Entry point for checking timeouts, called periodically from Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.SHA1Hex(System.IntPtr)">
            <summary>
            Entry point for calls to redis.sha1hex.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Log(System.IntPtr)">
            <summary>
            Entry point for calls to redis.log.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.AclCheckCommand(System.IntPtr)">
            <summary>
            Entry point for calls to redis.acl_check_cmd.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.SetResp(System.IntPtr)">
            <summary>
            Entry point for calls to redis.setresp.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Atan2(System.IntPtr)">
            <summary>
            Entry point for calls to math.atan2.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Cosh(System.IntPtr)">
            <summary>
            Entry point for calls to math.cosh.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Frexp(System.IntPtr)">
            <summary>
            Entry point for calls to math.frexp.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Ldexp(System.IntPtr)">
            <summary>
            Entry point for calls to math.ldexp.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Log10(System.IntPtr)">
            <summary>
            Entry point for calls to math.log10.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Pow(System.IntPtr)">
            <summary>
            Entry point for calls to math.pow.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Sinh(System.IntPtr)">
            <summary>
            Entry point for calls to math.sinh.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Tanh(System.IntPtr)">
            <summary>
            Entry point for calls to math.tanh.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Maxn(System.IntPtr)">
            <summary>
            Entry point for calls to table.maxn.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.LoadString(System.IntPtr)">
            <summary>
            Entry point for calls to loadstring.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CJsonEncode(System.IntPtr)">
            <summary>
            Entry point for calls to cjson.encode.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CJsonDecode(System.IntPtr)">
            <summary>
            Entry point for calls to cjson.decode.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.BitToBit(System.IntPtr)">
            <summary>
            Entry point for calls to bit.tobit.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.BitToHex(System.IntPtr)">
            <summary>
            Entry point for calls to bit.tohex.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.Bitop(System.IntPtr)">
            <summary>
            Entry point for calls to garnet_bitop, which backs
            bit.bnot, bit.bor, etc.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.BitBswap(System.IntPtr)">
            <summary>
            Entry point for calls to bit.bswap.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CMsgPackPack(System.IntPtr)">
            <summary>
            Entry point for calls to cmsgpack.pack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.CMsgPackUnpack(System.IntPtr)">
            <summary>
            Entry point for calls to cmsgpack.unpack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.StructPack(System.IntPtr)">
            <summary>
            Entry point for calls to struct.pack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.StructUnpack(System.IntPtr)">
            <summary>
            Entry point for calls to struct.unpack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.StructSize(System.IntPtr)">
            <summary>
            Entry point for calls to struct.size.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaRunnerTrampolines.UnpackTrampoline(System.IntPtr)">
            <summary>
            Entry point for calls to garnet_unpack_trampoline.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaScriptHandle">
            <summary>
            Used to track the lifetime a shared Lua script, which may end up backing multiple <see cref="T:Garnet.server.LuaRunner"/>s.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaScriptHandle.IsDisposed">
            <summary>
            Returns true if this <see cref="T:Garnet.server.LuaScriptHandle"/> has been disposed.
            
            Things kept alive by this handle should be discarded when this state
            is encountered.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaScriptHandle.ScriptData">
            <summary>
            Source (or compiled source) for the associated Lua script.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaScriptHandle.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.LuaStateWrapper">
            <summary>
            For performance purposes, we need to track some additional state alongside the
            raw Lua runtime.
            
            This type does that.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaStateWrapper.StackTop">
            <summary>
            Current top item in the stack.
            
            0 implies the stack is empty.
            </summary>
        </member>
        <member name="P:Garnet.server.LuaStateWrapper.NeedsDispose">
            <summary>
            If execution has left this wrapper in a dangerous (but not illegal) state, this will be set.
            
            At the next convenient point, this <see cref="T:Garnet.server.LuaStateWrapper"/> should be disposed and recreated.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.ExpectLuaStackEmpty">
            <summary>
            Call when ambient state indicates that the Lua stack is in fact empty.
            
            Maintains <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to avoid unnecessary p/invokes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryEnsureMinimumStackCapacity(System.Int32)">
            <summary>
            Ensure there's enough space on the Lua stack for <paramref name="additionalCapacity"/> more items.
            
            Returns false if space cannot be obtained.
            
            Maintains <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to avoid unnecessary p/invokes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.CallFromLuaEntered(System.IntPtr)">
            <summary>
            Call when the Lua runtime calls back into .NET code.
            
            Figures out the state of the Lua stack once, to avoid unnecessary p/invokes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.KnownCallFromLuaEntered(System.IntPtr,System.Int32)">
            <summary>
            Call when the Lua runtime calls back into .NET code AND we know enough details about the caller
            to elide some p/invoke.
            
            Calls from user provided scripts should go through <see cref="M:Garnet.server.LuaStateWrapper.CallFromLuaEntered(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Type(System.Int32)">
            <summary>
            This should be used for all Type calls into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryPushBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            This should be used for all PushBuffer calls into Lua.
            
            If the string is a constant, consider registering it in the constructor and using <see cref="M:Garnet.server.LuaStateWrapper.PushConstantString(System.Int32)"/> instead.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushNil">
            <summary>
            This should be used for all PushNil calls into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushNumber(System.Double)">
            <summary>
            This should be used for all PushInteger calls into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushInteger(System.Int64)">
            <summary>
            This should be used for all PushInteger calls into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushBoolean(System.Boolean)">
            <summary>
            This should be used for all PushBoolean calls into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Pop(System.Int32)">
            <summary>
            This should be used for all Pop calls into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PCall(System.Int32,System.Int32)">
            <summary>
            This should be used for all PCalls into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.RawSetInteger(System.Int32,System.Int32,System.Int32)">
            <summary>
            This should be used for all RawSetIntegers into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            
            Takes <paramref name="tableArraySize"/>, the size of the array portion of the table being updated.
            
            Incorrectly specifying this <paramref name="tableArraySize"/> cause OOMs which lead to crashes.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.RawSet(System.Int32,System.Int32,System.Int32@)">
            <summary>
            This should be used for all RawSet into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.RawGetInteger(System.Nullable{KeraLua.LuaType},System.Int32,System.Int32)">
            <summary>
            This should be used for all RawGetIntegers into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.RawGet(System.Nullable{KeraLua.LuaType},System.Int32)">
            <summary>
            This should be used for all RawGets into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryRef(System.Int32@)">
            <summary>
            This should be used for all Refs into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            
            Note this will CRASH if there is insufficient memory to create the ref.
            Accordingly, there should only be a fixed number of these calls against any <see cref="T:Garnet.server.LuaStateWrapper"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Unref(KeraLua.LuaRegistry,System.Int32)">
            <summary>
            This should be used for all Unrefs into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryCreateTable(System.Int32,System.Int32)">
            <summary>
            This should be used for all CreateTables into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.GetGlobal(KeraLua.LuaType,System.ReadOnlySpan{System.Byte})">
            <summary>
            This should be used for all GetGlobals into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TrySetGlobal(System.ReadOnlySpan{System.Byte})">
            <summary>
            This should be used for all SetGlobals into Lua.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.LoadBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            This should be used for all LoadBuffers into Lua.
            
            Note that this is different from pushing a buffer, as the loaded buffer is compiled and executed.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.LoadString(System.ReadOnlySpan{System.Byte})">
            <summary>
            This should be used for all LoadStrings into Lua.
            
            Note that this is different from pushing or loading buffer, as the loaded buffer is compiled but NOT executed.
            
            Maintains <see cref="F:Garnet.server.LuaStateWrapper.curStackSize"/> and <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/> to minimize p/invoke calls.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryNumberToString(System.Int32,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Call to convert a number on the stack to a string in the same slot.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.KnownStringToBuffer(System.Int32,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Call when value at index is KNOWN to be a string.
            
            <paramref name="str"/> only remains valid as long as the buffer remains on the stack,
            use with care.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.CheckNumber(System.Int32)">
            <summary>
            This should be used for all CheckNumbers into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.ToBoolean(System.Int32)">
            <summary>
            This should be used for all ToBooleans into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.RawLen(System.Int32)">
            <summary>
            This should be used for all RawLens into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushCFunction()">
            <summary>
            This should be used for all PushCFunctions into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryRegister(System.ReadOnlySpan{System.Byte},)">
            <summary>
            Call to register a function in the Lua global namespace.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushConstantString(System.Int32)">
            <summary>
            This should be used to push all known constants strings into Lua.
            
            This avoids extra copying of data between .NET and Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Next(System.Int32)">
            <summary>
            This should be used for all Nexts into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.PushValue(System.Int32)">
            <summary>
            This should be used for all PushValues into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Remove(System.Int32)">
            <summary>
            This should be used for all Removes into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.Rotate(System.Int32,System.Int32)">
            <summary>
            This should be used for all Rotates into Lua.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TrySetHook(,KeraLua.LuaHookMask,System.Int32)">
            <summary>
            This should be used to set all debug hooks for Lua when multiple threads are involved.
            
            This can fail if there's a thread race to close the state.
            
            This is the ONLY thread-safe method on <see cref="T:Garnet.server.LuaStateWrapper"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.ClearStack">
            <summary>
            Remove everything from the Lua stack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.UpdateStackTop(System.Int32)">
            <summary>
            Helper to update <see cref="P:Garnet.server.LuaStateWrapper.StackTop"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.EnterInfallibleAllocationRegion">
            <summary>
            Enter a region where allocation calls against the <see cref="F:Garnet.server.LuaStateWrapper.customAllocator"/> cannot fail.
            
            Must be paired with a call to <see cref="M:Garnet.server.LuaStateWrapper.TryExitInfallibleAllocationRegion"/>, which indicates if
            an OOM should be raised.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.TryExitInfallibleAllocationRegion">
            <summary>
            Exit a previously entered infallible allocation region.
            
            If an allocation occurred that SHOULD have failed, false is returned.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.AssertLuaStackIndexInBounds(System.Int32)">
            <summary>
            Check that the given index refers to a valid part of the stack.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.AssertLuaStackExpected">
            <summary>
            Check that the Lua stack top is where expected in DEBUG builds.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.AssertLuaStackNotFull(System.Int32)">
            <summary>
            Check that there's space to push some number of elements.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapper.AssertLuaStackNotEmpty">
            <summary>
            Check that there's space to push some number of elements.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaStateWrapperTrampolines">
            <summary>
            Holds static functions for Lua-to-.NET interop.
            
            We annotate these as "unmanaged callers only" as a micro-optimization.
            See: https://devblogs.microsoft.com/dotnet/improvements-in-native-code-interop-in-net-5-0/#unmanagedcallersonly
            </summary>
        </member>
        <member name="P:Garnet.server.LuaStateWrapperTrampolines.PanicLogger">
            <summary>
            Controls the singular logger that will be used for panic invocations.
            
            Because Lua is panic'ing, we're about to crash.  This being process wide is hacky,
            but we're in hacky situtation.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapperTrampolines.LuaAtPanic(System.IntPtr)">
            <summary>
            Called when Lua encounters an unrecoverable error.
            
            When this returns, Lua is going to terminate the process, so plan accordingly.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaStateWrapperTrampolines.LuaAllocateBytes(System.IntPtr,System.IntPtr,System.UIntPtr,System.UIntPtr)">
            <summary>
            Provides data for Lua allocations.
            
            All returns data must be PINNED or unmanaged, Lua does not allow it to move.
            
            If allocation cannot be performed, null is returned.
            </summary>
            <param name="udPtr">Pointer to user data provided during allocation function registration</param>
            <param name="ptr">Either null (if new alloc) or pointer to existing allocation being resized or freed.</param>
            <param name="osize">If <paramref name="ptr"/> is not null, the <paramref name="nsize"/> value passed when allocation was obtained or resized.</param>
            <param name="nsize">The desired size of the allocation, in bytes.</param>
        </member>
        <member name="T:Garnet.server.Lua.LuaTimeoutManager">
            <summary>
            Central place to manage timeouts being injected into running Lua scripts.
            
            We use this because each <see cref="T:Garnet.server.LuaRunner"/> starting it's own timer
            or similar has substantial overhead.
            
            Timeouts are explicitly best effort, there's no guarantee we'll time something out _exactly_
            when it runs too long.  We will time it out _eventually_ once it has run too long.
            </summary>
            <remarks>
            This is complex functionality.
            
            Complications are:
             1. Timeouts are _rare_, so significant overhead must be avoided
                - We cannot afford to allocate timers/tasks/etc. per-invocation due to this
             2. Scripts can be active on many threads
                - However, only 1 script will be active PER thread
             3. Scripts can complete after we've decided to "time them out", so there's a natural race
             
            The rough design is:
             - <see cref="T:Garnet.server.SessionScriptCache"/>s are registered with the <see cref="T:Garnet.server.Lua.LuaTimeoutManager"/>
             - <see cref="T:Garnet.server.SessionScriptCache"/>s now track the active <see cref="T:Garnet.server.LuaRunner"/> (if any)
             - When a script starts, we get a unique token so we can distinguish the natural race
             - A dedicate thread is ticking periodically, walking the <see cref="T:Garnet.server.SessionScriptCache"/>s and triggering timeouts
            </remarks>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.Registration.SetCookie(System.UInt32)">
            <summary>
            Update value of <see cref="P:Garnet.server.Lua.LuaTimeoutManager.Registration.Cookie"/> atomically.
            </summary>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.Registration.AdvanceTimeout(System.UInt32@)">
            <summary>
            Advance count on current registration.
            
            Returns true if should be cancelled.
            
            If true, <paramref name="cookie"/> will be set to the value that identifies
            this registration.
            </summary>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.Registration.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.Start">
            <summary>
            Start this <see cref="T:Garnet.server.Lua.LuaTimeoutManager"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.RegisterForTimeout(Garnet.server.SessionScriptCache)">
            <summary>
            Register the given <see cref="T:Garnet.server.SessionScriptCache"/> for a timeout notification.
            
            A runner can only be registered a single time, by a single thread.
            
            Returns a <see cref="T:Garnet.server.Lua.LuaTimeoutManager.Registration"/> that uniquely identifies identifies this registration.
            
            Dispose the <see cref="T:Garnet.server.Lua.LuaTimeoutManager.Registration"/> to remove the cache from timeout notifications.
            </summary>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.RemoveRegistration(Garnet.server.Lua.LuaTimeoutManager.Registration)">
            <summary>
            Remove a previously created registration
            </summary>
        </member>
        <member name="M:Garnet.server.Lua.LuaTimeoutManager.TickTimeouts">
            <summary>
            Invoked periodically to check timeouts on active registrations.
            </summary>
        </member>
        <member name="T:Garnet.server.LuaTrackedAllocator">
            <summary>
            Lua allocator which still uses native memory, but tracks it and can impose limits.
            
            <see cref="M:System.GC.AddMemoryPressure(System.Int64)"/> is also used to inform .NET host of native allocations.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.EnterInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.TryExitInfallibleAllocationRegion">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.AllocateNew(System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.Free(System.Byte@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.ResizeAllocation(System.Byte@,System.Int32,System.Int32,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.InfallibleAllocate(System.Int32)">
            <summary>
            Allocate a new pinned byte[] and root it in <see cref="F:Garnet.server.LuaTrackedAllocator.infallibleAllocations"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.LuaTrackedAllocator.IsInfallibleAllocation(System.Byte@)">
            <summary>
            Returns true if <paramref name="byteStart"/> points into an infallible allocations.
            </summary>
        </member>
        <member name="T:Garnet.server.NativeMethods">
            <summary>
            Lua runtime methods we want that are not provided by <see cref="T:KeraLua.Lua"/>.
            
            Long term we'll want to try and push these upstreams and move to just using KeraLua, 
            but for now we're just defining them ourselves.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_tolstring(System.IntPtr,System.Int32,System.UIntPtr@)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_tolstring
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushlstring(System.IntPtr,System.IntPtr,System.UIntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushlstring
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_loadbufferx(System.IntPtr,System.IntPtr,System.UIntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_loadbufferx
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_loadstring(System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_loadstring
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_newstate">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_newstate
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_newstate(System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_newstate
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_openlibs(System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_openlibs
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_close(System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_close
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_checkstack(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_checkstack
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_checknumber(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_checknumber
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rawlen(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rawlen
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pcallk(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pcallk
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rawseti(System.IntPtr,System.Int32,System.Int64)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rawseti
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rawset(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rawset
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rawgeti(System.IntPtr,System.Int32,System.Int64)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rawgeti
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rawget(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rawget
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_ref(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_ref
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.luaL_unref(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#luaL_unref
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_createtable(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_createtable
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_getglobal(System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_getglobal
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_setglobal(System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_setglobal
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_next(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_next
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_rotate(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_rotate
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_gc(System.IntPtr,System.Int32,)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_gc
            
            Because this is variadic, must use DllImport and extern despite that being the old style.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_gettop(System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_gettop
            
            Does basically nothing, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_gettop
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_type(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_type
            
            Does some very basic ifs and then returns, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_type
            And
            see: https://www.lua.org/source/5.4/lapi.c.html#index2value
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushnil(System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushnil
            
            Does some very small writes, and stack size is pre-validated, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushnil
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushinteger(System.IntPtr,System.Int64)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushnumber
            
            Does some very small writes, and stack size is pre-validated, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushnumber
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushnumber(System.IntPtr,System.Double)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushnumber
            
            Does some very small writes, and stack size is pre-validated, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushinteger
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushboolean(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushboolean
            
            Does some very small writes, and stack size is pre-validated, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushboolean
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_toboolean(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_toboolean
            
            Does some very basic ifs and then returns an int, so suppressing GC transition.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_toboolean
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_settop(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_settop
            
            We aren't pushing complex types, so none of the close logic should run.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_settop
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_atpanic(System.IntPtr,System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_atpanic
            
            Just changing a global value, should be quick.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_atpanic
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushcclosure(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushcclosure
            
            We never call this with n != 0, so does very little.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushcclosure
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_sethook(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_hook
            
            This just updates some pointers, so does very little.
            see: https://www.lua.org/source/5.4/ldebug.c.html#lua_sethook
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_pushvalue(System.IntPtr,System.Int32)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_pushvalue
            
            Constant time copy into already allocated space.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_pushvalue
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.lua_version(System.IntPtr)">
            <summary>
            see: https://www.lua.org/manual/5.4/manual.html#lua_version
            
            Just returns a constant.
            see: https://www.lua.org/source/5.4/lapi.c.html#lua_version
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.CheckBuffer(System.IntPtr,System.Int32,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Returns true if the given index on the stack holds a string or a number.
            
            Sets <paramref name="str"/> to the string equivalent if so, otherwise leaves it empty.
            
            <paramref name="str"/> only remains valid as long as the buffer remains on the stack,
            use with care.
            
            Note that is changes the value on the stack to be a string if it returns true, regardless of
            what it was originally.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.KnownStringToBuffer(System.IntPtr,System.Int32,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Call when value at index is KNOWN to be a string or number
            
            <paramref name="str"/> only remains valid as long as the buffer remains on the stack,
            use with care.
            
            Note that is changes the value on the stack to be a string if it returns true, regardless of
            what it was originally.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushBuffer(System.IntPtr,System.ReadOnlySpan{System.Byte})">
            <summary>
            Pushes given span to stack as a string.
            
            Provided data is copied, and can be reused once this call returns.
            
            This method allocates, and can raise a Lua memory error.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.LoadBuffer(System.IntPtr,System.ReadOnlySpan{System.Byte})">
            <summary>
            Push given span to stack, compiles it, and executes it.
            
            Provided data is copied, and can be reused once this call returns.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.LoadString(System.IntPtr,System.ReadOnlySpan{System.Byte})">
            <summary>
            Push given span to stack, and compiles it.
            
            Provided data is copied, and can be reused once this call returns.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.GetTop(System.IntPtr)">
            <summary>
            Get the top index on the stack.
            
            0 indicates empty.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Type(System.IntPtr,System.Int32)">
            <summary>
            Gets the type of the value at the stack index.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushNil(System.IntPtr)">
            <summary>
            Pushes a nil value onto the stack.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushInteger(System.IntPtr,System.Int64)">
            <summary>
            Pushes an integer onto the stack.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushNumber(System.IntPtr,System.Double)">
            <summary>
            Pushes a double onto the stack.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushBoolean(System.IntPtr,System.Boolean)">
            <summary>
            Pushes a boolean onto the stack.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.ToBoolean(System.IntPtr,System.Int32)">
            <summary>
            Read a boolean off the stack
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Pop(System.IntPtr,System.Int32)">
            <summary>
            Remove some number of items from the stack.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.AtPanic(System.IntPtr,)">
            <summary>
            Update the panic function.
            
            Suppresses GC transition.
            and suppressing GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.NewState">
            <summary>
            Create a new Lua state.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.NewState(,System.IntPtr)">
            <summary>
            Create a new Lua state.
            
            Suppresses GC transition.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.OpenLibs(System.IntPtr)">
            <summary>
            Open all standard Lua libraries.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Close(System.IntPtr)">
            <summary>
            Close the state, releasing all associated resources.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.CheckStack(System.IntPtr,System.Int32)">
            <summary>
            Reserve space on the stack, returning false if that was not possible.
            
            This method may allocate, but will not raise a Lua error if allocations fail.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.CheckNumber(System.IntPtr,System.Int32)">
            <summary>
            Read a number, as a double, out of the stack.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.RawLen(System.IntPtr,System.Int32)">
            <summary>
            Gets the length of an object on the stack, ignoring metatable methods.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushCFunction(System.IntPtr,System.IntPtr)">
            <summary>
            Push a function onto the stack.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PCall(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Perform a protected call with the given number of arguments, expecting the given number of returns.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.RawSetInteger(System.IntPtr,System.Int32,System.Int64)">
            <summary>
            Equivalent of t[i] = v, where t is the table at the given index and v is the value on the top of the stack.
            
            Ignores metatable methods.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.RawSet(System.IntPtr,System.Int32)">
            <summary>
            Equivalent to t[k] = v, where t is the value at the given index, v is the value on the top of the stack, and k is the value just below the top.
            
            Ignores metatable methods.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.RawGetInteger(System.IntPtr,System.Int32,System.Int64)">
            <summary>
            Pushes onto the stack the value t[n], where t is the table at the given index.
            
            Ignores metatable methods.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.RawGet(System.IntPtr,System.Int32)">
            <summary>
            Pushes onto the stack the value t[k], where t is the value at the given index and k is the value on the top of the stack.
            
            Ignores metatable methods.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Ref(System.IntPtr,System.Int32)">
            <summary>
            Creates and reference a reference in that table at the given index.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Unref(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Free a ref previously created with <see cref="M:Garnet.server.NativeMethods.Ref(System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.CreateTable(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Create a new table and push it on the stack.
            
            Reserves capacity for the given number of elements and hints at capacity for non-sequence records.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.GetGlobal(System.IntPtr,System.ReadOnlySpan{System.Byte})">
            <summary>
            Load a global under the given name onto the stack.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.SetGlobal(System.IntPtr,System.ReadOnlySpan{System.Byte})">
            <summary>
            Pops the top item on the stack, and stores it under the given name as a global.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Next(System.IntPtr,System.Int32)">
            <summary>
            Pops a key from the stack, and either:
              - pushes the next key and the next value (in that order) from the table at <paramref name="tableIndex"/> and returns non-zero
              - returns zero
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.PushValue(System.IntPtr,System.Int32)">
            <summary>
            Push a copy of the value at <paramref name="stackIndex" /> onto the stack.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.SetTop(System.IntPtr,System.Int32)">
            <summary>
            Sets the index of the top elements on the stack.
            
            0 == empty
            
            Items above this point can no longer be safely accessed.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.Rotate(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Rotates elements above (and including) <paramref name="stackIndex"/> in <paramref name="n"/> steps in
            the direction of the top of the stack.
            
            <paramref name="n"/> can be negative.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.SetHook(System.IntPtr,,KeraLua.LuaHookMask,System.Int32)">
            <summary>
            Set a debugging hook.
            </summary>        
        </member>
        <member name="M:Garnet.server.NativeMethods.Version">
            <summary>
            Get the Lua version.
            </summary>
        </member>
        <member name="M:Garnet.server.NativeMethods.GC(System.IntPtr,KeraLua.LuaGC)">
            <summary>
            Invoke the Lua GC.
            </summary>
        </member>
        <member name="T:Garnet.server.ScratchBufferNetworkSender">
            <summary>
            Dummy network sender that reads from a fixed in-memory buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferNetworkSender.maxSizeSettings">
            <summary>
            Max size settings of the in-memory sender buffer
            </summary>
        </member>
        <member name="F:Garnet.server.ScratchBufferNetworkSender.serverBufferSize">
            <summary>
            Max size of the server buffer in bytes
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.#ctor">
            <summary>
            Create a new dummy network sender with a simple in-memory buffer
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.IsLocalConnection">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.Dispose">
            <summary>
            Cleanup this DummyNetworkSender instance
            </summary>
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.DisposeNetworkSender(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.Enter">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.EnterAndGetResponseObject(System.Byte*@,System.Byte*@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.Exit">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.ExitAndReturnResponseObject">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.GetResponseObject">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.GetResponseObjectHead">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.GetResponseObjectTail">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.ReturnResponseObject">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.SendCallback(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.SendResponse(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.SendResponse(System.Byte[],System.Int32,System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.Throttle">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScratchBufferNetworkSender.TryClose">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.ScriptHashKey">
            <summary>
            Specialized key type for storing script hashes.
            </summary>
        </member>
        <member name="M:Garnet.server.ScriptHashKey.CopyTo(System.Span{System.Byte})">
            <summary>
            Copy key data.
            </summary>
        </member>
        <member name="M:Garnet.server.ScriptHashKey.Equals(Garnet.server.ScriptHashKey)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.ScriptHashKey.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ScriptHashKey.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.SessionScriptCache">
            <summary>
            Cache of Lua scripts, per session
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.StartRunningScript(Garnet.server.LuaRunner)">
            <summary>
            Indicate that at a script is about to run.
            
            Enables timeouts, if they are configured.
            
            Should always be paired with a call to <see cref="M:Garnet.server.SessionScriptCache.StopRunningScript"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.StopRunningScript">
            <summary>
            Indicate that a script has stopped running.
            
            Should always be paired with a call to <see cref="M:Garnet.server.SessionScriptCache.StartRunningScript(Garnet.server.LuaRunner)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.RequestTimeout(System.UInt32)">
            <summary>
            Request that the currently running script timeout.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.TryGetFromDigest(Garnet.server.ScriptHashKey,Garnet.server.LuaRunner@,Garnet.server.LuaScriptHandle@)">
            <summary>
            Try get script runner for given digest
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.TryLoad(Garnet.server.RespServerSession,System.ReadOnlySpan{System.Byte},Garnet.server.ScriptHashKey,Garnet.server.LuaScriptHandle@,Garnet.server.LuaRunner@,System.Nullable{Garnet.server.ScriptHashKey}@)">
            <summary>
            Load script into the cache.
            
            If necessary, <paramref name="digestOnHeap"/> will be set so the allocation can be reused.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.Remove(Garnet.server.ScriptHashKey)">
            <summary>
            Attempt to remove the script with the given hash from the cache.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.Clear">
            <summary>
            Clear the session script cache
            </summary>
        </member>
        <member name="M:Garnet.server.SessionScriptCache.TrySwapDatabaseSessions(System.Int32,System.Int32)">
            <summary>
            Swap database sessions in processor session
            </summary>
            <param name="dbId1">First database ID</param>
            <param name="dbId2">Second database ID</param>
            <returns>True if successful</returns>
        </member>
        <member name="F:Garnet.server.GarnetServerMetrics.total_connections_received">
            <summary>
            Server metrics
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerMetrics.byteUnit">
            <summary>
            Instantaneous metrics
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerMetrics.globalSessionMetrics">
            <summary>
            Global session metrics
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerMetrics.historySessionMetrics">
            <summary>
            History of session metrics.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerMetrics.globalLatencyMetrics">
            <summary>
            Global latency metrics per command.
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetSessionMetrics">
            <summary>
            Performance Metrics Emitted from ServerSessionBase
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_net_input_bytes">
            <summary>
            Aggregate number of incoming bytes from the network
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_net_output_bytes">
            <summary>
            Aggregate number of outgoing bytes to the network
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_commands_processed">
            <summary>
            Aggregate number of commands processed
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_pending">
            <summary>
            Aggregate number pending.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_found">
            <summary>
            Aggregate number of found.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_notfound">
            <summary>
            Aggregate number of notfound.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_cluster_commands_processed">
            <summary>
            Aggregate number of cluster commands processed
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_write_commands_processed">
            <summary>
            Keep track of write commands executed
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_read_commands_processed">
            <summary>
            Keep track of read commands executed
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_transactions_commands_received">
            <summary>
            Keep track of transaction commands received.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_number_resp_server_session_exceptions">
            <summary>
            Keep track of total number of exceptions triggered in try consume for all resp server sessions
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetSessionMetrics.total_transaction_commands_execution_failed">
            <summary>
            Keep track of total number of transactions that were executed successfully.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.#ctor">
            <summary>
            GarnetSessionMetrics constructor
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.Add(Garnet.server.GarnetSessionMetrics)">
            <summary>
            Add to this session metrics tracker
            </summary>
            <param name="add"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.Reset">
            <summary>
            Reset current session metrics tracker
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_net_input_bytes(System.UInt64)">
            <summary>
            Accumulate incoming bytes from network
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_net_input_bytes">
            <summary>
            Get total_net_input_bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_net_output_bytes(System.UInt64)">
            <summary>
            Accumulate output bytes from network
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_net_output_bytes">
            <summary>
            Get total_net_output_bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_commands_processed(System.UInt64)">
            <summary>
            Accumulate commands processed
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_commands_processed">
            <summary>
            Get total_commands_processed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_pending(System.UInt64)">
            <summary>
            Increment pending operations.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_pending">
            <summary>
            Get total_pending
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_found(System.UInt64)">
            <summary>
            Increment found operations.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_found">
            <summary>
            Get total_found
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_notfound(System.UInt64)">
            <summary>
            Increment found operations.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_notfound">
            <summary>
            Get total_notfound
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_cluster_commands_processed(System.UInt64)">
            <summary>
            Increment total cluster commands processed
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_cluster_commands_processed">
            <summary>
            Get total_cluster_commands_processed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.add_total_write_commands_processed(System.UInt64)">
            <summary>
            Add to total_write_commands_processed
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_write_commands_processed">
            <summary>
            Get total_write_commands_processed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.add_total_read_commands_processed(System.UInt64)">
            <summary>
            Add to total_read_commands_processed
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_transaction_commands_received(System.UInt64)">
            <summary>
            Increment total_transactions_commands_received
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_transaction_execution_failed(System.UInt64)">
            <summary>
            Increment total_transaction_commands_execution_failed
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_read_commands_processed">
            <summary>
            Get total_read_commands_processed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_transaction_commands_received">
            <summary>
            Get total_transactions_commands_received
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_transaction_commands_execution_failed">
            <summary>
            Get total_transaction_commands_execution_failed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.incr_total_number_resp_server_session_exceptions(System.UInt64)">
            <summary>
            Increment total_number_resp_server_session_exceptions
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Garnet.server.GarnetSessionMetrics.get_total_number_resp_server_session_exceptions">
            <summary>
            Get total_number_resp_server_session_exceptions
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.GarnetLatencyMetrics">
            <summary>
            Latency metrics emitted from RespServerSession
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetLatencyMetricsSession">
            <summary>
            Latency metrics emitted from RespServerSession
            </summary>
        </member>
        <member name="T:Garnet.server.RespLatencyHelp">
            <summary>
            Info on what latency commands are supported
            </summary>
        </member>
        <member name="M:Garnet.server.RespLatencyHelp.GetLatencyCommands">
            <summary>
            Get supported latency commands and a short description
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.RespSlowLogHelp">
            <summary>
            Info on what slow log commands are supported
            </summary>
        </member>
        <member name="M:Garnet.server.RespSlowLogHelp.GetSlowLogCommands">
            <summary>
            Get supported latency commands and a short description
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.SlowLogContainer">
            <summary>
            Thread-safe container for the slow log
            </summary>
        </member>
        <member name="M:Garnet.server.SlowLogContainer.#ctor(System.Int32)">
            <summary>
            Create new instance of slow log container
            </summary>
            <param name="size"></param>
        </member>
        <member name="P:Garnet.server.SlowLogContainer.Count">
            <summary>
            Count number of entries in the slow log
            </summary>
        </member>
        <member name="M:Garnet.server.SlowLogContainer.Add(Garnet.server.SlowLogEntry)">
            <summary>
            Add entry to the slow log with auto-assigned id
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:Garnet.server.SlowLogContainer.Clear">
            <summary>
            Clear the slow log buffer
            </summary>
        </member>
        <member name="M:Garnet.server.SlowLogContainer.GetEntries(System.Int32)">
            <summary>
            Get a snapshot of the latest count entries in the slow log (-1 returns all entries)
            </summary>
        </member>
        <member name="T:Garnet.server.SlowLogEntry">
            <summary>
            Each entry in the slow log
            </summary>
        </member>
        <member name="T:Garnet.server.ModuleBase">
            <summary>
            Abstract base class that all Garnet modules must inherit from.
            The module must have a parameterless constructor.
            NOTE: This is a feature that is under development.
            If taking a dependency on this, please be prepared for breaking changes.
            </summary>
        </member>
        <member name="M:Garnet.server.ModuleBase.OnLoad(Garnet.server.ModuleLoadContext,System.String[])">
            <summary>
            Called when the module is loaded.
            </summary>
            <param name="context">Module load context</param>
            <param name="args">Module load args</param>
        </member>
        <member name="T:Garnet.server.ModuleActionStatus">
            <summary>
            Represents the status of a module action.
            </summary>
        </member>
        <member name="T:Garnet.server.ModuleLoadContext">
            <summary>
            Provides context for a loading module to invoke initialization and registration methods.
            </summary>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.Initialize(System.String,System.UInt32)">
            <summary>
            Initializes the module load context
            </summary>
            <param name="name">Module name</param>
            <param name="version">Module version</param>
            <returns>Initialization status</returns>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.RegisterCommand(System.String,Garnet.server.CustomRawStringFunctions,Garnet.server.CommandType,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs,System.Int64)">
            <summary>
            Registers a raw string custom command
            </summary>
            <param name="name">Command name</param>
            <param name="type">Command type</param>
            <param name="customFunctions">Custom raw string function implementation</param>
            <param name="commandInfo">Command info</param>
            <param name="commandDocs">RESP command docs</param>
            <param name="expirationTicks">Expiration ticks for the key</param>
            <returns>Registration status</returns>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.RegisterTransaction(System.String,System.Func{Garnet.server.CustomTransactionProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Registers a custom transaction
            </summary>
            <param name="name">Transaction name</param>
            <param name="proc">Transaction procedure implementation</param>
            <param name="commandInfo">Command info</param>
            <param name="commandDocs">Command docs</param>
            <returns>Registration status</returns>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.RegisterType(Garnet.server.CustomObjectFactory)">
            <summary>Registers a custom type</summary>
            <param name="factory">Factory to generate new instances of type</param>
            <returns>Registration status</returns>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.RegisterCommand(System.String,Garnet.server.CustomObjectFactory,Garnet.server.CustomObjectFunctions,Garnet.server.CommandType,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Registers a custom object command
            </summary>
            <param name="name">Command name</param>
            <param name="factory">Type factory</param>
            <param name="command">Custom object function implementation</param>
            <param name="type">Command type</param>
            <param name="commandInfo">Command info</param>
            <param name="commandDocs">RESP command docs</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ModuleLoadContext.RegisterProcedure(System.String,System.Func{Garnet.server.CustomProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Registers a custom procedure that performs several operations in a non-transactional manner
            </summary>
            <param name="name">Procedure name</param>
            <param name="customScriptProc">Custom procedure implementation</param>
            <param name="commandInfo">Command info</param>
            <param name="commandDocs">Command docs</param>
            <returns>Registration status</returns>
        </member>
        <member name="M:Garnet.server.ModuleRegistrar.LoadModule(Garnet.server.CustomCommandManager,System.Reflection.Assembly,System.String[],Microsoft.Extensions.Logging.ILogger,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Load module from a specified assembly and register it with the custom command managers
            </summary>
            <param name="customCommandManager">Custom command manager instance</param>
            <param name="loadedAssembly">Loaded assembly containing module</param>
            <param name="moduleArgs">Module arguments</param>
            <param name="logger">Logger</param>
            <param name="errorMessage">Error message</param>
            <returns>True if module loaded successfully</returns>
        </member>
        <member name="M:Garnet.server.ModuleUtils.LoadAssemblies(System.Collections.Generic.IEnumerable{System.String},System.String[],System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}@,System.ReadOnlySpan{System.Byte}@,System.String[],System.IO.SearchOption,System.Boolean,System.Boolean)">
            <summary>
            Load assemblies from specified binary paths
            </summary>
            <param name="binaryPaths">Source paths for assemblies (can be either files or directories)</param>
            <param name="allowedExtensionPaths">List of allowed paths for loading assemblies from</param>
            <param name="allowUnsignedAssemblies">True if loading unsigned assemblies is allowed</param>
            <param name="loadedAssemblies">Loaded assemblies</param>
            <param name="errorMessage">Error message</param>
            <param name="ignoreFileNames">File names to ignore (optional)</param>
            <param name="searchOption">In case path is a directory, determines whether to search only top directory or all subdirectories</param>
            <param name="ignoreAssemblyLoadErrors">False if method should return an error when at least one assembly was not loaded correctly (false by default)</param>
            <param name="ignorePathCheckWhenUndefined">Ignore path check when path is undefined (default false).</param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.HashOperation">
            <summary>
            Operations on Hash
            </summary>
        </member>
        <member name="T:Garnet.server.HashObject">
            <summary>
             Hash Object Class
            </summary>
            <summary>
             Hash - RESP specific operations
            </summary>
        </member>
        <member name="M:Garnet.server.HashObject.#ctor(System.Int64)">
            <summary>
             Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.HashObject.#ctor(System.IO.BinaryReader)">
            <summary>
            Construct from binary serialized form
            </summary>
        </member>
        <member name="M:Garnet.server.HashObject.#ctor(System.Collections.Generic.Dictionary{System.Byte[],System.Byte[]},System.Collections.Generic.Dictionary{System.Byte[],System.Int64},System.Collections.Generic.PriorityQueue{System.Byte[],System.Int64},System.Int64,System.Int64)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="P:Garnet.server.HashObject.Type">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.HashObject.DoSerialize(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.HashObject.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.HashObject.Clone">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.HashObject.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.HashObject.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.CollectionItemBroker">
            <summary>
            This class brokers collection items for blocking operations.
            When a supported blocking command is initiated, RespServerSession will call the GetCollectionItemAsync method
            with the desired object type and operation and a list of keys to the desired objects.
            When an item is added to a collection, the StorageSession will call the Publish method with the relevant object key
            to notify the broker that a new item may be available.
            The main loop, in the Start method, listens for published item additions as well as new observers
            and notifies the calling method if an item was found.
            </summary>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.#ctor">
            <summary>
            Constructor for CollectionItemBroker
            </summary>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.TryGetObserver(System.Int32,Garnet.server.CollectionItemObserver@)">
            <summary>
            Tries to get the observer associated with the given session ID.
            </summary>
            <param name="sessionId">The ID of the session to retrieve the observer for.</param>
            <param name="observer">When this method returns, contains the observer associated with the specified session ID, if the session ID is found; otherwise, null. This parameter is passed uninitialized.</param>
            <returns>true if the observer is found; otherwise, false.</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.GetCollectionItemAsync(Garnet.server.RespCommand,System.Byte[][],Garnet.server.RespServerSession,System.Double,Garnet.server.ArgSlice[])">
            <summary>
            Asynchronously wait for item from collection object
            </summary>
            <param name="command">RESP command</param>
            <param name="keys">Keys of objects to observe</param>
            <param name="session">Calling session instance</param>
            <param name="timeoutInSeconds">Timeout of operation (in seconds, 0 for waiting indefinitely)</param>
            <param name="cmdArgs">Additional arguments for command</param>
            <returns>Result of operation</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.MoveCollectionItemAsync(Garnet.server.RespCommand,System.Byte[],Garnet.server.RespServerSession,System.Double,Garnet.server.ArgSlice[])">
            <summary>
            Asynchronously wait for item from collection object at srcKey and
            atomically add it to collection at dstKey
            </summary>
            <param name="command">RESP command</param>
            <param name="srcKey">Key of the object to observe</param>
            <param name="session">Calling session instance</param>
            <param name="timeoutInSeconds">Timeout of operation (in seconds, 0 for waiting indefinitely)</param>
            <param name="cmdArgs">Additional arguments for command</param>
            <returns>Result of operation</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.HandleCollectionUpdate(System.Byte[])">
            <summary>
            Notify broker that an item was added to a collection object in specified key
            </summary>
            <param name="key">Key of the updated collection object</param>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.HandleSessionDisposed(Garnet.server.RespServerSession)">
            <summary>
            Notify broker that a RespServerSession object is being disposed
            </summary>
            <param name="session">The disposed session</param>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.HandleBrokerEvent(Garnet.server.CollectionItemBrokerEvent@)">
            <summary>
            Calls the appropriate method based on the broker event type
            </summary>
            <param name="brokerEvent">Event to handle</param>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.InitializeObserver(Garnet.server.CollectionItemObserver,System.Byte[][])">
            <summary>
            Handles a new observer
            </summary>
            <param name="observer">The new observer instance</param>
            <param name="keys">Keys observed by the new observer</param>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.TryAssignItemFromKey(System.Byte[])">
            <summary>
            Try to assign item available (if exists) with next ready observer in queue
            </summary>
            <param name="key">Key</param>
            <returns>True if successful in assigning item</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.TryGetNextListItem(Garnet.server.ListObject,Garnet.server.RespCommand,System.Byte[]@)">
            <summary>
            Try to get next available item from list object
            </summary>
            <param name="listObj">List object</param>
            <param name="command">RESP command</param>
            <param name="nextItem">Item retrieved</param>
            <returns>True if found available item</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.TryGetNextSortedSetItem(System.Byte[],Garnet.server.SortedSetObject,System.Int32,Garnet.server.RespCommand,Garnet.server.ArgSlice[],Garnet.server.CollectionItemResult@)">
            <summary>
            Try to get next available item from sorted set object based on command type
            BZPOPMIN and BZPOPMAX share same implementation since Dictionary.First() and Last() 
            handle the ordering automatically based on sorted set scores
            </summary>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.Start">
            <summary>
            Broker's main loop logic
            </summary>
            <returns>Task</returns>
        </member>
        <member name="M:Garnet.server.CollectionItemBroker.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.CollectionItemBrokerEventType">
            <summary>
            Event types handled by CollectionItemBroker
            </summary>
        </member>
        <member name="T:Garnet.server.CollectionItemBrokerEvent">
            <summary>
            Struct that holds data for different event types handled by CollectionItemBroker
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemBrokerEvent.Key">
            <summary>
            Key of updated collection (for a CollectionUpdated event)
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemBrokerEvent.Keys">
            <summary>
            The keys that the observer requests to subscribe on (for a NewObserver event)
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemBrokerEvent.Observer">
            <summary>
            The new observer instance (for a NewObserver event)
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemBrokerEvent.EventType">
            <summary>
            The type of event represented
            </summary>
        </member>
        <member name="M:Garnet.server.CollectionItemBrokerEvent.CreateCollectionUpdatedEvent(System.Byte[])">
            <summary>
            Creates a CollectionUpdated event
            </summary>
            <param name="key">Key of updated collection</param>
        </member>
        <member name="M:Garnet.server.CollectionItemBrokerEvent.CreateNewObserverEvent(Garnet.server.CollectionItemObserver,System.Byte[][])">
            <summary>
            Creates a NewObserver event
            </summary>
            <param name="observer">The new observer instance</param>
            <param name="keys">The keys that the observer requests to subscribe on</param>
        </member>
        <member name="T:Garnet.server.CollectionItemObserver">
            <summary>
            This class defines an observer for a specific blocking command
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.Session">
            <summary>
            The session in which the blocking command was called
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.Command">
            <summary>
            The command type for the blocking command
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.CommandArgs">
            <summary>
            Additional arguments for the command
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.Status">
            <summary>
            Status of the observer
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.Result">
            <summary>
            Result of the observer
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemObserver.ObserverStatusLock">
            <summary>
            Lock for the status of the observer
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.ResultFoundSemaphore">
            <summary>
            Semaphore to notify the ResultSet status
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemObserver.CancellationTokenSource">
            <summary>
            Cancellation token to signal the semaphore awaiter to stop
            </summary>
        </member>
        <member name="M:Garnet.server.CollectionItemObserver.HandleSetResult(Garnet.server.CollectionItemResult,System.Boolean)">
            <summary>
            Safely set the result for the observer
            </summary>
            <param name="result"></param>
            <param name="isWriteLocked">True if the ObserverStatusLock was write locked by the caller</param>
        </member>
        <member name="M:Garnet.server.CollectionItemObserver.HandleSessionDisposed">
            <summary>
            Safely set the status of the observer to reflect that its calling session was disposed
            </summary>
        </member>
        <member name="T:Garnet.server.CollectionItemResult">
            <summary>
            Result of item retrieved from observed collection
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Found">
            <summary>
            True if item was found
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Key">
            <summary>
            Key of collection from which item was retrieved
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Item">
            <summary>
            Item retrieved from collection
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Score">
            <summary>
            Score associated with the item retrieved from the collection
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Items">
            <summary>
            Item retrieved from collection
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.Scores">
            <summary>
            Scores associated with the items retrieved from the collection
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.IsForceUnblocked">
            <summary>
            Gets a value indicating whether the item retrieval was force unblocked.
            </summary>
        </member>
        <member name="P:Garnet.server.CollectionItemResult.IsTypeMismatch">
            <summary>
            Gets a value indicating whether the item retrieval returned a type mismatch.
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemResult.Empty">
            <summary>
            Instance of empty result
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemResult.ForceUnblocked">
            <summary>
            Instance representing a Force Unblocked result.
            </summary>
        </member>
        <member name="F:Garnet.server.CollectionItemResult.TypeMismatch">
            <summary>
            Instance representing a Type Mismatch result.
            </summary>
        </member>
        <member name="T:Garnet.server.ListOperation">
            <summary>
            Operations on SortedSet
            </summary>
        </member>
        <member name="T:Garnet.server.OperationDirection">
            <summary>
            Direction for the List operations
            </summary>
        </member>
        <member name="F:Garnet.server.OperationDirection.Left">
            <summary>
            Left or head
            </summary>
        </member>
        <member name="F:Garnet.server.OperationDirection.Right">
            <summary>
            Right or tail
            </summary>
        </member>
        <member name="T:Garnet.server.ListObject">
            <summary>
            List
            </summary>
            <summary>
            List - RESP specific operations
            </summary>
        </member>
        <member name="M:Garnet.server.ListObject.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.ListObject.#ctor(System.IO.BinaryReader)">
            <summary>
            Construct from binary serialized form
            </summary>
        </member>
        <member name="M:Garnet.server.ListObject.#ctor(System.Collections.Generic.LinkedList{System.Byte[]},System.Int64,System.Int64)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="P:Garnet.server.ListObject.Type">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.ListObject.LnkList">
            <summary>
            Public getter for the list
            </summary>
        </member>
        <member name="M:Garnet.server.ListObject.DoSerialize(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ListObject.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ListObject.Clone">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ListObject.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ListObject.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.LinkedListHelper">
            <summary>
            Extensions methods for LinkedList
            </summary>
        </member>
        <member name="M:Garnet.server.LinkedListHelper.Nodes``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Extension method that gets an enumerable to compare the value of each node
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.SetOperation">
            <summary>
            Operations on Set
            </summary>
        </member>
        <member name="T:Garnet.server.SetObject">
            <summary>
             Set Object Class
            </summary>
            <summary>
             Set - RESP specific operations
            </summary>
        </member>
        <member name="M:Garnet.server.SetObject.#ctor(System.Int64)">
            <summary>
             Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.SetObject.#ctor(System.IO.BinaryReader)">
            <summary>
            Construct from binary serialized form
            </summary>
        </member>
        <member name="M:Garnet.server.SetObject.#ctor(System.Collections.Generic.HashSet{System.Byte[]},System.Int64,System.Int64)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="P:Garnet.server.SetObject.Type">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SetObject.DoSerialize(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SetObject.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SetObject.Clone">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SetObject.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SetObject.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="F:Garnet.server.SortedSetComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Garnet.server.SortedSetComparer.Compare(System.ValueTuple{System.Double,System.Byte[]},System.ValueTuple{System.Double,System.Byte[]})">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.GeoHash">
            <summary>
            Encoding and decoding methods for Geospatial
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.LongitudeMin">
            <summary>
            Minimum allowed longitude.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.LongitudeMax">
            <summary>
            Maximum allowed longitude.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.LatitudeMin">
            <summary>
            Minimum allowed latitude.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.LatitudeMax">
            <summary>
            Maximum allowed latitude.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.BitsOfPrecision">
            <summary>
            The number of bits used for the precision of the geohash.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoHash.CodeLength">
            <summary>
            The length of the geohash "standard textual representation".
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.GeoToLongValue(System.Double,System.Double)">
            <summary>
            Encodes the tuple of (<paramref name="latitude"/>, <paramref name="longitude"/>) coordinates to a unique 52-bit integer
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.GetCoordinatesFromLong(System.Int64)">
            <summary>
            Gets pair (latitude, longitude) of GPS coordinates
            latitude comes before longitude in the ISO 6709 standard
            https://en.wikipedia.org/wiki/ISO_6709#Order,_sign,_and_units
            Latitude refers to the Y-values and are between -90 and +90 degrees.
            Longitude refers to the X-coordinates and are between -180 and +180 degrees.
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.MortonEncode(System.UInt32,System.UInt32)">
            <summary>
            Encodes the given x- and y-coordinates into a single 64-bit value using Morton encoding (also known as Z-order curve).
            <para />
            This is essentially a bit interleaving where <paramref name="x"/> and <paramref name="y"/> are "spread" on even and odd bits respectively.
            </summary>
            <param name="x">The x-coordinate to encode.</param>
            <param name="y">The y-coordinate to encode.</param>
            <returns>
            A 64-bit value representing the Morton encoding of the given coordinates.
            i.e. in binary representation, for:
            <code>
            x = xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
            y = yyyyyyyy yyyyyyyy yyyyyyyy yyyyyyyy
            </code>
            Method returns:
            <code>
            yxyxyxyx yxyxyxyx yxyxyxyx yxyxyxyx
            yxyxyxyx yxyxyxyx yxyxyxyx yxyxyxyx
            </code>
            </returns>
        </member>
        <member name="M:Garnet.server.GeoHash.MortonDecode(System.UInt64)">
            <summary>
            Decodes the given 64-bit value into a pair of x- and y-coordinates using Morton decoding (also known as Z-order curve).
            <para />
            This is essentially a bit de-interleaving operation where the even and odd bits of <paramref name="x"/> are "squashed" into separate 32-bit values representing the x- and y-coordinates respectively.
            </summary>
            <param name="x">The 64-bit value to decode.</param>
            <returns>A tuple of 32-bit values representing the x- and y-coordinates decoded from the given Morton code.</returns>
        </member>
        <member name="M:Garnet.server.GeoHash.GetGeoHashCode(System.Int64)">
            <summary>
            Encodes the given integer hash value using base-32 to the "standard textual representation".
            </summary>
            <param name="hash">The 52-bit geohash integer to encode.</param>
            <returns>The standard textual representation of the given 52-bit GeoHash integer</returns>
        </member>
        <member name="M:Garnet.server.GeoHash.Distance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Gets the distance in meters using Haversine Formula
            https://en.wikipedia.org/wiki/Haversine_formula
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.IsPointWithinRadius(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
            Find if a point is within radius of the given center point.
            <paramref name="radius">Radius</paramref>
            <paramref name="latCenterPoint">Center point latitude</paramref>
            <paramref name="lonCenterPoint">Center point longitude</paramref>
            <paramref name="lat">Point latitude</paramref>
            <paramref name="lon">Point longitude</paramref>
            <paramref name="distance">Distance</paramref>
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.GetDistanceWhenInRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
            Find if a point is in the axis-aligned rectangle.
            when the distance between the searched point and the center point is less than or equal to 
            height/2 or width/2,
            the point is in the rectangle.
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.GetGeoErrorByPrecision">
            <summary>
            Calculates the error in latitude and longitude based on <see cref="F:Garnet.server.GeoHash.BitsOfPrecision">the number of bits used for precision</see>.
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.ConvertValueToMeters(System.Double,Garnet.server.GeoDistanceUnitType)">
            <summary>
            Helper to convert kilometers, feet, or miles to meters.
            </summary>
        </member>
        <member name="M:Garnet.server.GeoHash.ConvertMetersToUnits(System.Double,Garnet.server.GeoDistanceUnitType)">
            <summary>
            Helper to convert meters to kilometers, feet, or miles
            </summary>
        </member>
        <member name="T:Garnet.server.GeoDistanceUnitType">
            <summary>
            Distance Unit for GeoSearch
            </summary>
        </member>
        <member name="F:Garnet.server.GeoDistanceUnitType.M">
            <summary>
            Meters
            </summary>
        </member>
        <member name="F:Garnet.server.GeoDistanceUnitType.KM">
            <summary>
            Kilometers
            </summary>
        </member>
        <member name="F:Garnet.server.GeoDistanceUnitType.MI">
            <summary>
            Miles
            </summary>
        </member>
        <member name="F:Garnet.server.GeoDistanceUnitType.FT">
            <summary>
            Foot
            </summary>
        </member>
        <member name="T:Garnet.server.GeoOrder">
            <summary>
            The direction in which to sequence elements.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOrder.None">
            <summary>
            No defined order.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOrder.Ascending">
            <summary>
            Order from low values to high values.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOrder.Descending">
            <summary>
            Order from high values to low values.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOriginType.Undefined">
            <summary>
            Not defined.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOriginType.FromLonLat">
            <summary>
            From explicit lon lat coordinates.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoOriginType.FromMember">
            <summary>
            From member key
            </summary>
        </member>
        <member name="T:Garnet.server.GeoSearchType">
            <summary>
            Type of GeoSearch
            </summary>
        </member>
        <member name="F:Garnet.server.GeoSearchType.Undefined">
            <summary>
            No defined order.
            </summary>
        </member>
        <member name="F:Garnet.server.GeoSearchType.ByRadius">
            <summary>
            Search inside circular area
            </summary>
        </member>
        <member name="F:Garnet.server.GeoSearchType.ByBox">
            <summary>
            Search inside an axis-aligned rectangle
            </summary>
        </member>
        <member name="T:Garnet.server.GeoSearchOptions">
            <summary>
            Small struct to store options for GEOSEARCH command
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetObject">
            <summary>
            Sorted Set - RESP specific operations for GEO Commands
            </summary>
            <summary>
            Sorted Set
            </summary>
            <summary>
            Sorted Set - RESP specific operations
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetObject.GeoSearchData">
            <summary>
            Use this struct for the reply of GEOSEARCH command
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.#ctor(System.IO.BinaryReader)">
            <summary>
            Construct from binary serialized form
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.#ctor(Garnet.server.SortedSetObject)">
            <summary>
            Copy constructor
            </summary>
        </member>
        <member name="P:Garnet.server.SortedSetObject.Type">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.SortedSetObject.Dictionary">
            <summary>
            Get sorted set as a dictionary.
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.DoSerialize(System.IO.BinaryWriter)">
            <summary>
            Serialize
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.Add(System.Byte[],System.Double)">
            <summary>
            Add to SortedSet
            </summary>
            <param name="item"></param>
            <param name="score"></param>
        </member>
        <member name="M:Garnet.server.SortedSetObject.Equals(Garnet.server.SortedSetObject)">
            <summary>
            Check for equality
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SortedSetObject.Clone">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SortedSetObject.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SortedSetObject.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SortedSetObject.CopyDiff(Garnet.server.SortedSetObject,Garnet.server.SortedSetObject)">
            <summary>
            Compute difference of two dictionaries, with new result
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.InPlaceDiff(System.Collections.Generic.Dictionary{System.Byte[],System.Double},Garnet.server.SortedSetObject)">
            <summary>
            Remove keys existing in second dictionary, from the first dictionary, if they exist
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.TryGetScore(System.Byte[],System.Double@)">
            <summary>
            Tries to get the score of the specified key.
            </summary>
            <param name="key">The key to get the score for.</param>
            <param name="value">The score of the key if found.</param>
            <returns>True if the key is found and not expired; otherwise, false.</returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.Count">
            <summary>
            Gets the count of elements in the sorted set.
            </summary>
            <returns>The count of elements in the sorted set.</returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.IsExpired(System.Byte[])">
            <summary>
            Determines whether the specified key is expired.
            </summary>
            <param name="key">The key to check for expiration.</param>
            <returns>True if the key is expired; otherwise, false.</returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.HasExpirableItems">
            <summary>
            Determines whether the sorted set has expirable items.
            </summary>
            <returns>True if the sorted set has expirable items; otherwise, false.</returns>
        </member>
        <member name="T:Garnet.server.SortedSetObject.SortedSetExpireResult">
            <summary>
            Result of an expiration operation.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetObject.SortedSetExpireResult.KeyNotFound">
            <summary>
            The key was not found.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetObject.SortedSetExpireResult.ExpireConditionNotMet">
            <summary>
            The expiration condition was not met.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetObject.SortedSetExpireResult.ExpireUpdated">
            <summary>
            The expiration was updated.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetObject.SortedSetExpireResult.KeyAlreadyExpired">
            <summary>
            The key was already expired.
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetObject.ZRangeOptions">
            <summary>
            Small struct to store options for ZRange command
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.SortedSetRank(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Boolean)">
            <summary>
            Gets the rank of a member of the sorted set
            in ascending or descending order
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="ascending"></param>
        </member>
        <member name="M:Garnet.server.SortedSetObject.PopMinOrMax(System.Boolean)">
            <summary>
            Removes and returns the element with the highest or lowest score from the sorted set.
            </summary>
            <param name="popMaxScoreElement">If true, pops the element with the highest score; otherwise, pops the element with the lowest score.</param>
            <returns>A tuple containing the score and the element as a byte array.</returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.SortedSetPopMinOrMaxCount(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,Garnet.server.SortedSetOperation)">
            <summary>
            Removes and returns up to COUNT members with the low or high score
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="op"></param>
        </member>
        <member name="M:Garnet.server.SortedSetObject.GetElementsInRangeByLex(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean,System.Boolean,System.Int32@,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Gets the elements that belong to the Range using lexicographical order
            </summary>
            <param name="minParamByteArray"></param>
            <param name="maxParamByteArray"></param>
            <param name="doReverse">Perfom reverse order</param>
            <param name="validLimit">Use a limit offset count</param>
            <param name="rem">Remove elements</param>
            <param name="errorCode">errorCode</param>
            <param name="limit">offset and count values</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.GetElementsInRangeByScore(System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Gets a range of elements using by score filters, when
            rem flag is true, removes the elements in the range
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <param name="minExclusive"></param>
            <param name="maxExclusive"></param>
            <param name="withScore"></param>
            <param name="doReverse"></param>
            <param name="validLimit"></param>
            <param name="rem"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SortedSetObject.TryParseParameter(System.ReadOnlySpan{System.Byte},System.Double@,System.Boolean@)">
            <summary>
            Helper method to parse parameters min and max and exclusions
            in commands including +inf -inf
            </summary>
        </member>
        <member name="M:Garnet.server.SortedSetObject.TryParseLexParameter(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte}@,System.Boolean@,Garnet.server.SortedSetObject.SpecialRanges@)">
            <summary>
            Helper method to parse parameter when using Lexicographical ranges
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetOperation">
            <summary>
            Operations on SortedSet
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetRangeOpts">
            <summary>
            Options for specifying the range in sorted set operations.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.None">
            <summary>
            No options specified.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.ByScore">
            <summary>
            Range by score.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.ByLex">
            <summary>
            Range by lexicographical order.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.Reverse">
            <summary>
            Reverse the range order.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.Store">
            <summary>
            Store the result.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetRangeOpts.WithScores">
            <summary>
            Include scores in the result.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.XX">
            <summary>
            Only update elements that already exist. Don't add new elements.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.NX">
            <summary>
            Only add new elements. Don't update already existing elements.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.LT">
            <summary>
            Only update existing elements if the new score is less than the current score.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.GT">
            <summary>
            Only update existing elements if the new score is greater than the current score.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.CH">
            <summary>
            Modify the return value from the number of new elements added, to the total number of elements changed.
            Changed elements are new elements added and elements already existing for which the score was updated.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAddOption.INCR">
            <summary>
            When this option is specified ZADD acts like ZINCRBY. Only one score-element pair can be specified in this mode.
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetOrderOperation">
            <summary>
            Order variations for sorted set commands
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetOrderOperation.ByRank">
            <summary>
            Rank(by index of the elements)
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetOrderOperation.ByScore">
            <summary>
            Score ordering
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetOrderOperation.ByLex">
            <summary>
            Lexicographical ordering (relies on all elements having the same score).
            </summary>
        </member>
        <member name="T:Garnet.server.ByteArrayBinaryObjectSerializer">
            <summary>
            Byte array serializer
            </summary>
        </member>
        <member name="M:Garnet.server.ByteArrayBinaryObjectSerializer.Deserialize(System.Byte[]@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ByteArrayBinaryObjectSerializer.Serialize(System.Byte[]@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.GarnetObject">
            <summary>
            Extensions
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetObject.Create(Garnet.server.GarnetObjectType,System.Int64)">
            <summary>
            Create initial value of object
            </summary>
            <param name="garnetObjectType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetObject.NeedToCreate(Garnet.server.RespInputHeader)">
            <summary>
            Check if object creation is necessary
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.GarnetObjectBase">
            <summary>
            Base class for Garnet heap objects
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetObjectBase.Type">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.GarnetObjectBase.Expiration">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.GarnetObjectBase.Size">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Serialize(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.CopyUpdate(Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Clone">
            <summary>
            Clone object (shallow copy)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.DoSerialize(System.IO.BinaryWriter)">
            <summary>
            Serialize to given writer
            NOTE: Make sure to first call base.DoSerialize(writer) in all derived classes.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <summary>
            Scan the items of the collection
            </summary>
            <param name="start">Shift the scan to this index</param>
            <param name="items">The matching items in the collection</param>
            <param name="cursor">The cursor in the current page</param>
            <param name="count">The number of items being taken in one iteration</param>
            <param name="pattern">A patter used to match the members of the collection</param>
            <param name="patternLength">The number of characters in the pattern</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.Scan(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte)">
            <summary>
            Implement Scan command
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="respProtocolVersion"></param>
        </member>
        <member name="M:Garnet.server.GarnetObjectBase.ReadScanInput(Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@,System.Int64@,System.Byte*@,System.Int32@,System.Int32@,System.Boolean@,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Reads and parses scan parameters from RESP format
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="cursorInput"></param>
            <param name="pattern"></param>
            <param name="patternLength"></param>
            <param name="countInInput"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.GarnetObjectSerializer">
            <summary>
            Serializer for IGarnetObject
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetObjectSerializer.#ctor(Garnet.server.CustomCommandManager)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetObjectSerializer.Deserialize(Garnet.server.IGarnetObject@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectSerializer.Deserialize(System.Byte[])">
            <summary>Thread-safe version of Deserialize</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetObjectSerializer.Serialize(Garnet.server.IGarnetObject@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetObjectSerializer.Serialize(Garnet.server.IGarnetObject)">
            <summary>Thread safe version of Serialize.</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ObjectStoreOutputFlags">
            <summary>
            Flags for object store outputs.
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectStoreOutputFlags.None">
            <summary>
            No flags set
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectStoreOutputFlags.RemoveKey">
            <summary>
            Remove key
            </summary>
        </member>
        <member name="F:Garnet.server.ObjectStoreOutputFlags.WrongType">
            <summary>
            Wrong type of object
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetObjectStoreOutput">
            <summary>
            Output type used by Garnet object store.
            Any field / property added to this struct must be set in the back-end (IFunctions) and used in the front-end (GarnetApi caller).
            That is in order to justify transferring data in this struct through the Tsavorite storage layer.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectStoreOutput.SpanByteAndMemory">
            <summary>
            Span byte and memory
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectStoreOutput.GarnetObject">
            <summary>
            Garnet object
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectStoreOutput.Header">
            <summary>
            Object header
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectStoreOutput.OutputFlags">
            <summary>
            Output flags
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetObjectStoreOutput.HasWrongType">
            <summary>
            True if output flag WrongType is set
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetObjectStoreOutput.HasRemoveKey">
            <summary>
            True if output flag RemoveKey is set
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetObjectType">
            <summary>
            Type of Garnet object
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Null">
            <summary>
            Null type
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.SortedSet">
            <summary>
            Sorted set
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.List">
            <summary>
            List
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Hash">
            <summary>
            Hash
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Set">
            <summary>
            Set
            </summary>        
        </member>
        <member name="F:Garnet.server.GarnetObjectType.DelIfExpIm">
            <summary>
            Special type indicating DELIFEXPIM command, a conditional deletion when a key is in memory and expired
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.PExpire">
            <summary>
            Special type indicating PEXPIRE command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.ExpireTime">
            <summary>
            Special type indicating EXPIRETIME command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.PExpireTime">
            <summary>
            Special type indicating PEXPIRETIME command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.All">
            <summary>
            Indicating a Custom Object command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.PTtl">
            <summary>
            Special type indicating PTTL command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Persist">
            <summary>
            Special type indicating PERSIST command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Ttl">
            <summary>
            Special type indicating TTL command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetObjectType.Expire">
            <summary>
            Special type indicating EXPIRE command
            </summary>
        </member>
        <member name="T:Garnet.server.IGarnetObject">
            <summary>
            Interface representing Garnet object
            </summary>
        </member>
        <member name="P:Garnet.server.IGarnetObject.Type">
            <summary>
            Type of object
            </summary>
        </member>
        <member name="P:Garnet.server.IGarnetObject.Expiration">
            <summary>
            Expiration time of object
            </summary>
        </member>
        <member name="P:Garnet.server.IGarnetObject.Size">
            <summary>
            Total memory size of the object
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetObject.Operate(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Byte,System.Int64@)">
            <summary>
            Operator on object
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="sizeChange"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetObject.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializer
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetObject.CopyUpdate(Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,System.Boolean)">
            <summary>
            Copy update
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetObject.Scan(System.Int64,System.Collections.Generic.List{System.Byte[]}@,System.Int64@,System.Int32,System.Byte*,System.Int32,System.Boolean)">
            <summary>
            Scan the items of the collection
            </summary>
            <param name="start">Shift the scan to this index</param>
            <param name="items">The matching items in the collection</param>
            <param name="cursor">The cursor in the current page</param>
            <param name="count">The number of items being taken in one iteration</param>
            <param name="pattern">A patter used to match the members of the collection</param>
            <param name="patternLength">The number of characters in the pattern</param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.OperationError">
            <summary>
            Operation error type
            </summary>
        </member>
        <member name="F:Garnet.server.OperationError.SUCCESS">
            <summary>
            Operation on data type succeeded
            </summary>
        </member>
        <member name="F:Garnet.server.OperationError.INVALID_TYPE">
            <summary>
            Operation failed due to incompatible type
            </summary>
        </member>
        <member name="F:Garnet.server.OperationError.NAN_OR_INFINITY">
            <summary>
            Operation failed due to NaN/infinity
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetProvider">
            <summary>
            Session provider for Garnet, based on
            [K, V, I, O, C] = [SpanByte, SpanByte, SpanByte, SpanByteAndMemory, long]
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetProvider.StoreWrapper">
            <summary>
            StoreWrapper
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetProvider.#ctor(Garnet.server.StoreWrapper,Garnet.server.SubscribeBroker,Garnet.networking.MaxSizeSettings)">
            <summary>
            Create SpanByte TsavoriteKV backend for Garnet
            </summary>
            <param name="storeWrapper"></param>
            <param name="broker"></param>
            <param name="maxSizeSettings"></param>        
        </member>
        <member name="M:Garnet.server.GarnetProvider.Start">
            <summary>
            Start
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetProvider.Recover">
            <summary>
            Recover
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetProvider.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetProvider.GetFunctions">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetProvider.GetSession(Garnet.networking.WireFormat,Garnet.networking.INetworkSender)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.TsavoriteKVProviderBase`8">
            <summary>
            Abstract session provider for TsavoriteKV store based on
            [K, V, I, O, F, P]
            </summary>
        </member>
        <member name="F:Garnet.server.TsavoriteKVProviderBase`8.store">
            <summary>
            Store
            </summary>
        </member>
        <member name="F:Garnet.server.TsavoriteKVProviderBase`8.serializer">
            <summary>
            Serializer
            </summary>
        </member>
        <member name="F:Garnet.server.TsavoriteKVProviderBase`8.broker">
            <summary>
            Broker
            </summary>
        </member>
        <member name="F:Garnet.server.TsavoriteKVProviderBase`8.maxSizeSettings">
            <summary>
            Size settings
            </summary>
        </member>
        <member name="M:Garnet.server.TsavoriteKVProviderBase`8.#ctor(`7,Garnet.server.SubscribeBroker,Garnet.networking.MaxSizeSettings)">
            <summary>
            Create TsavoriteKV backend
            </summary>
            <param name="serializer"></param>
            <param name="broker"></param>
            <param name="maxSizeSettings"></param>
        </member>
        <member name="P:Garnet.server.TsavoriteKVProviderBase`8.GetMaxSizeSettings">
            <summary>
            Get MaxSizeSettings
            </summary>
        </member>
        <member name="M:Garnet.server.TsavoriteKVProviderBase`8.GetFunctions">
            <summary>
            GetFunctions() for custom functions provided by the client
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TsavoriteKVProviderBase`8.GetSession(Garnet.networking.WireFormat,Garnet.networking.INetworkSender)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.PatternSubscriptionEntry">
            <summary>
            Entry in the table of pattern subscriptions.
            </summary>
        </member>
        <member name="F:Garnet.server.PatternSubscriptionEntry.pattern">
            <summary>
            The pattern to which the subscriptions are subscribed.
            </summary>
        </member>
        <member name="F:Garnet.server.PatternSubscriptionEntry.subscriptions">
            <summary>
            The set of subscriptions.
            </summary>
        </member>
        <member name="T:Garnet.server.SubscribeBroker">
            <summary>
            Broker used for pub/sub
            </summary>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.#ctor(System.String,System.Int64,System.Int32,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
            <param name="logDir">Directory where the log will be stored</param>
            <param name="pageSize">Page size of log used for pub/sub</param>
            <param name="subscriberRefreshFrequencyMs">Subscriber log refresh frequency</param>
            <param name="startFresh">start the log from scratch, do not continue</param>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.RemoveSubscription(Garnet.networking.IMessageConsumer)">
            <summary>
            Remove all subscriptions for a session,
            called during dispose of server session
            </summary>
            <param name="session">server session</param>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.Subscribe(Garnet.server.ArgSlice,Garnet.server.ServerSessionBase)">
            <summary>
            Subscribe to a particular Key
            </summary>
            <param name="key">Key to subscribe to</param>
            <param name="session">Server session</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.PatternSubscribe(Garnet.server.ArgSlice,Garnet.server.ServerSessionBase)">
            <summary>
            Subscribe to a particular pattern
            </summary>
            <param name="pattern">Pattern to subscribe to</param>
            <param name="session">Server session</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.Unsubscribe(Garnet.server.ByteArrayWrapper,Garnet.server.ServerSessionBase)">
            <summary>
            Unsubscribe to a particular key
            </summary>
            <param name="key">Key to subscribe to</param>
            <param name="session">Server session</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.PatternUnsubscribe(Garnet.server.ByteArrayWrapper,Garnet.server.ServerSessionBase)">
            <summary>
            Unsubscribe to a particular pattern
            </summary>
            <param name="key">Pattern to subscribe to</param>
            <param name="session">Server session</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.ListAllSubscriptions(Garnet.server.ServerSessionBase)">
            <summary>
            List all subscriptions made by a session
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.ListAllPatternSubscriptions(Garnet.server.ServerSessionBase)">
            <summary>
            List all pattern subscriptions made by a session
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.PublishNow(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Publish the update made to key to all the subscribers, synchronously
            </summary>
            <param name="key">key that has been updated</param>
            <param name="value">value that has been updated</param>
            <returns>Number of subscribers notified</returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.Publish(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Publish the update made to key to all the subscribers, asynchronously
            </summary>
            <param name="key">key that has been updated</param>
            <param name="value">value that has been updated</param>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.GetChannels">
            <summary>
            Get the number of channels subscribed to
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.GetChannels(Garnet.server.ArgSlice)">
            <summary>
            Get the number of channels subscribed to, matching the given pattern
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.NumPatternSubscriptions">
            <summary>
            Retrieves the number of pattern subscriptions.
            </summary>
            <returns>The number of pattern subscriptions.</returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.NumSubscriptions(Garnet.server.ArgSlice)">
            <summary>
            Retrieves the number of subscriptions for a given channel.
            </summary>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SubscribeBroker.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.BitmapOperation">
             (1) , (2) , (3) 
            overflow check, ptr protection, and status not found implemented for below
            GETBIT, SETBIT, BITCOUNT, BITPOS (1),(2)
        </member>
        <member name="F:Garnet.server.BitmapOperation.NONE">
            <summary>
            NONE
            </summary>
        </member>
        <member name="F:Garnet.server.BitmapOperation.AND">
            <summary>
            AND
            </summary>
        </member>
        <member name="F:Garnet.server.BitmapOperation.OR">
            <summary>
            OR
            </summary>
        </member>
        <member name="F:Garnet.server.BitmapOperation.XOR">
            <summary>
            XOR
            </summary>
        </member>
        <member name="F:Garnet.server.BitmapOperation.NOT">
            <summary>
            NOT
            </summary>
        </member>
        <member name="F:Garnet.server.BitmapOperation.DIFF">
            <summary>
            DIFF
            </summary>
        </member>
        <member name="T:Garnet.server.BitFieldCmdArgs">
            <summary>
            struct with parameters for BITFIELD command
            </summary>
        </member>
        <member name="F:Garnet.server.BitFieldCmdArgs.secondaryCommand">
            <summary>
            BITFIELD command
            </summary>
        </member>
        <member name="F:Garnet.server.BitFieldCmdArgs.typeInfo">
            <summary>
            encoding info
            </summary>
        </member>
        <member name="F:Garnet.server.BitFieldCmdArgs.offset">
            <summary>
            offset
            </summary>
        </member>
        <member name="F:Garnet.server.BitFieldCmdArgs.value">
            <summary>
            value
            </summary>
        </member>
        <member name="F:Garnet.server.BitFieldCmdArgs.overflowType">
            <summary>
            BitFieldOverflow enum 
            </summary>
        </member>
        <member name="M:Garnet.server.BitFieldCmdArgs.#ctor(Garnet.server.RespCommand,System.Byte,System.Int64,System.Int64,System.Byte)">
            <summary>
            add a command to execute in bitfield
            </summary>
            <param name="secondaryCommand"></param>
            <param name="typeInfo"></param>
            <param name="offset"></param>
            <param name="value"></param>
            <param name="overflowType"></param>
        </member>
        <member name="T:Garnet.server.BitmapManager">
            <summary>
            Bitmap management methods
            </summary>
        </member>
        <member name="M:Garnet.server.BitmapManager.IsLargeEnough(System.Int32,System.Int64)">
            <summary>
            Check to see if offset contained by value size
            </summary>
            <param name="vlen"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.Length(System.Int64)">
            <summary>
            Get minimum length from offset in CmdInput
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.NewBlockAllocLength(System.Int32,System.Int64)">
            <summary>
            Get bitmap allocation size
            </summary>
            <param name="valueLen"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.UpdateBitmap(System.Byte*,System.Int64,System.Byte)">
            <summary>
            Update bitmap value from input
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="set"></param>        
        </member>
        <member name="M:Garnet.server.BitmapManager.GetBit(System.Int64,System.Byte*,System.Int32)">
            <summary>
            Get bit value from value ptr at offset specified at offset.
            </summary>
            <param name="offset"></param>
            <param name="value"></param>
            <param name="valLen"></param>        
        </member>
        <member name="M:Garnet.server.BitmapManager.BitIndexCount(System.Byte,System.Int32,System.Int32)">
            <summary>
            Count bits within a byte given start and end offsets.
            </summary>
            <param name="payload">Payload to count bits.</param>
            <param name="startBitOffset">Bit offset to starting counting from.</param>
            <param name="endBitOffset">Bit offset to end counting.</param>
            <returns>Long count of bits set in payload.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitIndexCount(System.Byte*,System.Int64,System.Int64)">
            <summary>
            Count partials bits for case where bit index is used.
            </summary>
            <param name="value">Bitmap value</param>
            <param name="startOffset">Bit starting offset</param>
            <param name="endOffset">Bit end offset</param>
            <returns>Long count of bits set at startOffset and endOffset.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitCountDriver(System.Int64,System.Int64,System.Byte,System.Byte*,System.Int32)">
            <summary>
            Main driver of BitCount Command.
            </summary>
            <param name="offsetType"></param>
            <param name="value">Value containing bits to count.</param>
            <param name="valLen">Value length</param>
            <param name="startOffset"></param>
            <param name="endOffset"></param>
            <returns>Integer count of all bits set to one.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.__scalar_popc(System.Byte*,System.Int64,System.Int64)">
            <summary>
            Scalar population count
            </summary>
            <param name="bitmap">Pointer to start of bitmap.</param>
            <param name="start">Starting offset into bitmap.</param>
            <param name="end">End offset into bitmap.</param>
            <returns>Long count of set bits in bitmap.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.__simd_popcX128(System.Byte*,System.Int64,System.Int64)">
            <summary>
            SIMD population count using 128 wide registers.
            </summary>
            <param name="bitmap">Pointer to start of bitmap.</param>
            <param name="start">Starting offset into bitmap.</param>
            <param name="end">End offset into bitmap.</param>
            <returns>Long count of set bits in bitmap.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.__simd_popcX256(System.Byte*,System.Int64,System.Int64)">
            <summary>
            SIMD population count using 256 wide registers.
            </summary>
            <param name="bitmap">Pointer to start of bitmap.</param>
            <param name="start">Starting offset into bitmap.</param>
            <param name="end">End offset into bitmap.</param>
            <returns>Long count of set bits in bitmap.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.IsLargeEnoughForType(Garnet.server.BitFieldCmdArgs,System.Int32)">
            <summary>
            Check if bitmap is large enough to apply bitfield op.
            </summary>
            <param name="args">Command input parameters.</param>
            <param name="vlen">Length of bitfield value.</param>
            <returns>True if need to grow value otherwise false.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.LengthFromType(Garnet.server.BitFieldCmdArgs)">
            <summary>
            Length in bytes based on offset calculated as raw bit offset or from typeInfo bitCount.
            </summary>
            <param name="args">Command input parameters.</param>
            <returns>Integer number of bytes required to perform bitfield op.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.NewBlockAllocLengthFromType(Garnet.server.BitFieldCmdArgs,System.Int32)">
            <summary>
            Get allocation size for bitfield command.
            </summary>
            <param name="args">Command input parameters.</param>
            <param name="valueLen">Current length of bitfield value.</param>
            <returns>Integer number of bytes required to perform bitfield operation.</returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.CheckBitfieldOverflow(System.Int64,System.Int64,System.Int64@,System.Byte,System.Byte,System.Boolean)">
            <summary>
            Check if bitfield operation will overflow.
            </summary>
            <param name="value"></param>
            <param name="incrBy"></param>
            <param name="result"></param>
            <param name="bitCount"></param>
            <param name="overflowType"></param>
            <param name="signed"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.BitmapManager.GetValue(System.Byte*@,System.Byte*@,System.Byte*,System.Byte*,System.Int64,System.Int64,System.Byte,System.Boolean)">
            <summary>
            Get bitfield value from bitmap
            </summary>
            <param name="buf">Buffer being used to write value into</param>
            <param name="curr">First byte of bitfield value</param>
            <param name="cend">Last byte of bitfield value </param>
            <param name="vend">Last byte of bitfield value bounded by bitmap length</param>
            <param name="bitmapLength">Bitmap length</param>
            <param name="offset">Bit offset for value</param>
            <param name="encoding">Encoding of value</param>
            <param name="signed">Whether the bitfield is signed</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.SetValue(System.Byte*,System.Byte*,System.Byte*,System.Byte*,System.Byte*,System.Int64,System.Int32,System.Int32,System.Int64)">
            <summary>
            Set bitfield value in bitmap
            </summary>
            <param name="buf">Buffer being used to write value into</param>
            <param name="curr">First byte of bitfield value</param>
            <param name="cend">Last byte of bitfield value </param>
            <param name="vend">Last byte of bitfield value bounded by bitmap length</param>
            <param name="bitmap">Bitmap start</param>
            <param name="offset">Bit offset for value</param>
            <param name="encoding">Encoding of value</param>
            <param name="unalignedBits"></param>
            <param name="newValue">New bitfield value</param>
        </member>
        <member name="M:Garnet.server.BitmapManager.GetBitfield(System.Byte*,System.Int64,System.Int64,System.Byte,System.Boolean)">
            <summary>
            Implementation of bitfield GET operation.
            </summary>
            <param name="bitmap"></param>
            <param name="bitmapLength"></param>
            <param name="offset"></param>
            <param name="encoding"></param>
            <param name="signed"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.SetBitfield(System.Byte*,System.Int64,System.Int64,System.Byte,System.Boolean,System.Int64,System.Byte)">
            <summary>
            Implementation of bitfield SET operation.
            </summary>
            <param name="bitmap"></param>
            <param name="bitmapLength"></param>
            <param name="offset"></param>
            <param name="encoding"></param>
            <param name="signed"></param>
            <param name="newValue"></param>
            <param name="overflowType"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.BitmapManager.IncrementBitfield(System.Byte*,System.Int64,System.Int64,System.Byte,System.Boolean,System.Int64,System.Byte)">
            <summary>
            Implementation of bitfield INCR operation.
            </summary>
            <param name="value"></param>
            <param name="valLen"></param>
            <param name="offset"></param>
            <param name="encoding"></param>
            <param name="signed"></param>
            <param name="incrementByValue"></param>
            <param name="overflowType"></param>
            <returns></returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitFieldExecute(Garnet.server.BitFieldCmdArgs,System.Byte*,System.Int32)">
            <summary>
            Execute bitfield operation described at input on bitmap stored within value.
            </summary>
            <param name="args"></param>
            <param name="value"></param>
            <param name="valLen"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitFieldExecute_RO(Garnet.server.BitFieldCmdArgs,System.Byte*,System.Int32)">
            <summary>
            Execute readonly bitfield operation described at input on bitmap stored within value.
            </summary>
            <param name="args"></param>
            <param name="value"></param>
            <param name="valLen"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.InvokeBitOperationUnsafe(Garnet.server.BitmapOperation,System.Int32,System.Byte**,System.Byte**,System.Byte*,System.Int32,System.Int32)">
            <summary>
            Performs a bitwise operation across one or more source buffers and writes the result to the destination buffer.
            </summary>
            <param name="op">The bitwise operation to perform.</param>
            <param name="srcCount">Number of source buffers</param>
            <param name="srcPtrs">Array of pointers to source buffers. The array length must be greater than or equal to <paramref name="srcCount"/></param>
            <param name="srcEndPtrs">Array of the buffer lengths specified in <paramref name="srcPtrs"/>. The array length must be greater than or equal to <paramref name="srcCount"/></param>
            <param name="dstPtr">Destination buffer to write the result.</param>
            <param name="dstLength">Destination buffer length.</param>
            <param name="shortestSrcLength">The length of shortest source buffer.</param>
        </member>
        <member name="M:Garnet.server.BitmapManager.InvokeNaryBitwiseOperation``1(System.Int32,System.Byte**,System.Byte**,System.Byte*,System.Int32,System.Int32)">
            <summary>
            Invokes bitwise binary operation across n-ary source bitmaps.
            </summary>
            <typeparam name="TBinaryOperator">The binary operator type to compute bitwise</typeparam>
            <param name="srcCount">Number of source bitmaps.</param>
            <param name="srcPtrs">Array of pointers to source bitmap buffers.</param>
            <param name="srcEndPtrs">Array of the of pointers pointing to the end of the respective the bitmaps specified in <paramref name="srcPtrs"/>.</param>
            <param name="dstPtr">Destination buffer to write the result.</param>
            <param name="dstLength">Destination buffer length.</param>
            <param name="shortestSrcLength">The length of shortest source buffer.</param>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitPosDriver(System.Byte*,System.Int32,System.Int64,System.Int64,System.Byte,System.Byte)">
            <summary>
            Main driver for BITPOS command
            </summary>
            <param name="input"></param>
            <param name="inputLen"></param>
            <param name="startOffset"></param>
            <param name="endOffset"></param>
            <param name="searchFor"></param>
            <param name="offsetType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitPosBitSearch(System.Byte*,System.Int64,System.Int64,System.Int64,System.Byte)">
            <summary>
            Search for position of bit set in byte array using bit offset for start and end range
            </summary>
            <param name="input"></param>
            <param name="inputLen"></param>
            <param name="startBitOffset"></param>
            <param name="endBitOffset"></param>
            <param name="searchFor"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.BitmapManager.BitPosByteSearch(System.Byte*,System.Int64,System.Int64,System.Int64,System.Byte)">
            <summary>
            Search for position of bit set in byte array using byte offset for start and end range
            </summary>
            <param name="input"></param>
            <param name="inputLen"></param>
            <param name="startOffset"></param>
            <param name="endOffset"></param>
            <param name="searchFor"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ByteArrayComparer">
            <summary>
            Byte array equality comparer
            </summary>
        </member>
        <member name="F:Garnet.server.ByteArrayComparer.Instance">
            <summary>
            The default instance.
            </summary>
            <remarks>Used to avoid allocating new comparers.</remarks>
        </member>
        <member name="M:Garnet.server.ByteArrayComparer.Equals(System.Byte[],System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ByteArrayComparer.GetHashCode(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ByteArrayComparer.Equals(System.ReadOnlySpan{System.Byte},System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.ByteArrayComparer.GetHashCode(System.ReadOnlySpan{System.Byte})">
            <inheritdozc/>
        </member>
        <member name="M:Garnet.server.ByteArrayComparer.Create(System.ReadOnlySpan{System.Byte})">
            <inheritdozc/>
        </member>
        <member name="T:Garnet.server.CmdStrings">
            <summary>
            Command strings for RESP protocol
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.CLIENT">
            <summary>
            Request strings
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.RESP_OK">
            <summary>
            Response strings
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.RESP_ERR_NOAUTH">
            <summary>
            Simple error response strings, i.e. these are of the form "-errorString\r\n"
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.RESP_ERR_GENERIC_UNK_CMD">
            <summary>
            Generic error response strings, i.e. these are of the form "-ERR error message\r\n"
            </summary>
        </member>
        <member name="F:Garnet.server.CmdStrings.GenericErrWrongNumArgs">
            <summary>
            Response string templates
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.RESP_ERR">
            <summary>
            Response errors while scripting
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.ZSET">
            <summary>
            Object types
            </summary>
        </member>
        <member name="P:Garnet.server.CmdStrings.READ">
            <summary>
            Register object types
            </summary>
        </member>
        <member name="T:Garnet.server.GarnetDatabaseSession">
            <summary>
            Represents a logical database session in Garnet
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabaseSession.Id">
            <summary>
            Database ID
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabaseSession.StorageSession">
            <summary>
            Storage session 
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabaseSession.GarnetApi">
            <summary>
            Garnet API
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabaseSession.LockableGarnetApi">
            <summary>
            Lockable Garnet API
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetDatabaseSession.TransactionManager">
            <summary>
            Transaction manager
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetDatabaseSession.Dispose">
            <summary>
            Dispose method
            </summary>
        </member>
        <member name="T:Garnet.server.HLL_DTYPE">
            
             Hyperloglog implementation based on 
             "New cardinality estimation algorithms for HyperLogLog sketches " (https://arxiv.org/abs/1702.01284)
                
            <summary>
            HLL Data structure types
            </summary>
        </member>
        <member name="T:Garnet.server.HyperLogLog">
            <summary>
            Garnet HypperLogLog implementation    
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.hll_header_bytes">
            Dense and Sparse representations have a 16 byte header (additional 2 bytes for Sparse to store length of RLE).
            [HYLL | E | N/U | Cardin]
            HYLL: 4 byte magic string
            E: 1 byte encoding for sparse/dense representation
            N/U: 3 bytes not used
            Cardin: 8 bytes (64 bit int) for previously computed cardinality if data has not changed
        </member>
        <member name="F:Garnet.server.HyperLogLog.DenseBytes">
            <summary>
            How many bytes needed for dense representation
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseMaxBytesPerInsert">
            <summary>
            How many bytes needed per new value added to the hll
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseSizeMaxCap">
            <summary>
            Maximum number of bytes consumed by the sparse representation
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseMemorySectorSize">
            <summary>
            Sparse representation allocation increments
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseZeroRanges">
            <summary>
            Sparse representation initial zero ranges cnt
            </summary>        
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseHeaderSize">
            <summary>
            Sparse header size = hll_header_bytes + RLE current size
            </summary>        
        </member>
        <member name="F:Garnet.server.HyperLogLog.SparseBytes">
            <summary>
            Sparse representation initial number of bytes
            header + sequence length in bytes + default zero sequence data + buffer to grow
            </summary>                
        </member>
        <member name="P:Garnet.server.HyperLogLog.PBit">
            <summary>
            Return bits used for indexing
            </summary>
        </member>
        <member name="P:Garnet.server.HyperLogLog.QBit">
            <summary>
            Return bits used for clz
            </summary>
        </member>
        <member name="F:Garnet.server.HyperLogLog.DefaultHLL">
            <summary>
            Default hyperloglog instance
            </summary>        
        </member>
        <member name="M:Garnet.server.HyperLogLog.#ctor">
            <summary>
            Default Garnet HyperLogLog Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.#ctor(System.Byte)">
            <summary>
            Custom Garnet HyperLogLog Constructor
            </summary>
            <param name="pbit"></param>
        </member>
        <member name="P:Garnet.server.HyperLogLog.RegCnt">
            <summary>
            Get register count for dense HLL representation
            </summary>        
        </member>
        <member name="M:Garnet.server.HyperLogLog.RegIdx(System.Int64)">
            <summary>
            Extract register index
            </summary>
            <param name="hv"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.clz(System.Int64)">
            <summary>
            Count leading zeros
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog._get_register(System.Byte*,System.UInt16)">
            <summary>
            Get register-idx value
            </summary>
            <param name="reg"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog._set_register(System.Byte*,System.UInt16,System.Byte)">
            <summary>
            Set register-idx in register array to val.
            </summary>
            <param name="reg"></param>
            <param name="idx"></param>
            <param name="val"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsValidHYLL(System.Byte*)">
            <summary>
            Check if header is correctly formatted.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsValidHYLL(System.Byte*,System.Int32)">
            <summary>
            Check if value is of type HLL
            </summary>
            <param name="ptr"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsHYLL(System.Byte*)">
            <summary>
            Check if tag is correctly set.
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SetPrefix(System.Byte*)">
            <summary>
            Set prefix HYLL (HYperLogLog)
            </summary>     
        </member>
        <member name="M:Garnet.server.HyperLogLog.GetType(System.Byte*)">
            <summary>
            Extract data structure type from header
            </summary>                
        </member>
        <member name="M:Garnet.server.HyperLogLog.SetType(System.Byte*,System.Byte)">
            <summary>
            Set representation type
            </summary>                
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsSparse(System.Byte*)">
            <summary>
            Check if data structure is sparse from header
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsDense(System.Byte*)">
            <summary>
            Check if data structure is sparse from dense
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SetCard(System.Byte*,System.Int64)">
            <summary>
            Invalidate cached cardinality estimate
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.GetCard(System.Byte*)">
            <summary>
            Get cached cardinality estimate
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.IsValidCard(System.Byte*)">
            <summary>
            Check if previously calculated cardinality has been invalidated by previous update
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.Init(Garnet.server.RawStringInput@,System.Byte*,System.Int32)">
            <summary>
            Initialize HLL data structure
            </summary>
            <param name="input"></param>
            <param name="value"></param>
            <param name="vlen"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.InitSparse(System.Byte*)">
            <summary>
            Initialize sparse blob
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.InitDense(System.Byte*)">
            <summary>
            Initialize dense blob
            </summary>  
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseInitialLength(Garnet.server.RawStringInput@)">
            <summary>
            Initial length for HLL based on inserted value count from input
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseRequiredBytes(System.Int32)">
            <summary>
            Required space allocation for given count of inserted values
            </summary>
            <param name="cnt"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CanGrowInPlace(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Check if allocated space is enough for [count] elements.
            </summary>
            <param name="value"></param>
            <param name="valueLen"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.UpdateGrow(Garnet.server.RawStringInput@,System.Byte*)">
            <summary>
            Return length of new value
            </summary>        
        </member>
        <member name="M:Garnet.server.HyperLogLog.MergeGrow(System.Byte*,System.Byte*)">
            <summary>
            Calculate growth for merge. 
            </summary>
            <param name="srcHLL"></param>
            <param name="dstHLL"></param>        
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CopyUpdateMerge(System.Byte*,System.Byte*,System.Byte*,System.Int32,System.Int32)">
            <summary>
            Merge operation triggered growth. First copy/transform oldHLL to newHLL and then merge srcHLL to newHLL.
            </summary>
            <param name="srcHLLPtr"></param>
            <param name="oldDstHLLPtr"></param>
            <param name="newDstHLLPtr"></param>
            <param name="oldValueLen"></param>
            <param name="newValueLen"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CopyUpdate(Garnet.server.RawStringInput@,System.Byte*,System.Byte*,System.Int32)">
            <summary>
            Main Copy update used for growing sparse to sparse or dense
            </summary>
            <param name="input"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <param name="newValueLen"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseToDenseCopy(System.Int64,System.Byte*,System.Byte*)">
            <summary>
            Copy oldValue (sparse) to newValue (dense) and insert new hash-value (hv)
            </summary>
            <param name="hv"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseToSparseCopy(System.Int64,System.Byte*,System.Byte*)">
            <summary>
            Copy oldValue (sparse) to newValue (sparse) and insert new hash-value (hv)
            </summary>
            <param name="hv"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DenseToDense(System.Byte*,System.Byte*)">
            <summary>
            Merge denseBlobA to denseBlobB
            </summary>
            <param name="srcDenseBlob"></param>
            <param name="dstDenseBlob"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.Update(Garnet.server.RawStringInput@,System.Byte*,System.Int32,System.Boolean@)">
            <summary>
            Main multi value update method
            </summary>
            <param name="input"></param>
            <param name="value"></param>
            <param name="valueLen"></param>
            <param name="updated"></param>
            <returns></returns>           
        </member>
        <member name="M:Garnet.server.HyperLogLog.UpdateDense(System.Byte*,System.Int64)">
            <summary>
            Update dense HypperLogLog structure
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.UpdateSparse(System.Byte*,System.Int64)">
            <summary>
            Update sparse representation
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.UpdateSparseReg(System.Byte*,System.UInt16,System.Byte)">
            <summary>
            Update sparse representation
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.Count(System.Byte*)">
            <summary>
            Main Count HLL method
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CountSparseNCEstimator(System.Byte*)">
            <summary>
            No correction for large values sparse estimator
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CountDenseNCEstimator(System.Byte*)">
            <summary>
            No correction for large values dense estimator
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.TryMerge(System.Byte*,System.Byte*,System.Int32)">
            <summary>
            TryMerge - fails if cannot update in place
            </summary>
            <param name="srcBlob"></param>
            <param name="dstBlob"></param>
            <param name="dstLen"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.Merge(System.Byte*,System.Byte*)">
            <summary>
            Merge hll srcBlob to hll dstBlob
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseToDense(System.Byte*,System.Byte*)">
            <summary>
            Transform sparse hll to dense hll
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseToSparse(System.Byte*,System.Byte*)">
            <summary>
            Merge sparseSrc to SparseDst
            </summary>
            <param name="sparseSrc"></param>
            <param name="sparceDst"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DenseCountNonZero(System.Byte*)">
            <summary>
            Count zeros in dense
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.SparseCountNonZero(System.Byte*)">
            <summary>
            Count zeros in sparse
            </summary>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DumpRawBytes(System.Byte*)">
            <summary>
            Dump HLL structure raw bytes
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.CompareSparseToDense(System.Byte*,System.Byte*)">
            <summary>
            Used for debugging to compare dense and sparse HLL
            </summary>
            <param name="denseHLL"></param>
            <param name="sparseHLL"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DumpRegs(System.Byte*)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DumpDenseRegs(System.Byte*)">
            <summary>
            Dump dense reg contents to console
            </summary>
        </member>
        <member name="M:Garnet.server.HyperLogLog.DumpSparseRegs(System.Byte*,System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Dump sparse reg contents to console
            </summary>
        </member>
        <member name="T:Garnet.server.IRespSerializable">
            <summary>
            Interface to define classes that are serializable to RESP format
            </summary>
        </member>
        <member name="M:Garnet.server.IRespSerializable.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <summary>
            Serializes the current object to RESP format
            </summary>
            <returns>Serialized value in RESP format</returns>
        </member>
        <member name="T:Garnet.server.LocalServerSession">
            <summary>
            Local server session
            </summary>
        </member>
        <member name="F:Garnet.server.LocalServerSession.BasicGarnetApi">
            <summary>
            Basic Garnet API
            </summary>
        </member>
        <member name="M:Garnet.server.LocalServerSession.#ctor(Garnet.server.StoreWrapper)">
            <summary>
            Create new local server session
            </summary>
        </member>
        <member name="M:Garnet.server.LocalServerSession.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.MGetReadArgBatch`1">
            <summary>
            Read batch implementation for <see cref="F:Garnet.server.RespCommand.MGET"/>.
            
            Attempts to write directly to output buffer.
            Blocks if operation would complete asynchronously.
            
            Ref struct on .NET 9+ for efficiency purposes.
            </summary>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.#ctor(`0@,Garnet.server.RespServerSession)">
            <summary>
            Read batch implementation for <see cref="F:Garnet.server.RespCommand.MGET"/>.
            
            Attempts to write directly to output buffer.
            Blocks if operation would complete asynchronously.
            
            Ref struct on .NET 9+ for efficiency purposes.
            </summary>
        </member>
        <member name="P:Garnet.server.MGetReadArgBatch`1.Count">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.GetInput(System.Int32,Garnet.server.RawStringInput@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.GetKey(System.Int32,Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.GetOutput(System.Int32,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.SetStatus(System.Int32,Tsavorite.core.Status)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch`1.SetOutput(System.Int32,Tsavorite.core.SpanByteAndMemory)">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.MGetReadArgBatch_SG">
            <summary>
            Read batch implementation for <see cref="F:Garnet.server.RespCommand.MGET"/> with scatter gather.
            
            For commands that are served entirely out of memory, writes results directly into the output buffer if possible.
            If operation would complete asynchronously, moves onto the next one and buffers results for later writing.
            </summary>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.#ctor(Garnet.server.RespServerSession)">
            <summary>
            Read batch implementation for <see cref="F:Garnet.server.RespCommand.MGET"/> with scatter gather.
            
            For commands that are served entirely out of memory, writes results directly into the output buffer if possible.
            If operation would complete asynchronously, moves onto the next one and buffers results for later writing.
            </summary>
        </member>
        <member name="P:Garnet.server.MGetReadArgBatch_SG.Count">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.GetInput(System.Int32,Garnet.server.RawStringInput@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.GetKey(System.Int32,Tsavorite.core.SpanByte@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.GetOutput(System.Int32,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.SetOutput(System.Int32,Tsavorite.core.SpanByteAndMemory)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.SetStatus(System.Int32,Tsavorite.core.Status)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MGetReadArgBatch_SG.CompletePending``1(``0@)">
            <summary>
            If any operations went async, complete them all and finish writing the results out.
            </summary>
        </member>
        <member name="T:Garnet.server.ParseUtils">
            <summary>
            Utilities for parsing RESP protocol messages.
            </summary>
        </member>
        <member name="M:Garnet.server.ParseUtils.ReadInt(Garnet.server.ArgSlice@)">
            <summary>
            Read a signed 32-bit integer from a given ArgSlice.
            </summary>
            <returns>
            Parsed integer
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.TryReadInt(Garnet.server.ArgSlice@,System.Int32@)">
            <summary>
            Try to read a signed 32-bit integer from a given ArgSlice.
            </summary>
            <returns>
            True if integer read successfully
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.ReadLong(Garnet.server.ArgSlice@)">
            <summary>
            Read a signed 64-bit long from a given ArgSlice.
            </summary>
            <returns>
            Parsed long
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.TryReadLong(Garnet.server.ArgSlice@,System.Int64@)">
            <summary>
            Try to read a signed 64-bit long from a given ArgSlice.
            </summary>
            <returns>
            True if long parsed successfully
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.ReadDouble(Garnet.server.ArgSlice@,System.Boolean)">
            <summary>
            Read a signed 64-bit double from a given ArgSlice.
            </summary>
            <param name="slice">Source</param>
            <param name="canBeInfinite">Allow reading an infinity</param>
            <returns>
            Parsed double
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.TryReadDouble(Garnet.server.ArgSlice@,System.Double@,System.Boolean)">
            <summary>
            Try to read a signed 64-bit double from a given ArgSlice.
            </summary>
            <param name="slice">Source</param>
            <param name="number">Result</param>
            <param name="canBeInfinite">Allow reading an infinity</param>
            <returns>
            True if double parsed successfully
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.ReadString(Garnet.server.ArgSlice@)">
            <summary>
            Read an ASCII string from a given ArgSlice.
            </summary>
            <returns>
            Parsed string
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.ReadBool(Garnet.server.ArgSlice@)">
            <summary>
            Read a boolean from a given ArgSlice.
            </summary>
            <returns>
            Parsed integer
            </returns>
        </member>
        <member name="M:Garnet.server.ParseUtils.TryReadBool(Garnet.server.ArgSlice@,System.Boolean@)">
            <summary>
            Try to read a signed 32-bit integer from a given ArgSlice.
            </summary>
            <returns>
            True if integer read successfully
            </returns>
        </member>
        <member name="T:Garnet.server.RespCommand">
            <summary>
            Basic RESP command enum
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandExtensions">
            <summary>
            Extension methods for <see cref="T:Garnet.server.RespCommand"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.IsAofIndependent(Garnet.server.RespCommand)">
            <summary>
            Returns whether or not a Resp command can have a dirty read or is dependent on AOF or not
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.NormalizeForACLs(Garnet.server.RespCommand)">
            <summary>
            Turns any not-quite-a-real-command entries in <see cref="T:Garnet.server.RespCommand"/> into the equivalent command
            for ACL'ing purposes and reading command info purposes
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.ExpandForACLs(Garnet.server.RespCommand)">
            <summary>
            Reverses <see cref="M:Garnet.server.RespCommandExtensions.NormalizeForACLs(Garnet.server.RespCommand)"/>, producing all the equivalent <see cref="T:Garnet.server.RespCommand"/>s which are covered by <paramref name="cmd"/>.
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandExtensions.LastValidCommand">
            <summary>
            Last valid command (i.e. RespCommand with the largest value excluding INVALID).
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.OneIfWrite(Garnet.server.RespCommand)">
            <summary>
            Returns 1 if <paramref name="cmd"/> is a write command.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.OneIfRead(Garnet.server.RespCommand)">
            <summary>
            Returns 1 if <paramref name="cmd"/> is a read command.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.IsNoAuth(Garnet.server.RespCommand)">
            <summary>
            Returns true if <paramref name="cmd"/> can be run even if the user is not authenticated.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandExtensions.IsClusterSubCommand(Garnet.server.RespCommand)">
            <summary>
            Returns true if <paramref name="cmd"/> can is a cluster subcommand.
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandOption">
            <summary>
            RESP command options enum
            </summary>
        </member>
        <member name="T:Garnet.server.SessionParseState">
            <summary>
            Wrapper to hold parse state for a RESP session.
            </summary>
        </member>
        <member name="F:Garnet.server.SessionParseState.MinParams">
            <summary>
            Initial number of arguments parsed for a command
            </summary>
        </member>
        <member name="F:Garnet.server.SessionParseState.Count">
            <summary>
            Count of accessible arguments for the command
            </summary>
        </member>
        <member name="F:Garnet.server.SessionParseState.bufferPtr">
            <summary>
            Pointer to accessible buffer
            </summary>
        </member>
        <member name="F:Garnet.server.SessionParseState.rootCount">
            <summary>
            Count of arguments in the original buffer
            </summary>
        </member>
        <member name="F:Garnet.server.SessionParseState.rootBuffer">
            <summary>
            Arguments original buffer
            </summary>
        </member>
        <member name="P:Garnet.server.SessionParseState.Parameters">
            <summary>
            Get a Span of the parsed parameters in the form an ArgSlice
            </summary>
        </member>
        <member name="M:Garnet.server.SessionParseState.Initialize">
            <summary>
            Initialize the parse state at the start of a session
            </summary>
        </member>
        <member name="M:Garnet.server.SessionParseState.Initialize(System.Int32)">
            <summary>
            Initialize the parse state with a given count of arguments
            </summary>
            <param name="count">Size of argument array to allocate</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArgument(Garnet.server.ArgSlice)">
            <summary>
            Initialize the parse state with one argument
            </summary>
            <param name="arg">Argument to initialize buffer with</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Initialize the parse state with two arguments
            </summary>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Initialize the parse state with three arguments
            </summary>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Initialize the parse state with four arguments
            </summary>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Initialize the parse state with four arguments
            </summary>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(Garnet.server.ArgSlice[])">
            <summary>
            Initialize the parse state with a given set of arguments
            </summary>
            <param name="args">Set of arguments to initialize buffer with</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.Slice(System.Int32)">
            <summary>
            Limit access to the argument buffer to start at a specified index.
            </summary>
            <param name="idxOffset">Offset value to the underlying buffer</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.Slice(System.Int32,System.Int32)">
            <summary>
            Limit access to the argument buffer to start at a specified index
            and end after a specified number of arguments.
            </summary>
            <param name="idxOffset">Offset value to the underlying buffer</param>
            <param name="count">Argument count</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.InitializeWithArguments(System.ReadOnlySpan{Garnet.server.ArgSlice})">
            <summary>
            Initialize the parse state with a given set of arguments
            </summary>
            <param name="args">Set of arguments to initialize buffer with</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.SetArgument(System.Int32,Garnet.server.ArgSlice)">
            <summary>
            Set argument at a specific index
            </summary>
            <param name="i">Index of buffer at which to set argument</param>
            <param name="arg">Argument to set</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.SetArguments(System.Int32,Garnet.server.ArgSlice[])">
            <summary>
            Set arguments starting at a specific index
            </summary>
            <param name="i">Index of buffer at which to start setting arguments</param>
            <param name="args">Arguments to set</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.SetArguments(System.Int32,System.ReadOnlySpan{Garnet.server.ArgSlice})">
            <summary>
            Set arguments starting at a specific index
            </summary>
            <param name="i">Index of buffer at which to start setting arguments</param>
            <param name="args">Arguments to set</param>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetSerializedLength">
            <summary>
            Get serialized length of parse state
            </summary>
            <returns>The serialized length</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.CopyTo(System.Byte*,System.Int32)">
            <summary>
            Serialize parse state to memory buffer
            when arguments are only serialized starting at a specified index
            </summary>
            <param name="dest">The memory buffer to serialize into (of size at least SerializedLength(firstIdx) bytes)</param>
            <param name="length">Length of buffer to serialize into.</param>
            <returns>Total serialized bytes</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.DeserializeFrom(System.Byte*)">
            <summary>
            Deserialize parse state from memory buffer into current struct
            </summary>
            <param name="src">Memory buffer to deserialize from</param>
            <returns>Number of deserialized bytes</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.Read(System.Int32,System.Byte*@,System.Byte*)">
            <summary>
            Read the next argument from the input buffer
            </summary>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetArgSliceByRef(System.Int32)">
            <summary>
            Get the argument at the given index
            </summary>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetInt(System.Int32)">
            <summary>
            Get int argument at the given index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.TryGetInt(System.Int32,System.Int32@)">
            <summary>
            Try to get int argument at the given index
            </summary>
            <returns>True if integer parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetLong(System.Int32)">
            <summary>
            Get long argument at the given index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.TryGetLong(System.Int32,System.Int64@)">
            <summary>
            Try to get long argument at the given index
            </summary>
            <returns>True if long parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetDouble(System.Int32,System.Boolean)">
            <summary>
            Get double argument at the given index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.TryGetDouble(System.Int32,System.Double@,System.Boolean)">
            <summary>
            Try to get double argument at the given index
            </summary>
            <returns>True if double parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetString(System.Int32)">
            <summary>
            Get ASCII string argument at the given index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.GetBool(System.Int32)">
            <summary>
            Get boolean argument at the given index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseState.TryGetBool(System.Int32,System.Boolean@)">
            <summary>
            Try to get boolean argument at the given index
            </summary>
            <returns>True if boolean parsed successfully</returns>
        </member>
        <member name="F:Garnet.server.ManagerType.MigrationManager">
            <summary>
            MigrationManager Buffer Pool
            </summary>
        </member>
        <member name="F:Garnet.server.ManagerType.ReplicationManager">
            <summary>
            ReplicationManager BufferPool
            </summary>
        </member>
        <member name="F:Garnet.server.ManagerType.ServerListener">
            <summary>
            ServerListener BufferPool
            </summary>
        </member>
        <member name="T:Garnet.server.ManagerTypeExtensions">
            <summary>
            Extension methods for <see cref="T:Garnet.server.ManagerType"/>.
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandAccessor">
            <summary>
            RESP command accessor
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandAccessor.MIGRATE">
            <summary>
            MIGRATE
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandArgumentBase">
            <summary>
            A base class that represents a RESP command's argument
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.Name">
            <summary>
            The argument's name
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.Type">
            <summary>
            The argument's type
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.DisplayText">
            <summary>
            The argument's display string
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.Token">
            <summary>
            A constant literal that precedes the argument (user input) itself
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.Summary">
            <summary>
            A short description of the argument
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgumentBase.ArgumentFlags">
            <summary>
            Argument flags
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandArgumentBase.#ctor">
            <summary>
            Empty constructor for JSON deserialization
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandArgumentBase.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandKeyArgument">
            <summary>
            Represents a RESP command's argument of type key
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeyArgument.Value">
            <summary>
            The argument's value - a string that describes the value in the command's syntax
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeyArgument.KeySpecIndex">
            <summary>
            This value is available for every argument of the key type.
            It is a 0-based index of the specification in the command's key specifications that corresponds to the argument.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandKeyArgument.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespCommandKeyArgument.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandArgument">
            <summary>
            Represents a RESP command's argument of all types except OneOf and Block
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandArgument.Value">
            <summary>
            The argument's value - a string that describes the value in the command's syntax
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandArgument.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandBasicArgument">
            <summary>
            Represents a RESP command's argument of all types except OneOf and Block
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandBasicArgument.#ctor">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandContainerArgument">
            <summary>
            Represents a RESP command's argument of type OneOf or Block
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandContainerArgument.Arguments">
            <summary>
            An array of nested arguments
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandContainerArgument.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespCommandContainerArgument.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandArgumentConverter">
            <summary>
            JSON converter for objects implementing RespCommandArgumentBase
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandArgumentConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespCommandArgumentConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespCommandArgumentConverter.Write(System.Text.Json.Utf8JsonWriter,Garnet.server.RespCommandArgumentBase,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandArgumentType">
            <summary>
            An enum representing a RESP command argument's type
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.String">
            <summary>
            A string argument
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.Integer">
            <summary>
            An integer argument
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.Double">
            <summary>
            A double-precision argument
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.Key">
            <summary>
            A string that represents the name of a key
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.Pattern">
            <summary>
            A string that represents a glob-like pattern
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.UnixTime">
            <summary>
            An integer that represents a Unix timestamp
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.PureToken">
            <summary>
            A token, meaning a reserved keyword, which may or may not be provided
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.OneOf">
            <summary>
            A container for nested arguments. This type enables choice among several nested arguments.
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentType.Block">
            <summary>
            A container for nested arguments. This type enables grouping arguments and applying a property.
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandArgumentFlags">
            <summary>
            Argument flags
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentFlags.Optional">
            <summary>
            Denotes that the argument is optional
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentFlags.Multiple">
            <summary>
            Denotes that the argument is optional
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandArgumentFlags.MultipleToken">
            <summary>
            Denotes that the argument is optional
            </summary>
        </member>
        <member name="M:Garnet.server.Resp.RespCommandDataCommon.TryImportRespCommandsData``1(System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,``0}@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Safely imports commands data from embedded resource in dynamically loaded/unloaded assembly
            </summary>
            <typeparam name="TData">Type of IRespCommandData to import</typeparam>
            <param name="path">Path to embedded resource</param>
            <param name="commandsData">Imported data</param>
            <param name="logger">Logger</param>
            <returns>True if imported successfully</returns>
        </member>
        <member name="T:Garnet.server.IRespCommandData">
            <summary>
            An interface for different RESP command data (e.g. RespCommandInfo, RespCommandDocs)
            </summary>
        </member>
        <member name="P:Garnet.server.IRespCommandData.Command">
            <summary>
            Garnet's RespCommand enum command representation
            </summary>
        </member>
        <member name="P:Garnet.server.IRespCommandData.Name">
            <summary>
            The command's name
            </summary>
        </member>
        <member name="T:Garnet.server.IRespCommandData`1">
            <summary>
            An interface for different RESP command data (e.g. RespCommandInfo, RespCommandDocs)
            </summary>
        </member>
        <member name="P:Garnet.server.IRespCommandData`1.SubCommands">
            <summary>
            All the command's sub-commands data, if any
            </summary>
        </member>
        <member name="P:Garnet.server.IRespCommandData`1.Parent">
            <summary>
            The parent data of the command
            </summary>
        </member>
        <member name="T:Garnet.server.IRespCommandsDataProvider`1">
            <summary>
            Interface for importing / exporting RESP commands data from different file types
            </summary>
        </member>
        <member name="M:Garnet.server.IRespCommandsDataProvider`1.TryImportRespCommandsData(System.String,Garnet.common.IStreamProvider,System.Collections.Generic.IReadOnlyDictionary{System.String,`0}@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Import RESP commands data from path using a stream provider
            </summary>
            <param name="path">Path to the file containing the serialized RESP commands data</param>
            <param name="streamProvider">Stream provider to use when reading from the path</param>
            <param name="logger">Logger</param>
            <param name="commandsData">Outputs a read-only dictionary that maps a command name to its matching data</param>
            <returns>True if import succeeded</returns>
        </member>
        <member name="M:Garnet.server.IRespCommandsDataProvider`1.TryExportRespCommandsData(System.String,Garnet.common.IStreamProvider,System.Collections.Generic.IReadOnlyDictionary{System.String,`0},Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Export RESP commands date to path using a stream provider
            </summary>
            <param name="path">Path to the file to write into</param>
            <param name="streamProvider">Stream provider to use when writing to the path</param>
            <param name="commandsData">Dictionary that maps a command name to its matching data</param>
            <param name="logger">Logger</param>
            <returns>True if export succeeded</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsDataProviderFactory.GetRespCommandsDataProvider``1(Garnet.server.RespCommandsDataFileType)">
            <summary>
            Get an IRespCommandsDataProvider instance based on its file type
            </summary>
            <param name="fileType">The RESP commands data file type</param>
            <returns>IRespCommandsDataProvider instance</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Garnet.server.DefaultRespCommandsDataProvider`1">
            <summary>
            Default commands data provider (JSON serialized array of data objects)
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandsDataFileType">
            <summary>
            Current supported RESP commands data file types
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandDocs">
            <summary>
            Represents a RESP command's docs
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Command">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Name">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Summary">
            <summary>
            Short command description
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Group">
            <summary>
            The functional group to which the command belong
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Complexity">
            <summary>
            A short explanation about the command's time complexity
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.DocFlags">
            <summary>
            Documentation flags
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.ReplacedBy">
            <summary>
            The alternative for a deprecated command
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.SubCommands">
            <summary>
            The command's arguments
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Parent">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandDocs.Arguments">
            <summary>
            The command's arguments
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandDocs.#ctor">
            <summary>
            Empty constructor for JSON deserialization
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandDocs.TryGetRespCommandsDocs(System.Collections.Generic.IReadOnlyDictionary{System.String,Garnet.server.RespCommandDocs}@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets all the command docs objects of commands supported by Garnet
            </summary>
            <param name="respCommandsDocs">Mapping between command name to command docs</param>
            <param name="externalOnly">Return only commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandDocs.TryGetRespCommandDocs(System.String,Garnet.server.RespCommandDocs@,System.Boolean,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets command docs by command name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsDocs">The command docs</param>
            <param name="externalOnly">Return command docs only if command is visible externally</param>
            <param name="includeSubCommands">Include sub-commands in command name search</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and command docs was found</returns>
        </member>
        <member name="M:Garnet.server.RespCommandDocs.TryGetRespSubCommandsDocs(System.Collections.Generic.IReadOnlyDictionary{System.String,Garnet.server.RespCommandDocs}@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets all the command docs of sub-commands supported by Garnet
            </summary>
            <param name="respSubCommandsDocs">Mapping between sub-command name to command docs</param>
            <param name="externalOnly">Return only sub-commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandDocs.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandGroup">
            <summary>
            Enum representing the functional group to which the command belongs
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandDocFlags">
            <summary>
            Documentation flags
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandDocFlags.Deprecated">
            <summary>
            The command is deprecated
            </summary>
        </member>
        <member name="F:Garnet.server.RespCommandDocFlags.SysCmd">
            <summary>
            A system command that isn't meant to be called by users
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandFlags">
            <summary>
            RESP command flags
            </summary>
        </member>
        <member name="T:Garnet.server.RespAclCategories">
            <summary>
            RESP ACL categories
            </summary>
        </member>
        <member name="T:Garnet.server.SimpleRespCommandInfo">
            <summary>
            Represents a simplified version of RESP command's information
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.Arity">
            <summary>
            Command Arity
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.AllowedInTxn">
            <summary>
            True if command is allowed in a transaction context
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.IsParent">
            <summary>
            True if command has sub-commands
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.IsSubCommand">
            <summary>
            True if command is a sub-command
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.KeySpecs">
            <summary>
            Simplified command key specifications
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.StoreType">
            <summary>
            Store type that the command operates on (None/Main/Object/All). Default: None for commands without key arguments.
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespCommandInfo.Default">
            <summary>
            Default SimpleRespCommandInfo
            </summary>
        </member>
        <member name="T:Garnet.server.SimpleRespKeySpecBeginSearch">
            <summary>
            Represents a simplified version of a single key specification of a RESP command
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecBeginSearch.Keyword">
            <summary>
            Keyword that precedes the keys in the command arguments
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecBeginSearch.Index">
            <summary>
            Index of first key or the index at which to start searching for keyword (if begin search is of keyword type)
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecBeginSearch.IsIndexType">
            <summary>
            If true - begin search is of type index, otherwise begin search is of type keyword
            </summary>
        </member>
        <member name="M:Garnet.server.SimpleRespKeySpecBeginSearch.#ctor(System.Int32)">
            <summary>
            Set begin search of type index
            </summary>
            <param name="index">Index of first key</param>
        </member>
        <member name="M:Garnet.server.SimpleRespKeySpecBeginSearch.#ctor(System.String,System.Int32)">
            <summary>
            Set begin search of type keyword
            </summary>
            <param name="keyword">Keyword that precedes the keys in the command arguments</param>
            <param name="startIdx">Index at which to start searching for keyword</param>
        </member>
        <member name="T:Garnet.server.SimpleRespKeySpecFindKeys">
            <summary>
            Represents a simplified version of a single key specification of a RESP command
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.Size">
            <summary>
            Size of struct
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.KeyNumIndex">
            <summary>
            The index (relative to begin search) of the argument containing the number of keys
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.FirstKey">
            <summary>
            the index (relative to begin search) of the first key
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.LastKeyOrLimit">
            <summary>
            The index (relative to begin search) of the last key argument or limit - stops the key search by a factor.
            0 and 1 mean no limit. 2 means half of the remaining arguments, 3 means a third, and so on.
            Limit is used if IsRangeLimitType is set.
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.KeyStep">
            <summary>
            The number of arguments that should be skipped, after finding a key, to find the next one.
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.IsRangeType">
            <summary>
            If true - find keys is of type range, otherwise find keys is of type keynum
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpecFindKeys.IsRangeLimitType">
            <summary>
            If true - find keys is of type range and limit is used, otherwise find keys is of type range and last key is used.
            </summary>
        </member>
        <member name="M:Garnet.server.SimpleRespKeySpecFindKeys.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Set find keys of type range
            </summary>
            <param name="keyStep">The number of arguments that should be skipped, after finding a key, to find the next one</param>
            <param name="lastKeyOrLimit">The index of the last key argument or the limit</param>
            <param name="isLimit">If preceding argument represents a limit</param>
        </member>
        <member name="M:Garnet.server.SimpleRespKeySpecFindKeys.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Set find keys of type keynum
            </summary>
            <param name="keyNumIndex">The index of the argument containing the number of keys</param>
            <param name="firstKey">The index of the first key</param>
            <param name="keyStep">The number of arguments that should be skipped, after finding a key, to find the next one</param>
        </member>
        <member name="T:Garnet.server.SimpleRespKeySpec">
            <summary>
            Represents a simplified version of a single key specification of a RESP command
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpec.BeginSearch">
            <summary>
            Begin search specification
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpec.FindKeys">
            <summary>
            Find keys specification
            </summary>
        </member>
        <member name="F:Garnet.server.SimpleRespKeySpec.Flags">
            <summary>
            Key specification flags
            </summary>
        </member>
        <member name="T:Garnet.server.RespCommandInfoExtensions">
            <summary>
            Extension methods for obtaining simplified RESP command info structs
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandInfoExtensions.PopulateSimpleCommandInfo(Garnet.server.RespCommandsInfo,Garnet.server.SimpleRespCommandInfo@)">
            <summary>
            Populates a SimpleRespCommandInfo struct from a RespCommandsInfo instance
            </summary>
            <param name="cmdInfo">The source RespCommandsInfo</param>
            <param name="simpleCmdInfo">The destination SimpleRespCommandInfo</param>
        </member>
        <member name="M:Garnet.server.RespCommandInfoExtensions.TryGetSimpleKeySpec(Garnet.server.RespCommandKeySpecification,Garnet.server.SimpleRespKeySpec@)">
            <summary>
            Tries to convert a RespCommandKeySpecification to a SimpleRespKeySpec
            </summary>
            <param name="keySpec">The source RespCommandKeySpecification</param>
            <param name="simpleKeySpec">The resulting SimpleRespKeySpec</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Garnet.server.RespCommandKeySpecification">
            <summary>
            Represents a RESP command's key specification
            A key specification describes a rule for extracting the names of one or more keys from the arguments of a given command
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeySpecification.BeginSearch">
            <summary>
            BeginSearch value of a specification informs the client of the extraction's beginning
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeySpecification.FindKeys">
            <summary>
            FindKeys value of a key specification tells the client how to continue the search for key names
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeySpecification.Notes">
            <summary>
            Notes about non-obvious key specs considerations
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandKeySpecification.Flags">
            <summary>
            Flags that provide more details about the key
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandKeySpecification.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <summary>
            Serializes the current object to RESP format
            </summary>
            <returns>Serialized value</returns>
        </member>
        <member name="T:Garnet.server.KeySpecificationFlags">
            <summary>
            RESP key specification flags
            </summary>
        </member>
        <member name="T:Garnet.server.KeySpecMethodBase">
            <summary>
            Base class representing key specification methods
            </summary>
        </member>
        <member name="P:Garnet.server.KeySpecMethodBase.MethodName">
            <summary>
            Name of the key specification method
            </summary>
        </member>
        <member name="M:Garnet.server.KeySpecMethodBase.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.BeginSearchKeySpecMethodBase">
            <summary>
            Base class representing BeginSearch key specification method types
            </summary>
        </member>
        <member name="P:Garnet.server.BeginSearchKeySpecMethodBase.MethodName">
            <summary>
            Name of the key specification
            </summary>
        </member>
        <member name="M:Garnet.server.BeginSearchKeySpecMethodBase.TryGetStartIndex(Garnet.server.SessionParseState@,System.Int32@)">
            <summary>
            Attempts to find the start index for key extraction based on the specified keyword.
            </summary>
            <param name="parseState">The current session parse state.</param>
            <param name="index">The index where the keyword is found, plus one.</param>
            <returns>True if the keyword is found; otherwise, false.</returns>
        </member>
        <member name="T:Garnet.server.BeginSearchIndex">
            <summary>
            Represents BeginSearch key specification method of type "index"
            Indicates that input keys appear at a constant index
            </summary>
        </member>
        <member name="P:Garnet.server.BeginSearchIndex.Index">
            <summary>
            The 0-based index from which the client should start extracting key names
            </summary>
        </member>
        <member name="M:Garnet.server.BeginSearchIndex.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchIndex.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchIndex.#ctor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchIndex.TryGetStartIndex(Garnet.server.SessionParseState@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.BeginSearchKeyword">
            <summary>
            Represents BeginSearch key specification method of type "keyword"
            Indicates that a literal token precedes key name arguments
            </summary>
        </member>
        <member name="P:Garnet.server.BeginSearchKeyword.Keyword">
            <summary>
            The keyword that marks the beginning of key name arguments
            </summary>
        </member>
        <member name="P:Garnet.server.BeginSearchKeyword.StartFrom">
            <summary>
            An index to the arguments array from which the client should begin searching
            </summary>
        </member>
        <member name="M:Garnet.server.BeginSearchKeyword.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchKeyword.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchKeyword.#ctor(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchKeyword.TryGetStartIndex(Garnet.server.SessionParseState@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.BeginSearchUnknown">
            <summary>
            Represents BeginSearch key specification method of unknown type
            </summary>
        </member>
        <member name="M:Garnet.server.BeginSearchUnknown.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.BeginSearchUnknown.TryGetStartIndex(Garnet.server.SessionParseState@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.FindKeysKeySpecMethodBase">
            <summary>
            Base class representing FindKeys key specification method types
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysKeySpecMethodBase.MethodName">
            <summary>
            Name of the key specification
            </summary>
        </member>
        <member name="M:Garnet.server.FindKeysKeySpecMethodBase.ExtractKeys(Garnet.server.SessionParseState@,System.Int32,System.Collections.Generic.List{Garnet.server.ArgSlice})">
            <summary>
            Extracts keys from the specified parse state starting from the given index.
            </summary>
            <param name="state">The current session parse state.</param>
            <param name="startIndex">The index from which to start extracting keys.</param>
            <param name="keys">The list to which extracted keys will be added.</param>
        </member>
        <member name="T:Garnet.server.FindKeysRange">
            <summary>
            Represents FindKeys key specification method of type "range"
            Indicates that keys stop at a specific index or relative to the last argument
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysRange.LastKey">
            <summary>
            The index, relative to BeginSearch, of the last key argument
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysRange.KeyStep">
            <summary>
            The number of arguments that should be skipped, after finding a key, to find the next one
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysRange.Limit">
            <summary>
            If LastKey is has the value of -1, Limit is used to stop the search by a factor
            </summary>
        </member>
        <member name="M:Garnet.server.FindKeysRange.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysRange.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysRange.#ctor(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysRange.ExtractKeys(Garnet.server.SessionParseState@,System.Int32,System.Collections.Generic.List{Garnet.server.ArgSlice})">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.FindKeysKeyNum">
            <summary>
            Represents FindKeys key specification method of type "keynum"
            Indicates that an additional argument specifies the number of input keys
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysKeyNum.KeyNumIdx">
            <summary>
            The index, relative to BeginSearch, of the argument containing the number of keys
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysKeyNum.FirstKey">
            <summary>
            The index, relative to BeginSearch, of the first key
            </summary>
        </member>
        <member name="P:Garnet.server.FindKeysKeyNum.KeyStep">
            <summary>
            The number of arguments that should be skipped, after finding a key, to find the next one
            </summary>
        </member>
        <member name="M:Garnet.server.FindKeysKeyNum.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysKeyNum.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysKeyNum.#ctor(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysKeyNum.ExtractKeys(Garnet.server.SessionParseState@,System.Int32,System.Collections.Generic.List{Garnet.server.ArgSlice})">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.FindKeysUnknown">
            <summary>
            Represents FindKeys key specification method of unknown type
            </summary>
        </member>
        <member name="M:Garnet.server.FindKeysUnknown.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.FindKeysUnknown.ExtractKeys(Garnet.server.SessionParseState@,System.Int32,System.Collections.Generic.List{Garnet.server.ArgSlice})">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.KeySpecConverter">
            <summary>
            JSON converter for objects implementing KeySpecMethodBase
            </summary>
        </member>
        <member name="M:Garnet.server.KeySpecConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.KeySpecConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.KeySpecConverter.Write(System.Text.Json.Utf8JsonWriter,Garnet.server.KeySpecMethodBase,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.RespCommandsInfo">
            <summary>
            Represents a RESP command's information
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Command">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Name">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.IsInternal">
            <summary>
            Determines if the command is Garnet internal-only (i.e. not exposed to clients) 
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Arity">
            <summary>
            The command's arity, i.e. the number of arguments a command expects
            * A positive integer means a fixed number of arguments
            * A negative integer means a minimal number of arguments
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Flags">
            <summary>
            RESP command flags
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.FirstKey">
            <summary>
            The position of the command's first key name argument
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.LastKey">
            <summary>
            The position of the command's last key name argument
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Step">
            <summary>
            The step, or increment, between the first key and the position of the next key
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.AclCategories">
            <summary>
            ACL categories to which the command belongs
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Tips">
            <summary>
            Helpful information about the command
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.KeySpecifications">
            <summary>
            Methods for locating keys in the command's arguments
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.StoreType">
            <summary>
            Store type that the command operates on (None/Main/Object/All). Default: None for commands without key arguments.
            </summary>
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.SubCommands">
            <inheritdoc />
        </member>
        <member name="P:Garnet.server.RespCommandsInfo.Parent">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetCommandsforAclCategory(Garnet.server.RespAclCategories,System.Collections.Generic.IReadOnlyList{Garnet.server.RespCommandsInfo}@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets commands which are covered by the given ACL category.
            </summary>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespCommandsInfoCount(System.Int32@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets the number of commands supported by Garnet
            </summary>
            <param name="count">The count value</param>
            <param name="externalOnly">Return number of commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespCommandsInfo(System.Collections.Generic.IReadOnlyDictionary{System.String,Garnet.server.RespCommandsInfo}@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets all the command info objects of commands supported by Garnet
            </summary>
            <param name="respCommandsInfo">Mapping between command name to command info</param>
            <param name="externalOnly">Return only commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespCommandNames(System.Collections.Generic.IReadOnlySet{System.String}@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets all the command names of commands supported by Garnet
            </summary>
            <param name="respCommandNames">The command names</param>
            <param name="externalOnly">Return only names of commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespCommandInfo(System.String,Garnet.server.RespCommandsInfo@,System.Boolean,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets command info by command name
            </summary>
            <param name="cmdName">The command name</param>
            <param name="respCommandsInfo">The command info</param>
            <param name="externalOnly">Return command info only if command is visible externally</param>
            <param name="includeSubCommands">Include sub-commands in command name search</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and command info was found</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespCommandInfo(Garnet.server.RespCommand,Garnet.server.RespCommandsInfo@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets command info by RespCommand enum and sub-command byte, if applicable
            </summary>
            <param name="cmd">The RespCommand enum</param>
            <param name="logger">Logger</param>
            <param name="respCommandsInfo">The commands info</param>
            <param name="txnOnly">Return only commands that are allowed in a transaction context (False by default)</param>
            <returns>True if initialization was successful and command info was found</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryFastGetRespCommandInfo(Garnet.server.RespCommand,Garnet.server.RespCommandsInfo@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Get command info by RespCommand enum from array of RespCommandsInfo
            </summary>
            <param name="cmd"></param>
            <param name="respCommandsInfo"></param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetRespSubCommandsInfo(System.Collections.Generic.IReadOnlyDictionary{System.String,Garnet.server.RespCommandsInfo}@,System.Boolean,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets all the command info objects of sub-commands supported by Garnet
            </summary>
            <param name="respSubCommandsInfo">Mapping between sub-command name to command info</param>
            <param name="externalOnly">Return only sub-commands that are visible externally</param>
            <param name="logger">Logger</param>
            <returns>True if initialization was successful and data was retrieved successfully</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.TryGetSimpleRespCommandInfo(Garnet.server.RespCommand,Garnet.server.SimpleRespCommandInfo@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets command's simplified info
            </summary>
            <param name="cmd">Resp command</param>
            <param name="cmdInfo">Arity</param>
            <param name="logger">Logger</param>
            <returns>True if valid command</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.GetRespCommandName(Garnet.server.RespCommand,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Gets command's name
            </summary>
            <param name="cmd">Resp command</param>
            <param name="logger">Logger</param>
            <returns>Command name</returns>
        </member>
        <member name="M:Garnet.server.RespCommandsInfo.ToRespFormat(Garnet.common.RespMemoryWriter@)">
            <summary>
            Serializes the current object to RESP format
            </summary>
            <returns>Serialized value</returns>
        </member>
        <member name="T:Garnet.server.ScriptHashOwner">
            <summary>
            Owner for memory used to store Lua script hashes on the heap.
            </summary>
        </member>
        <member name="P:Garnet.server.ScriptHashOwner.Memory">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.ScriptHashOwner.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.GarnetServerBase">
            <summary>
            Garnet server - common base class
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerBase.activeHandlers">
            <summary>
            Active network handlers
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerBase.activeHandlerCount">
            <summary>
            Count of active network handlers sessions
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerBase.sessionProviders">
            <summary>
            Session providers
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerBase.EndPoint">
            <summary>
            The endpoint server listener socket is bound to.
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerBase.NetworkBufferSize">
            <summary>
            Server NetworkBufferSize
            </summary>        
        </member>
        <member name="P:Garnet.server.GarnetServerBase.Disposed">
            <summary>
            Check if server has been disposed
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerBase.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.IncrementConnectionsReceived">
            <summary>
            Add to total_connections_received
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.IncrementConnectionsDisposed">
            <summary>
            Add to total_connections_disposed
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.ActiveConsumers">
            <summary>
            Returns all the active message consumers.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.ActiveClusterSessions">
            <summary>
            Return all active <see cref="T:Garnet.server.IClusterSession"/>s.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.get_conn_active">
            <summary>
            Get total_connections_active
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerBase.TotalConnectionsReceived">
            <summary>
            Get the total number of connections received.
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerBase.TotalConnectionsDisposed">
            <summary>
            Get the total number of connections received.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.ResetConnectionsReceived">
            <summary>
            Reset connections received counter. Multiplier for accounting for pub/sub
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.ResetConnectionsDiposed">
            <summary>
            Reset connections disposed counter
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerBase.Register(Garnet.networking.WireFormat,Garnet.server.ISessionProvider)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetServerBase.Unregister(Garnet.networking.WireFormat,Garnet.server.ISessionProvider@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetServerBase.GetSessionProviders">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetServerBase.AddSession(Garnet.networking.WireFormat,Garnet.server.ISessionProvider@,Garnet.networking.INetworkSender,Garnet.networking.IMessageConsumer@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetServerBase.Start">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.GarnetServerBase.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.GarnetServerOptions">
            <summary>
            Options when creating Garnet server
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.DisableObjects">
            <summary>
            Support data structure objects.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreHeapMemorySize">
            <summary>
            Heap memory size limit of object store.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreLogMemorySize">
            <summary>
            Object store log memory used in bytes excluding heap memory.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStorePageSize">
            <summary>
            Size of each object store page in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreSegmentSize">
            <summary>
            Size of each object store log segment in bytes on disk (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreIndexSize">
            <summary>
            Size of object store hash index in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreIndexMaxSize">
            <summary>
            Max size of object store hash index in bytes (rounds down to power of 2). 
            If unspecified, index size doesn't grow (default behavior).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreMutablePercent">
            <summary>
            Percentage of object store log memory that is kept mutable.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableCluster">
            <summary>
            Enable cluster.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CleanClusterConfig">
            <summary>
            Start with clean cluster config
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ParallelMigrateTaskCount">
            <summary>
            Number of parallel migrate tasks to spawn when SLOTS or SLOTSRANGE option is used.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.FastMigrate">
            <summary>
            When migrating slots 1. write directly to network buffer to avoid unecessary copies, 2. do not wait for ack from target before sending next batch of keys.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AuthSettings">
            <summary>
            Authentication settings
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableAOF">
            <summary>
            Enable append-only file (write ahead log)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AofMemorySize">
            <summary>
            Total AOF memory buffer used in bytes (rounds down to power of 2) - spills to disk after this limit.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AofPageSize">
            <summary>
            Aof page size in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AofReplicationRefreshFrequencyMs">
            <summary>
            AOF replication (safe tail address) refresh frequency in milliseconds. 0 = auto refresh after every enqueue.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.SubscriberRefreshFrequencyMs">
            <summary>
            Subscriber (safe tail address) refresh frequency in milliseconds (for pub-sub). 0 = auto refresh after every enqueue.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CommitFrequencyMs">
            <summary>
            Write ahead logging (append-only file) commit issue frequency in milliseconds.
            0 = issue an immediate commit per operation
            -1 = manually issue commits using COMMITAOF command (no auto-commit)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ExpiredKeyDeletionScanFrequencySecs">
            <summary>
            Frequency of background scan for expired key deletion, in seconds.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.IndexResizeFrequencySecs">
            <summary>
            Index resize check frequency in seconds.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.IndexResizeThreshold">
            <summary>
            Overflow bucket count over total index size in percentage to trigger index resize.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.WaitForCommit">
            <summary>
            Wait for AOF to commit before returning results to client.
            Warning: will greatly increase operation latency.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AofSizeLimit">
            <summary>
            Aof size limit in bytes
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AofSizeLimitEnforceFrequencySecs">
            <summary>
            Frequency (in ms) of execution of the AutoCheckpointBasedOnAofSizeLimit background task.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CompactionFrequencySecs">
            <summary>
            Hybrid log compaction frequency in seconds. 0 = disabled
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ExpiredObjectCollectionFrequencySecs">
            <summary>
            Frequency in seconds for the background task to perform object collection which removes expired members within object from memory. 0 = disabled. Use the HCOLLECT and ZCOLLECT API to collect on-demand.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CompactionType">
            <summary>
            Hybrid log compaction type.
             None - no compaction.
             Shift - shift begin address without compaction (data loss).
             Scan - scan old pages and move live records to tail (no data loss).
             Lookup - lookup each record in compaction range, for record liveness checking using hash chain (no data loss).
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CompactionForceDelete">
            <summary>
            Forcefully delete the inactive segments immediately after the compaction strategy (type) is applied.
            If false, take a checkpoint to actually delete the older data files from disk.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CompactionMaxSegments">
            <summary>
            Number of log segments created on disk before compaction triggers.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectStoreCompactionMaxSegments">
            <summary>
            Number of object store log segments created on disk before compaction triggers.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.GossipSamplePercent">
            <summary>
            Percent of cluster nodes to gossip with at each gossip iteration.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.GossipDelay">
            <summary>
            Cluster mode gossip protocol per node sleep (in seconds) delay to send updated config.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterTimeout">
            <summary>
            Cluster node timeout is the amount of seconds a node must be unreachable. 
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterConfigFlushFrequencyMs">
            <summary>
            How frequently to flush cluster config unto disk to persist updates. =-1: never (memory only), =0: immediately (every update performs flush), >0: frequency in ms
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.TlsOptions">
            <summary>
            TLS options
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterUsername">
            <summary>
            Username for clients used by cluster backend
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterPassword">
            <summary>
            Password for clients used by cluster backend
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.LatencyMonitor">
            <summary>
            Enable per command latency tracking for all commands
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.SlowLogThreshold">
            <summary>
            Threshold (microseconds) for logging command in the slow log. 0 to disable
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.SlowLogMaxEntries">
            <summary>
            Maximum number of slow log entries to keep
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.MetricsSamplingFrequency">
            <summary>
            Metrics sampling frequency
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.LogLevel">
            <summary>
            Logging level. Value options: Trace, Debug, Information, Warning, Error, Critical, None
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.LoggingFrequency">
            <summary>
            Frequency (in seconds) of logging (used for tracking progress of long running operations e.g. migration)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.QuietMode">
            <summary>
            Metrics sampling frequency
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableIncrementalSnapshots">
            <summary>
            SAVE and BGSAVE: Enable incremental snapshots, try to write only changes compared to base snapshot
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.FullCheckpointLogInterval">
            <summary>
            SAVE and BGSAVE: We will take a full (index + log) checkpoint when ReadOnlyAddress of log increases by this amount, from the last full checkpoint.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.IncrementalSnapshotLogSizeLimit">
            <summary>
            SAVE and BGSAVE: Limit on size of delta log for incremental snapshot, we perform a non-incremental checkpoint after this limit is reached.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.UseFoldOverCheckpoints">
            <summary>
            SAVE and BGSAVE: Use fold-over checkpoints instead of snapshots.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ThreadPoolMinThreads">
            <summary>
            Minimum worker threads in thread pool (0 for default)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ThreadPoolMaxThreads">
            <summary>
            Maximum worker threads in thread pool (0 for default)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ThreadPoolMinIOCompletionThreads">
            <summary>
            Minimum IO completion threads in thread pool (0 for default)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ThreadPoolMaxIOCompletionThreads">
            <summary>
            Maximum IO completion threads in thread pool (0 for default)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.NetworkConnectionLimit">
            <summary>
            Maximum client connection limit
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.DeviceFactoryCreator">
            <summary>
            Instance of interface to create named device factories
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.CheckpointThrottleFlushDelayMs">
            <summary>
            Whether and by how much should we throttle the disk IO for checkpoints (default = 0)
            -1   - disable throttling
            >= 0 - run checkpoint flush in separate task, sleep for specified time after each WRiteAsync
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableFastCommit">
            <summary>
            Enable FastCommit mode for TsavoriteLog
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.FastCommitThrottleFreq">
            <summary>
            Throttle FastCommit to write metadata once every K commits
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.NetworkSendThrottleMax">
            <summary>
            Throttle the maximum outstanding network sends per session
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableScatterGatherGet">
            <summary>
            Whether we use scatter gather IO for MGET operations - useful to saturate disk random read IO
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaSyncDelayMs">
            <summary>
            Whether and by how much should we throttle replica sync frequency (default = 5ms)
            0   - disable throttling
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicationOffsetMaxLag">
            <summary>
            Throttle ClusterAppendLog when replica.AOFTailAddress - ReplicationOffset > ReplicationOffsetMaxLag. 0: Synchronous replay,  >=1: background replay with specified lag, -1: infinite lag
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.FastAofTruncate">
            <summary>
            Whether we truncate AOF as soon as replicas are fed (not just after checkpoints)
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.OnDemandCheckpoint">
            <summary>
            Used with main-memory replication model. Take on demand checkpoint to avoid missing data when attaching
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaDisklessSync">
            <summary>
            Whether diskless replication is enabled or not.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaDisklessSyncDelay">
            <summary>
            Delay in diskless replication sync in seconds. =0: Immediately start diskless replication sync.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaSyncTimeout">
            <summary>
            Timeout in seconds for replication sync operations
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaAttachTimeout">
            <summary>
            Timeout in seconds for replication attach operation
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ReplicaDisklessSyncFullSyncAofThreshold">
            <summary>
            AOF replay size threshold for diskless replication, beyond which we will perform a full sync even if a partial sync is possible. Defaults to AOF memory size if not specified.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.UseAofNullDevice">
            <summary>
            With main-memory replication, whether we use null device for AOF. Ensures no disk IO, but can cause data loss during replication.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ObjectScanCountLimit">
            <summary>
            Limit of items to return in one iteration of *SCAN command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivBinRecordSizes">
            <summary>
            Sizes of records in each revivification bin, in order of increasing size. See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivBinRecordCounts">
            <summary>
            Number of records in each bin. See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivifiableFraction">
            <summary>
            How much of the in-memory storage space, from the highest log address down, is eligible for revivification.
            It may be important for recent records to remain in mutable memory as long as possible before entering the read-only
            memory region or being evicted to disk.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.UseRevivBinsPowerOf2">
            <summary>
            A shortcut to specify revivification with power-of-2-sized bins. See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivNumberOfBinsToSearch">
            <summary>
            Search this number of next-higher bins if the search cannot be satisfied in the best-fitting bin. See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivBinBestFitScanLimit">
            <summary>
            Number of records to scan for best fit after finding first fit. See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivInChainOnly">
            <summary>
            Revivify tombstoned records in tag chains only (do not use free list). See Options helptext for details.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.RevivObjBinRecordCount">
            <summary>
            Number of records in the single free record bin for the object store.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AdjustedIndexMaxCacheLines">
            <summary>Max size of hash index (cache lines) after rounding down size in bytes to power of 2.</summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.AdjustedObjectStoreIndexMaxCacheLines">
            <summary>Max size of object store hash index (cache lines) after rounding down size in bytes to power of 2.</summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableDebugCommand">
            <summary>
            Enables the DEBUG command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.EnableModuleCommand">
            <summary>
            Enables the MODULE command
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ExtensionBinPaths">
            <summary>
            Directories on server from which custom command binaries can be loaded by admin users
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ExtensionAllowUnsignedAssemblies">
            <summary>
            Allow loading custom commands from digitally unsigned assemblies
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.LoadModuleCS">
            <summary>List of modules to load</summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.UnixSocketPath">
            <summary>
            Unix socket address path to bind server to
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.UnixSocketPermission">
            <summary>
            Unix socket file permissions
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.MaxDatabases">
            <summary>
            Max number of logical databases allowed
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.AllowMultiDb">
            <summary>
            Allow more than one logical database in server
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.CheckpointBaseDirectory">
            <summary>
            Gets the base directory for storing checkpoints
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.MainStoreCheckpointBaseDirectory">
            <summary>
            Gets the base directory for storing main-store checkpoints
            </summary>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.ObjectStoreCheckpointBaseDirectory">
            <summary>
            Gets the base directory for storing object-store checkpoints
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterReplicationReestablishmentTimeout">
            <summary>
            Seconds between attempts to re-establish replication between a Primary and Replica if the replication connection
            has faulted.
            
            0 disables.
            
            Attempts will only be made if Primary and Replica are exchanging GOSSIP messages.
            </summary>
        </member>
        <member name="F:Garnet.server.GarnetServerOptions.ClusterReplicaResumeWithData">
            <summary>
            If true, a Cluster Replica will load any AOF/Checkpoint data from disk when it starts
            and NOT dump it's data until a Primary connects.
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetCheckpointDirectoryName(System.Int32)">
            <summary>
            Get the directory name for database checkpoints
            </summary>
            <param name="dbId">Database Id</param>
            <returns>Directory name</returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetMainStoreCheckpointDirectory(System.Int32)">
            <summary>
            Get the directory for main-store database checkpoints
            </summary>
            <param name="dbId">Database Id</param>
            <returns>Directory</returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetObjectStoreCheckpointDirectory(System.Int32)">
            <summary>
            Get the directory for object-store database checkpoints
            </summary>
            <param name="dbId">Database Id</param>
            <returns>Directory</returns>
        </member>
        <member name="P:Garnet.server.GarnetServerOptions.AppendOnlyFileBaseDirectory">
            <summary>
            Gets the base directory for storing AOF commits
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetAppendOnlyFileDirectoryName(System.Int32)">
            <summary>
            Get the directory name for database AOF commits
            </summary>
            <param name="dbId">Database Id</param>
            <returns>Directory name</returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetAppendOnlyFileDirectory(System.Int32)">
            <summary>
            Get the directory for database AOF commits
            </summary>
            <param name="dbId">Database Id</param>
            <returns>Directory</returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.Initialize(Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Initialize Garnet server options
            </summary>
            <param name="loggerFactory"></param>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetSettings(Microsoft.Extensions.Logging.ILoggerFactory,Tsavorite.core.LightEpoch,Tsavorite.core.StateMachineDriver,Tsavorite.core.INamedDeviceFactory@)">
            <summary>
            Get main store settings
            </summary>
            <param name="loggerFactory">Logger factory for debugging and error tracing</param>
            <param name="epoch">Epoch instance used by server</param>
            <param name="stateMachineDriver">Common state machine driver used by Garnet</param>
            <param name="logFactory">Tsavorite Log factory instance</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.MemorySizeBits(System.String,System.String,System.Int32@)">
            <summary>
            Get memory size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetObjectStoreSettings(Microsoft.Extensions.Logging.ILoggerFactory,Tsavorite.core.LightEpoch,Tsavorite.core.StateMachineDriver,System.Int64@,System.Int64@)">
            <summary>
            Get KVSettings for the object store log
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetAofSettings(System.Int32,Tsavorite.core.TsavoriteLogSettings@)">
            <summary>
            Get AOF settings
            </summary>
            <param name="dbId">DB ID</param>
            <param name="tsavoriteLogSettings">Tsavorite log settings</param>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetInitializedDeviceFactory(System.String)">
            <summary>
            Gets a new instance of device factory initialized with the supplied baseName.
            </summary>
            <param name="baseName"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.AofMemorySizeBits">
            <summary>
            Get AOF memory size in bits
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.AofPageSizeBits">
            <summary>
            Get AOF Page size in bits
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.AofSizeLimitSizeBits">
            <summary>
            Get maximum AOF size in bits
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.ObjectStorePageSizeBits">
            <summary>
            Get object store page size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.ReplicaDisklessSyncFullSyncAofThresholdValue">
            <summary>
            Get integer value of ReplicaDisklessSyncFullSyncAofThreshold
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.ObjectStoreSegmentSizeBits">
            <summary>
            Get object store segment size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerOptions.GetAofDevice(System.Int32)">
            <summary>
            Get device for AOF
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.GarnetServerTcp">
            <summary>
            Garnet server for TCP
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.ActiveConsumers">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.ActiveClusterSessions">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.#ctor(System.Net.EndPoint,System.Int32,Garnet.server.TLS.IGarnetTlsOptions,System.Int32,System.Int32,System.String,System.IO.UnixFileMode,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor for server
            </summary>
            <param name="endpoint">Endpoint bound for listening for connections.</param>
            <param name="networkBufferSize"></param>
            <param name="tlsOptions"></param>
            <param name="networkSendThrottleMax"></param>
            <param name="networkConnectionLimit"></param>
            <param name="unixSocketPath"></param>
            <param name="unixSocketPermission"></param>
            <param name="logger"></param>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.Start">
            <summary>
            Start listening to incoming requests
            </summary>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.TryCreateMessageConsumer(System.Span{System.Byte},Garnet.networking.INetworkSender,Garnet.networking.IMessageConsumer@)">
            <summary>
            Create session (message consumer) given incoming bytes
            </summary>
            <param name="bytes"></param>
            <param name="networkSender"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.GarnetServerTcp.DisposeMessageConsumer(Garnet.networking.INetworkHandler)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.IGarnetServer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Garnet.server.IGarnetServer.Register(Garnet.networking.WireFormat,Garnet.server.ISessionProvider)">
            <summary>
            Register session provider for specified wire format with the server
            </summary>
            <param name="wireFormat"></param>
            <param name="backendProvider"></param>
        </member>
        <member name="M:Garnet.server.IGarnetServer.Unregister(Garnet.networking.WireFormat,Garnet.server.ISessionProvider@)">
            <summary>
            Unregister provider associated with specified wire format
            </summary>
            <param name="wireFormat"></param>
            <param name="provider"></param>
        </member>
        <member name="M:Garnet.server.IGarnetServer.GetSessionProviders">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetServer.AddSession(Garnet.networking.WireFormat,Garnet.server.ISessionProvider@,Garnet.networking.INetworkSender,Garnet.networking.IMessageConsumer@)">
            <summary>
            
            </summary>
            <param name="protocol"></param>
            <param name="provider"></param>
            <param name="networkSender"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IGarnetServer.Start">
            <summary>
            Start server
            </summary>
        </member>
        <member name="T:Garnet.server.IServerSerializer`4">
            <summary>
            Serializer interface for server-side processing
            </summary>
            <typeparam name="TKey">Key</typeparam>
            <typeparam name="TValue">Value</typeparam>
            <typeparam name="TInput">Input</typeparam>
            <typeparam name="TOutput">Output</typeparam>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.Write(`0@,System.Byte*@,System.Int32)">
            <summary>
            Write element to given destination, with length bytes of space available
            </summary>
            <param name="k">Element to write</param>
            <param name="dst">Destination memory</param>
            <param name="length">Space (bytes) available at destination</param>
            <returns>True if write succeeded, false if not (insufficient space)</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.Write(`1@,System.Byte*@,System.Int32)">
            <summary>
            Write element to given destination, with length bytes of space available
            </summary>
            <param name="v">Element to write</param>
            <param name="dst">Destination memory</param>
            <param name="length">Space (bytes) available at destination</param>
            <returns>True if write succeeded, false if not (insufficient space)</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.Write(`3@,System.Byte*@,System.Int32)">
            <summary>
            Write element to given destination, with length bytes of space available
            </summary>
            <param name="o">Element to write</param>
            <param name="dst">Destination memory</param>
            <param name="length">Space (bytes) available at destination</param>
            <returns>True if write succeeded, false if not (insufficient space)</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.GetLength(`3@)">
            <summary>
            Get length of given output
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.ReadKeyByRef(System.Byte*@)">
            <summary>
            Read key by reference, from given location
            </summary>
            <param name="src">Memory location</param>
            <returns>Key</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.ReadValueByRef(System.Byte*@)">
            <summary>
            Read value by reference, from given location
            </summary>
            <param name="src">Memory location</param>
            <returns>Value</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.ReadInputByRef(System.Byte*@)">
            <summary>
            Read input by reference, from given location
            </summary>
            <param name="src">Memory location</param>
            <returns>Input</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.AsRefOutput(System.Byte*,System.Int32)">
            <summary>
            Read memory as output (by reference), at given location
            </summary>
            <param name="src">Memory location</param>
            <param name="length">Length of buffer at memory</param>
            <returns>Output</returns>
        </member>
        <member name="M:Garnet.server.IServerSerializer`4.SkipOutput(System.Byte*@)">
            <summary>
            Skip output (increment address)
            </summary>
            <param name="src">Memory location</param>
        </member>
        <member name="T:Garnet.server.MetricsApi">
            <summary>
            Metrics API
            </summary>
        </member>
        <member name="M:Garnet.server.MetricsApi.#ctor(Garnet.server.GarnetProvider)">
            <summary>
            Construct new Metrics API instance
            </summary>
        </member>
        <member name="M:Garnet.server.MetricsApi.GetInfoMetrics(Garnet.common.InfoMetricsType,System.Int32)">
            <summary>
            Get info metrics for specified info type
            </summary>
            <param name="infoMetricsType"></param>
            <param name="dbId">Database ID for database-specific metrics</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MetricsApi.GetInfoMetrics(Garnet.common.InfoMetricsType[],System.Int32)">
            <summary>
            Get info metrics for specified info types
            </summary>
            <param name="infoMetricsTypes">Info types to get, null to get all</param>
            <param name="dbId">Database ID for database-specific metrics</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MetricsApi.GetHeader(Garnet.common.InfoMetricsType,System.Int32)">
            <summary>
            Get header for given info metrics type
            </summary>
            <param name="infoMetricsType">Info types to get, null to get all</param>
            <param name="dbId">Database ID for database-specific metrics</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MetricsApi.ResetInfoMetrics(Garnet.common.InfoMetricsType)">
            <summary>
            Reset info metrics
            </summary>
            <param name="infoMetricsType"></param>
        </member>
        <member name="M:Garnet.server.MetricsApi.ResetInfoMetrics(Garnet.common.InfoMetricsType[])">
            <summary>
            Reset info metrics
            </summary>
            <param name="infoMetricsTypes">Info types to reset, null to reset all</param>
        </member>
        <member name="M:Garnet.server.MetricsApi.GetLatencyMetrics(Garnet.common.LatencyMetricsType)">
            <summary>
            Get latency metrics (histogram) for specified latency type
            </summary>
            <param name="latencyMetricsType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MetricsApi.GetLatencyMetrics(Garnet.common.LatencyMetricsType[])">
            <summary>
            Get latency metrics (histograms) for specified latency types
            </summary>
            <param name="latencyMetricsTypes">Latency types to get, null to get all</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.MetricsApi.ResetLatencyMetrics(Garnet.common.LatencyMetricsType)">
            <summary>
            Reset latency histogram for eventType
            </summary>
            <param name="latencyMetricsType">Latency types to reset, null to reset all</param>
        </member>
        <member name="M:Garnet.server.MetricsApi.ResetLatencyMetrics(Garnet.common.LatencyMetricsType[])">
            <summary>
            Reset latency histogram for eventTypes
            </summary>
            <param name="latencyMetricsTypes"></param>
        </member>
        <member name="T:Garnet.server.RegisterApi">
            <summary>
            Command registration API
            </summary>
        </member>
        <member name="M:Garnet.server.RegisterApi.#ctor(Garnet.server.GarnetProvider)">
            <summary>
            Construct new Register API instance
            </summary>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewCommand(System.String,Garnet.server.CommandType,Garnet.server.CustomRawStringFunctions,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs,System.Int64)">
            <summary>
            Register custom command with Garnet
            </summary>
            <param name="name">Name of command</param>
            <param name="type">Type of command (e.g., read)</param>
            <param name="customFunctions">Custom functions for command logic</param>
            <param name="commandInfo">RESP command info</param>
            <param name="commandDocs">RESP command docs</param>
            <param name="expirationTicks">
            Expiration for value, in ticks.
            -1 => remove existing expiration metadata;
             0 => retain whatever it is currently (or no expiration if this is a new entry) - this is the default;
            >0 => set expiration to given value.
            </param>
            <returns>ID of the registered command</returns>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewTransactionProc(System.String,System.Func{Garnet.server.CustomTransactionProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Register transaction procedure with Garnet
            </summary>
            <param name="name">Name of command</param>
            <param name="proc">Custom stored procedure</param>
            <param name="commandInfo">RESP command info</param>
            <param name="commandDocs">RESP command docs</param>
            <returns>ID of the registered command</returns>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewType(Garnet.server.CustomObjectFactory)">
            <summary>
            Register object type with server
            </summary>
            <param name="factory">Factory for object type</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewCommand(System.String,Garnet.server.CommandType,Garnet.server.CustomObjectFactory,Garnet.server.CustomObjectFunctions,Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Register custom command with Garnet
            </summary>
            <param name="name">Name of command</param>
            <param name="commandType">Type of command (e.g., read)</param>
            <param name="factory">Custom factory for object</param>
            <param name="customObjectFunctions">Custom object command implementation</param>
            <param name="commandInfo">RESP command info</param>
            <param name="commandDocs">RESP command docs</param>
            <returns>ID of the registered command</returns>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewProcedure(System.String,System.Func{Garnet.server.CustomProcedure},Garnet.server.RespCommandsInfo,Garnet.server.RespCommandDocs)">
            <summary>
            Register custom procedure with Garnet
            </summary>
            <param name="name"></param>
            <param name="customProcedure"></param>
            <param name="commandInfo"></param>
            <param name="commandDocs"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.RegisterApi.NewModule(Garnet.server.ModuleBase,System.String[],System.ReadOnlySpan{System.Byte}@,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Register custom module with Garnet
            </summary>
            <param name="module"></param>
            <param name="moduleArgs"></param>
            <param name="logger"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ServerOptions">
            <summary>
            Options when creating Garnet server
            </summary>
        </member>
        <member name="P:Garnet.server.ServerOptions.EndPoints">
            <summary>
            Endpoints to bind server to.
            </summary>
        </member>
        <member name="P:Garnet.server.ServerOptions.ClusterAnnounceEndpoint">
            <summary>
            Cluster announce Endpoint
            </summary>
        </member>
        <member name="P:Garnet.server.ServerOptions.ClusterAnnounceHostname">
            <summary>
            Cluster announce Hostname
            </summary>
        </member>
        <member name="P:Garnet.server.ServerOptions.ClusterPreferredEndpointType">
            <summary>
            Cluster Preferred Endpoint Type
            Used in cluster redirection messages, cluster slots 
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.MemorySize">
            <summary>
            Total log memory used in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.PageSize">
            <summary>
            Size of each page in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.SegmentSize">
            <summary>
            Size of each log segment in bytes on disk (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.IndexSize">
            <summary>
            Size of hash index in bytes (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.IndexMaxSize">
            <summary>
            Max size of hash index in bytes (rounds down to power of 2). If unspecified, index size doesn't grow (default behavior).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.MutablePercent">
            <summary>
            Percentage of log memory that is kept mutable.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.EnableStorageTier">
            <summary>
            Enable tiering of records (hybrid log) to storage, to support a larger-than-memory store. Use LogDir to specify storage directory.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.CopyReadsToTail">
            <summary>
            When records are read from the main store's in-memory immutable region or storage device, copy them to the tail of the log.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.ObjectStoreCopyReadsToTail">
            <summary>
            When records are read from the object store's in-memory immutable region or storage device, copy them to the tail of the log.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.LogDir">
            <summary>
            Storage directory for tiered records (hybrid log), if storage tiering (UseStorage) is enabled. Uses current directory if unspecified.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.CheckpointDir">
            <summary>
            Storage directory for checkpoints. Uses LogDir if unspecified.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.Recover">
            <summary>
            Recover from latest checkpoint.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.DisablePubSub">
            <summary>
            Disable pub/sub feature on server.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.PubSubPageSize">
            <summary>
            Page size of log used for pub/sub (rounds down to power of 2).
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.FailOnRecoveryError">
            <summary>
            Server bootup should fail if errors happen during bootup of AOF and checkpointing.
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.SkipRDBRestoreChecksumValidation">
            <summary>
            Skip RDB restore checksum validation
            </summary>
        </member>
        <member name="F:Garnet.server.ServerOptions.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:Garnet.server.ServerOptions.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.ServerOptions.MemorySizeBits">
            <summary>
            Get memory size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.PageSizeBits">
            <summary>
            Get page size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.PubSubPageSizeBytes">
            <summary>
            Get pub/sub page size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.SegmentSizeBits">
            <summary>
            Get segment size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.IndexSizeCachelines(System.String,System.String)">
            <summary>
            Get index size
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.ParseSize(System.String,System.Int32@)">
            <summary>
            Parse size from string specification
            </summary>
            <param name="value"></param>
            <param name="bytesRead"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.TryParseSize(System.String,System.Int64@)">
            <summary>
            Try to parse size from string specification
            </summary>
            <param name="value">String size value</param>
            <param name="size">Parsed size</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.PrettySize(System.Int64)">
            <summary>
            Pretty print value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.PreviousPowerOf2(System.Int64)">
            <summary>
            Previous power of 2
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.ServerOptions.NextPowerOf2(System.Int64)">
            <summary>
            Next power of 2
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.StoreApi">
            <summary>
            Store API
            </summary>
        </member>
        <member name="M:Garnet.server.StoreApi.#ctor(Garnet.server.StoreWrapper)">
            <summary>
            Store API
            </summary>
        </member>
        <member name="T:Garnet.server.StoreApi.PreventRoleChangeLock">
            <summary>
            Helper to prevent certain operations from happening on a node which is currently a replica.
            </summary>
        </member>
        <member name="M:Garnet.server.StoreApi.PreventRoleChangeLock.#ctor(Garnet.server.StoreApi)">
            <summary>
            Helper to prevent certain operations from happening on a node which is currently a replica.
            </summary>
        </member>
        <member name="M:Garnet.server.StoreApi.PreventRoleChangeLock.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.StoreApi.IsReplica">
            <summary>
            Helper for checking if node is currently a replica.
            
            Only call under a <see cref="T:Garnet.server.StoreApi.PreventRoleChangeLock"/> using acquired via <see cref="M:Garnet.server.StoreApi.PreventRoleChange(System.Boolean@)"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.StoreApi.CommitAOF(System.Boolean)">
            <summary>
            Commit AOF
            </summary>
            <param name="spinWait">True if should wait until all commits complete</param>
            <returns>false if the commit was ignored due to node state or config</returns>
        </member>
        <member name="M:Garnet.server.StoreApi.WaitForCommitAsync(System.Threading.CancellationToken)">
            <summary>
            Wait for commit
            </summary>
            <returns>false if the commit was ignored due to node state or config</returns>
        </member>
        <member name="M:Garnet.server.StoreApi.WaitForCommit">
            <summary>
            Wait for commit
            </summary>
            <returns>false if the commit was ignored due to node state or config</returns>
        </member>
        <member name="M:Garnet.server.StoreApi.CommitAOFAsync(System.Threading.CancellationToken)">
            <summary>
            Commit AOF
            </summary>
            <returns>false if the commit was ignored due to node state or config</returns>
        </member>
        <member name="M:Garnet.server.StoreApi.FlushDB(System.Int32,System.Boolean)">
            <summary>
            Flush DB (delete all keys)
            Optionally truncate log on disk. This is a destructive operation. Instead take a checkpoint if you are using checkpointing, as
            that will safely truncate the log on disk after the checkpoint.
            </summary>
            <returns>false if the commit was ignored due to node state or config</returns>
        </member>
        <member name="M:Garnet.server.StoreApi.PreventRoleChange(System.Boolean@)">
            <summary>
            Helper to disable role changes during a using block.
            
            <paramref name="acquired"/> is set if, and only if, the role will not change until the return is disposed.
            </summary>
        </member>
        <member name="T:Garnet.server.SessionParseStateExtensions">
            <summary>
            Extension methods for <see cref="T:Garnet.server.SessionParseState"/>.
            </summary>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetInfoMetricsType(Garnet.server.SessionParseState,System.Int32,Garnet.common.InfoMetricsType@)">
            <summary>
            Parse info metrics type from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetLatencyMetricsType(Garnet.server.SessionParseState,System.Int32,Garnet.common.LatencyMetricsType@)">
            <summary>
            Parse latency metrics type from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetClientName(Garnet.server.SessionParseState,System.Int32,System.String@)">
            <summary>
            Parse client name from parse state at specified index.
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="clientName">Client name</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetClientType(Garnet.server.SessionParseState,System.Int32,Garnet.server.ClientType@)">
            <summary>
            Parse client type from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetBitFieldOverflow(Garnet.server.SessionParseState,System.Int32,Garnet.server.BitFieldOverflow@)">
            <summary>
            Parse bit field overflow from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetBitfieldEncoding(Garnet.server.SessionParseState,System.Int32,System.Int64@,System.Boolean@)">
            <summary>
            Parse bit field ENCODING slice from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="bitCount">parsed bitcount</param>
            <param name="isSigned">bitfield signtype</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetBitfieldOffset(Garnet.server.SessionParseState,System.Int32,System.Int64@,System.Boolean@)">
            <summary>
            Parse bit field OFFSET slice from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="bitFieldOffset">parsed value</param>
            <param name="multiplyOffset">should value by multiplied by bitcount</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetGeoSearchOptions(Garnet.server.SessionParseState,Garnet.server.RespCommand,Garnet.server.GeoSearchOptions@,System.Int32@,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Parse GEOSEARCH commands options from parse state based on command
            </summary>
            <param name="parseState"></param>
            <param name="command"></param>
            <param name="searchOpts"></param>
            <param name="destIdx"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetManagerType(Garnet.server.SessionParseState,System.Int32,Garnet.server.ManagerType@)">
            <summary>
            Parse manager type from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetSortedSetAddOption(Garnet.server.SessionParseState,System.Int32,Garnet.server.SortedSetAddOption@)">
            <summary>
            Parse sorted set add option from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetExpireOption(Garnet.server.SessionParseState,System.Int32,Garnet.server.ExpireOption@)">
            <summary>
            Parse expire option from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetSortedSetAggregateType(Garnet.server.SessionParseState,System.Int32,Garnet.server.SortedSetAggregateType@)">
            <summary>
            Parse sorted set aggregate type from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetExpirationOption(Garnet.server.SessionParseState,System.Int32,Garnet.server.ExpirationOption@)">
            <summary>
            Given the parseState and an index, potentially get the expiration option at that index.
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed expiration option value</param>
            <returns>If the argument at that index is a valid expiration option return true, else return false</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetExpirationOptionWithToken(Garnet.server.SessionParseState,System.Span{System.Byte}@,Garnet.server.ExpirationOption@)">
            <summary>
            Given the parse state and a token, potentially get the expiration option represented by the token.
            </summary>
            <param name="parseState">The parse state (used only to provide the dot notation for this method)</param>
            <param name="token">The token to parse</param>
            <param name="value">Parsed expiration option value</param>
            <returns>If the token is a valid expiration option return true, else false</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetGeoDistanceUnit(Garnet.server.SessionParseState,System.Int32,Garnet.server.GeoDistanceUnitType@)">
            <summary>
            Parse geo distance unit from parse state at specified index
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="value">Parsed value</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetGeoLonLat(Garnet.server.SessionParseState,System.Int32,System.Double@,System.Double@,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Parse geo longitude and latitude from parse state at specified index.
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The first argument index</param>
            <param name="lon">Longitude</param>
            <param name="lat">Latitude</param>
            <param name="error">Error if failed</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetTimeout(Garnet.server.SessionParseState,System.Int32,System.Double@,System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Parse timeout (in seconds) from parse state at specified index.
            </summary>
            <param name="parseState">The parse state</param>
            <param name="idx">The argument index</param>
            <param name="timeout">Timeout</param>
            <param name="error">Error if failed</param>
            <returns>True if value parsed successfully</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.ExtractCommandKeys(Garnet.server.SessionParseState@,Garnet.server.SimpleRespCommandInfo)">
            <summary>
            Tries to extract keys from the key specifications in the given RespCommandsInfo.
            </summary>
            <param name="state">The SessionParseState instance.</param>
            <param name="commandInfo">The command's simplified info</param>
            <returns>The extracted keys</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.ExtractCommandKeysAndFlags(Garnet.server.SessionParseState@,Garnet.server.SimpleRespCommandInfo)">
            <summary>
            Tries to extract keys and their associated flags from the key specifications in the given RespCommandsInfo.
            </summary>
            <param name="state">The SessionParseState instance.</param>
            <param name="commandInfo">The command's simplified info</param>
            <returns>The extracted keys and flags</returns>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryAppendKeysFromSpec(Garnet.server.SessionParseState@,Garnet.server.SimpleRespKeySpec,System.Boolean,System.Collections.Generic.List{System.ValueTuple{Garnet.server.ArgSlice,System.Int32}})">
            <summary>
            Extracts keys from the given key specification in the provided SessionParseState.
            </summary>
            <param name="parseState">The SessionParseState instance.</param>
            <param name="keySpec">The key specification to use for extraction.</param>
            <param name="isSubCommand">True if command is a sub-command</param>
            <param name="keysToIndexes">The list to store extracted keys and their matching indexes</param>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryAppendKeysAndFlagsFromSpec(Garnet.server.SessionParseState@,Garnet.server.SimpleRespKeySpec,System.Boolean,System.Collections.Generic.List{System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.KeySpecificationFlags,System.Int32}})">
            <summary>
            Extracts keys from the given key specification in the provided SessionParseState.
            </summary>
            <param name="parseState">The SessionParseState instance.</param>
            <param name="keySpec">The key specification to use for extraction.</param>
            <param name="isSubCommand">True if command is a sub-command</param>
            <param name="keysAndFlags">The list to store extracted keys and flags and their indexes</param>
        </member>
        <member name="M:Garnet.server.SessionParseStateExtensions.TryGetKeySearchArgsFromSimpleKeySpec(Garnet.server.SessionParseState@,Garnet.server.SimpleRespKeySpec,System.Boolean,System.ValueTuple{System.Int32,System.Int32,System.Int32}@)">
            <summary>
            Extracts the first, last, and step arguments for key searching based on a simplified RESP key specification and the current parse state.
            </summary>
            <param name="parseState">The current parse state</param>
            <param name="keySpec">The simplified key specification</param>
            <param name="isSubCommand">True if command is a sub-command</param>
            <param name="searchArgs">First, last, and step arguments for key searching</param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ISessionProvider">
            <summary>
            Interface to provides server-side session processing logic
            </summary>
        </member>
        <member name="M:Garnet.server.ISessionProvider.GetSession(Garnet.networking.WireFormat,Garnet.networking.INetworkSender)">
            <summary>
            Given messages of wire format type and a networkSender, returns a session that handles that wire format. If no provider is configured
            for the given wire format, an exception is thrown.
            </summary>
            <param name="wireFormat">Wire format</param>
            <param name="networkSender">Socket connection</param>
            <returns>Server session</returns>
        </member>
        <member name="P:Garnet.server.ISessionProvider.GetMaxSizeSettings">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.ServerSessionBase">
            <summary>
            Abstract base class for server session provider
            </summary>
        </member>
        <member name="F:Garnet.server.ServerSessionBase.bytesRead">
            <summary>
            Bytes read
            </summary>
        </member>
        <member name="F:Garnet.server.ServerSessionBase.networkSender">
            <summary>
            NetworkSender instance
            </summary>
        </member>
        <member name="M:Garnet.server.ServerSessionBase.#ctor(Garnet.networking.INetworkSender)">
            <summary>
             Create instance of session backed by given networkSender
            </summary>
            <param name="networkSender"></param>
        </member>
        <member name="M:Garnet.server.ServerSessionBase.TryConsumeMessages(System.Byte*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ServerSessionBase.Publish(Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Publish an update to a key to all the subscribers of the key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Garnet.server.ServerSessionBase.PatternPublish(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice)">
            <summary>
            Publish an update to a key to all the (pattern) subscribers of the key
            </summary>
            <param name="pattern"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Garnet.server.ServerSessionBase.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:Garnet.server.SortedSetAggregateType">
            <summary>
            Specifies the type of aggregation to be used in sorted set operations.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAggregateType.Sum">
            <summary>
            Sum the values.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAggregateType.Min">
            <summary>
            Use the minimum value.
            </summary>
        </member>
        <member name="F:Garnet.server.SortedSetAggregateType.Max">
            <summary>
            Use the maximum value.
            </summary>
        </member>
        <member name="T:Garnet.server.SpanByteFunctionsForServer`1">
            <summary>
            Callback functions using SpanByteAndMemory output, for SpanByte key, value, input
            </summary>
        </member>
        <member name="M:Garnet.server.SpanByteFunctionsForServer`1.#ctor(System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="memoryPool"></param>
        </member>
        <member name="M:Garnet.server.SpanByteFunctionsForServer`1.SingleReader(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteFunctionsForServer`1.ConcurrentReader(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteFunctionsForServer`1.CopyWithHeaderTo(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,System.Buffers.MemoryPool{System.Byte})">
            <summary>
            Copy to given SpanByteAndMemory (header length and payload copied to actual span/memory)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="memoryPool"></param>
        </member>
        <member name="T:Garnet.server.SpanByteServerSerializer">
            <summary>
            Serializer for SpanByte. Used only on server-side.
            </summary>
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="maxKeyLength">Max key length</param>
            <param name="maxValueLength">Max value length</param>
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.ReadKeyByRef(System.Byte*@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.ReadValueByRef(System.Byte*@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.ReadInputByRef(System.Byte*@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.Write(Tsavorite.core.SpanByte@,System.Byte*@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.Write(Tsavorite.core.SpanByteAndMemory@,System.Byte*@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.AsRefOutput(System.Byte*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.SkipOutput(System.Byte*@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.SpanByteServerSerializer.GetLength(Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.EtagState">
            <summary>
            Indirection wrapper to provide a way to set offsets related to Etags and use the getters opaquely from outside.
            </summary>
        </member>
        <member name="P:Garnet.server.EtagState.etagOffsetForVarlen">
            <summary>
            Offset used accounting space for an etag during allocation
            </summary>
        </member>
        <member name="P:Garnet.server.EtagState.etagSkippedStart">
            <summary>
            Gives an offset used to opaquely work with Etag in a payload. By calling this you can skip past the etag if it is present.
            </summary>
        </member>
        <member name="P:Garnet.server.EtagState.etagAccountedLength">
            <summary>
            Resp response methods depend on the value for end being -1 or length of the payload. This field lets you work with providing the end opaquely.
            </summary>
        </member>
        <member name="P:Garnet.server.EtagState.etag">
            <summary>
            Field provides access to getting an Etag from a record, hiding whether it is actually present or not.
            </summary>
        </member>
        <member name="M:Garnet.server.EtagState.SetValsForRecordWithEtag(Garnet.server.EtagState@,Tsavorite.core.SpanByte@)">
            <summary>
            Sets the values to indicate the presence of an Etag as a part of the payload value
            </summary>
        </member>
        <member name="T:Garnet.server.FunctionsState">
            <summary>
            State for Functions - one instance per session is created
            </summary>
        </member>
        <member name="T:Garnet.server.MainSessionFunctions">
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
            <summary>
            Callback functions for main store
            </summary>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.ReadCompletionCallback(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,System.Int64,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.RMWCompletionCallback(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,System.Int64,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.SingleDeleter(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostSingleDeleter(Tsavorite.core.SpanByte@,Tsavorite.core.DeleteInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.ConcurrentDeleter(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostDeleteOperation``1(Tsavorite.core.SpanByte@,Tsavorite.core.DeleteInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.#ctor(Garnet.server.FunctionsState)">
            <summary>
            Constructor
            </summary>
            <param name="functionsState"></param>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.ConvertOutputToHeap(Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.TryCopyUpdateNumber(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,System.Int64,System.Int32)">
            <summary>
            Copy update from old value to new value while also validating whether oldValue is a numerical value.
            </summary>
            <param name="oldValue">Old value copying from</param>
            <param name="newValue">New value copying to</param>
            <param name="output">Output value</param>
            <param name="input">Parsed input value</param>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.TryCopyUpdateNumber(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,System.Double,System.Int32)">
            <summary>
            Copy update from old value to new value while also validating whether oldValue is a numerical value.
            </summary>
            <param name="oldValue">Old value copying from</param>
            <param name="newValue">New value copying to</param>
            <param name="output">Output value</param>
            <param name="input">Parsed input value</param>
            <param name="etagIgnoredOffset">Number of bytes to skip for ignoring etag in value payload</param>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.IsValidNumber(System.Int32,System.Byte*,System.Span{System.Byte},System.Int64@)">
            <summary>
            Parse ASCII byte array into long and validate that only contains ASCII decimal characters
            </summary>
            <param name="length">Length of byte array</param>
            <param name="source">Pointer to byte array</param>
            <param name="output">Output error flag</param>
            <param name="val">Parsed long value</param>
            <returns>True if input contained only ASCII decimal characters, otherwise false</returns>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.CopyValueLengthToOutput(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,System.Int32)">
            <summary>
            Copy length of value to output (as ASCII bytes)
            </summary>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.WriteLogUpsert``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,System.Int64,System.Int32,``0)">
            <summary>
            Logging upsert from
            a. ConcurrentWriter
            b. PostSingleWriter
            </summary>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.WriteLogRMW``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,System.Int64,System.Int32,``0)">
            <summary>
            Logging RMW from
            a. PostInitialUpdater
            b. InPlaceUpdater
            c. PostCopyUpdater
            </summary>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.WriteLogDelete``1(Tsavorite.core.SpanByte@,System.Int64,System.Int32,``0)">
            <summary>
             Logging Delete from
             a. ConcurrentDeleter
             b. PostSingleDeleter
            </summary>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.SingleReader(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.ConcurrentReader(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.NeedInitialUpdate(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.InitialUpdater(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostInitialUpdater(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.InPlaceUpdater(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.NeedCopyUpdate(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.CopyUpdater(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostCopyUpdater(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostRMWOperation``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.RMWInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.SingleWriter(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostSingleWriter(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.ConcurrentWriter(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.PostUpsertOperation``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByte@,Tsavorite.core.UpsertInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.IsValidNumber(System.Int32,System.Byte*,System.Int64@)">
            <summary>
            Parse ASCII byte array into long and validate that only contains ASCII decimal characters
            </summary>
            <param name="length">Length of byte array</param>
            <param name="source">Pointer to byte array</param>
            <param name="val">Parsed long value</param>
            <returns>True if input contained only ASCII decimal characters, otherwise false</returns>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.IsValidDouble(System.Int32,System.Byte*,System.Double@)">
            <summary>
            Parse ASCII byte array into double and validate that only contains ASCII decimal characters
            </summary>
            <param name="length">Length of byte array</param>
            <param name="source">Pointer to byte array</param>
            <param name="val">Parsed long value</param>
            <returns>True if input contained only ASCII decimal characters, otherwise false</returns>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.GetRMWInitialValueLength(Garnet.server.RawStringInput@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.MainSessionFunctions.GetRMWModifiedValueLength(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@)">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.ObjectSessionFunctions">
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
            <summary>
            Object store functions
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.ReadCompletionCallback(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Int64,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.RMWCompletionCallback(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,System.Int64,Tsavorite.core.Status,Tsavorite.core.RecordMetadata)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.SingleDeleter(System.Byte[]@,Garnet.server.IGarnetObject@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostSingleDeleter(System.Byte[]@,Tsavorite.core.DeleteInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.ConcurrentDeleter(System.Byte[]@,Garnet.server.IGarnetObject@,Tsavorite.core.DeleteInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostDeleteOperation``1(System.Byte[]@,Tsavorite.core.DeleteInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.#ctor(Garnet.server.FunctionsState)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.ConvertOutputToHeap(Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.WriteLogUpsert``1(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,System.Int64,System.Int32,``0)">
            <summary>
            Logging upsert from
            a. ConcurrentWriter
            b. PostSingleWriter
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.WriteLogRMW``1(System.Byte[]@,Garnet.server.ObjectInput@,System.Int64,System.Int32,``0)">
            <summary>
            Logging RMW from
            a. PostInitialUpdater
            b. InPlaceUpdater
            c. PostCopyUpdater
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.WriteLogDelete``1(System.Byte[]@,System.Int64,System.Int32,``0)">
            <summary>
             Logging Delete from
             a. ConcurrentDeleter
             b. PostSingleDeleter
            </summary>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.SingleReader(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.ReadInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.ConcurrentReader(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.ReadInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.NeedInitialUpdate(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.InitialUpdater(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostInitialUpdater(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.InPlaceUpdater(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.NeedCopyUpdate(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.CopyUpdater(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostCopyUpdater(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.RMWInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostRMWOperation``1(System.Byte[]@,Garnet.server.ObjectInput@,Tsavorite.core.RMWInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.SingleWriter(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostSingleWriter(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.UpsertInfo@,Tsavorite.core.WriteReason)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.ConcurrentWriter(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Garnet.server.IGarnetObject@,Garnet.server.GarnetObjectStoreOutput@,Tsavorite.core.UpsertInfo@,Tsavorite.core.RecordInfo@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.PostUpsertOperation``1(System.Byte[]@,Garnet.server.ObjectInput@,Garnet.server.IGarnetObject@,Tsavorite.core.UpsertInfo@,``0)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.GetRMWModifiedValueLength(Garnet.server.IGarnetObject@,Garnet.server.ObjectInput@)">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.ObjectSessionFunctions.GetRMWInitialValueLength(Garnet.server.ObjectInput@)">
            <inheritdoc/>
        </member>
        <member name="T:Garnet.server.StorageSession">
            <summary>
            Server API methods - HASH
            </summary>
            <summary>
            Server session for RESP protocol - SET
            </summary>
            <summary>
            Storage Session - the internal layer that Garnet uses to perform storage operations
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.DbScan(Garnet.server.ArgSlice,System.Boolean,System.Int64,System.Int64@,System.Collections.Generic.List{System.Byte[]}@,System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
             Gets keys matching the pattern with a limit of count in every iteration
             when using pattern
            </summary>
            <param name="patternB">ptr to the matching pattern</param>
            <param name="allKeys">true when the pattern is *</param>
            <param name="cursor">cursor sent in the request</param>
            <param name="storeCursor"></param>
            <param name="keys">The list with the keys from the store</param>
            <param name="count">size of every block or keys to return</param>
            <param name="typeObject">The type object to filter out</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.MainStoreExpiredKeyDeletionScan(System.Int64,System.Int64)">
            <summary>
            Iterates over main store memory collecting expired records.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.ObjectStoreExpiredKeyDeletionScan(System.Int64,System.Int64)">
            <summary>
            Iterates over object store memory collecting expired records.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.IterateMainStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Iterate the contents of the main store (push-based)
            </summary>
            <typeparam name="TScanFunctions"></typeparam>
            <param name="scanFunctions"></param>
            <param name="untilAddress"></param>
            <param name="cursor"></param>
            <param name="maxAddress"></param>
            <param name="validateCursor"></param>
            <param name="includeTombstones"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.IterateMainStore">
            <summary>
            Iterate the contents of the main store (pull based)
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.IterateObjectStore``1(``0@,System.Int64@,System.Int64,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Iterate the contents of the object store (push-based)
            </summary>
            <typeparam name="TScanFunctions"></typeparam>
            <param name="scanFunctions"></param>
            <param name="untilAddress"></param>
            <param name="cursor"></param>
            <param name="maxAddress"></param>
            <param name="validateCursor"></param>
            <param name="includeTombstones"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.IterateObjectStore">
            <summary>
            Iterate the contents of the main store (pull based)
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.DBKeys(Garnet.server.ArgSlice)">
            <summary>
             Get a list of the keys in the store and object store
             when using pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.DbSize">
            <summary>
            Count the number of keys in main and object store
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.CompletePendingForSession``1(Tsavorite.core.Status@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            Handles the complete pending status for Session Store
            </summary>
            <param name="status"></param>
            <param name="output"></param>
            <param name="context"></param>
        </member>
        <member name="M:Garnet.server.StorageSession.CompletePendingForSession``1(``0@)">
            <summary>
            Handles the complete pending status for Session Store, without outputs.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.HyperLogLogAdd``1(Garnet.server.ArgSlice,System.String[],System.Boolean@,``0@)">
            <summary>
            Adds all the element arguments to the HyperLogLog data structure stored at the variable name specified as key.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.HyperLogLogAdd``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            Adds one element to the HyperLogLog data structure stored at the variable name specified.
            </summary>
            <typeparam name="TContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HyperLogLogLength``1(Garnet.server.RawStringInput@,System.Int64@,System.Boolean@,``0@)">
            <summary>
            Returns the approximated cardinality computed by the HyperLogLog data structure stored at the specified key,
            or 0 if the key does not exist.
            </summary>
            <param name="input"></param>
            <param name="count"></param>
            <param name="error"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HyperLogLogMerge(Garnet.server.RawStringInput@,System.Boolean@)">
            <summary>
            Merge multiple HyperLogLog values into a unique value that will approximate the cardinality 
            of the union of the observed Sets of the source HyperLogLog structures.
            </summary>
            <param name="input"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GETDEL``1(Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            GETDEL command - Gets the value corresponding to the given key and deletes the key.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="output">Span to allocate the output of the operation</param>
            <param name="context">Basic Context of the store</param>
            <returns> Operation status </returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GETDEL``1(Tsavorite.core.SpanByte@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            GETDEL command - Gets the value corresponding to the given key and deletes the key.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="output">Span to allocate the output of the operation</param>
            <param name="context">Basic Context of the store</param>
            <returns> Operation status </returns>
        </member>
        <member name="M:Garnet.server.StorageSession.TTL``2(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@,``0@,``1@,System.Boolean)">
            <summary>
            Returns the remaining time to live of a key that has a timeout.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to get the remaining time to live in the store.</param>
            <param name="storeType">The store to operate on</param>
            <param name="output">Span to allocate the output of the operation</param>
            <param name="context">Basic Context of the store</param>
            <param name="objectContext">Object Context of the store</param>
            <param name="milliseconds">when true the command to execute is PTTL.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIRETIME``2(Tsavorite.core.SpanByte@,Garnet.server.StoreType,Tsavorite.core.SpanByteAndMemory@,``0@,``1@,System.Boolean)">
            <summary>
            Get the absolute Unix timestamp at which the given key will expire.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to get the Unix timestamp.</param>
            <param name="storeType">The store to operate on</param>
            <param name="output">Span to allocate the output of the operation</param>
            <param name="context">Basic Context of the store</param>
            <param name="objectContext">Object Context of the store</param>
            <param name="milliseconds">when true the command to execute is PEXPIRETIME.</param>
            <returns>Returns the absolute Unix timestamp (since January 1, 1970) in seconds or milliseconds at which the given key will expire.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.APPEND``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@,``0@)">
            <summary>
            APPEND command - appends value at the end of existing string
            </summary>
            <typeparam name="TContext">Context type</typeparam>
            <param name="key">Key whose value is to be appended</param>
            <param name="value">Value to be appended</param>
            <param name="output">Length of updated value</param>
            <param name="context">Store context</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.APPEND``1(Tsavorite.core.SpanByte@,Garnet.server.RawStringInput@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            APPEND command - appends value at the end of existing string
            </summary>
            <typeparam name="TContext">Context type</typeparam>
            <param name="key">Key whose value is to be appended</param>
            <param name="input">Input for main store</param>
            <param name="output">Length of updated value</param>
            <param name="context">Store context</param>
            <returns>Operation status</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.RENAMENX(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.StoreType,System.Int32@,System.Boolean)">
            <summary>
            Renames key to newkey if newkey does not yet exist. It returns an error when key does not exist.
            </summary>
            <param name="oldKeySlice">The old key to be renamed.</param>
            <param name="newKeySlice">The new key name.</param>
            <param name="storeType">The type of store to perform the operation on.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXISTS``2(Garnet.server.ArgSlice,Garnet.server.StoreType,``0@,``1@)">
            <summary>
            Returns if key is an existing one in the store.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The name of the key to use in the operation</param>
            <param name="storeType">The store to operate on.</param>
            <param name="context">Basic context for the main store.</param>
            <param name="objectContext">Object context for the object store.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIRE``2(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption,``0@,``1@)">
            <summary>
            Set a timeout on key
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to set the timeout on.</param>
            <param name="expiryMs">Milliseconds value for the timeout.</param>
            <param name="timeoutSet">True when the timeout was properly set.</param>
            <param name="storeType">The store to operate on.</param>
            <param name="expireOption">>Flags to use for the operation.</param>
            <param name="context">Basic context for the main store.</param>
            <param name="objectStoreContext">Object context for the object store.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIRE``2(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,System.Boolean@,Garnet.server.StoreType,``0@,``1@)">
            <summary>
            Set a timeout on key.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to set the timeout on.</param>
            <param name="input">Input for the main store</param>
            <param name="timeoutSet">True when the timeout was properly set.</param>
            <param name="storeType">The store to operate on.</param>
            <param name="context">Basic context for the main store</param>
            <param name="objectStoreContext">Object context for the object store</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIREAT``2(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption,``0@,``1@,System.Boolean)">
            <summary>
            Set a timeout on key using absolute Unix timestamp (seconds since January 1, 1970).
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to set the timeout on.</param>
            <param name="expiryTimestamp">Absolute Unix timestamp</param>
            <param name="timeoutSet">True when the timeout was properly set.</param>
            <param name="storeType">The store to operate on.</param>
            <param name="expireOption">Flags to use for the operation.</param>
            <param name="context">Basic context for the main store</param>
            <param name="objectStoreContext">Object context for the object store</param>
            <param name="milliseconds">When true, <paramref name="expiryTimestamp"/> is treated as milliseconds else seconds</param>
            <returns>Return GarnetStatus.OK when key found, else GarnetStatus.NOTFOUND</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIRE``2(Garnet.server.ArgSlice,System.TimeSpan,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption,``0@,``1@,System.Boolean)">
            <summary>
            Set a timeout on key.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to set the timeout on.</param>
            <param name="expiry">The timespan value to set the expiration for.</param>
            <param name="timeoutSet">True when the timeout was properly set.</param>
            <param name="storeType">The store to operate on.</param>
            <param name="expireOption">Flags to use for the operation.</param>
            <param name="context">Basic context for the main store</param>
            <param name="objectStoreContext">Object context for the object store</param>
            <param name="milliseconds">When true the command executed is PEXPIRE, expire by default.</param>
            <returns>Return GarnetStatus.OK when key found, else GarnetStatus.NOTFOUND</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.EXPIRE``2(Garnet.server.ArgSlice,System.Int64,System.Boolean@,Garnet.server.StoreType,Garnet.server.ExpireOption,``0@,``1@,Garnet.server.RespCommand)">
            <summary>
            Set a timeout on key.
            </summary>
            <typeparam name="TContext"></typeparam>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The key to set the timeout on.</param>
            <param name="expiration">The timespan value to set the expiration for.</param>
            <param name="timeoutSet">True when the timeout was properly set.</param>
            <param name="storeType">The store to operate on.</param>
            <param name="expireOption">Flags to use for the operation.</param>
            <param name="context">Basic context for the main store</param>
            <param name="objectStoreContext">Object context for the object store</param>
            <param name="respCommand">The current RESP command</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SETRANGE``1(Garnet.server.ArgSlice,Garnet.server.RawStringInput@,Garnet.server.ArgSlice@,``0@)">
            <summary>
            For existing keys - overwrites part of the value at a specified offset (in-place if possible)
            For non-existing keys - creates a new string with the value at a specified offset (padded with '\0's)
            </summary>
            <typeparam name="TContext"></typeparam>
            <param name="key">The key for which to set the range</param>
            <param name="input">Input for the main store</param>
            <param name="output">The length of the updated string</param>
            <param name="context">Basic context for the main store</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.LCS(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Tsavorite.core.SpanByteAndMemory@,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Computes the Longest Common Subsequence (LCS) of two keys.
            </summary>
            <param name="key1">The first key to compare.</param>
            <param name="key2">The second key to compare.</param>
            <param name="output">The output span to store the result.</param>
            <param name="lenOnly">If true, only the length of the LCS is returned.</param>
            <param name="withIndices">If true, the indices of the LCS in both keys are returned.</param>
            <param name="withMatchLen">If true, the length of each match is returned.</param>
            <param name="minMatchLen">The minimum length of a match to be considered.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.RMWObjectStoreOperationWithOutput``1(System.Byte[],Garnet.server.ObjectInput@,``0@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Perform RMW operation in object store
            use this method in commands that return an array
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="objectStoreContext"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ReadObjectStoreOperationWithOutput``1(System.Byte[],Garnet.server.ObjectInput@,``0@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Perform Read operation in object store
            use this method in commands that return an array
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="objectStoreContext"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ReadObjectStoreOperationWithOutput``1(System.Byte[],Garnet.server.ArgSlice,``0@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Perform Read operation in object store
            use this method in commands that return an array
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="objectStoreContext"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ObjectScan``1(Garnet.server.GarnetObjectType,Garnet.server.ArgSlice,System.Int64,System.String,System.Int32,Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Common functionality for executing SSCAN, HSCAN and ZSCAN
            </summary>
            <param name="objectType"></param>
            <param name="key">The key of the object</param>
            <param name="cursor">The value of the cursor</param>
            <param name="match">The pattern to match</param>
            <param name="count">Limit number for the response</param>
            <param name="items">The list of items for the response</param>
            <param name="objectStoreContext"></param>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessRespArrayOutput(Garnet.server.GarnetObjectStoreOutput,System.String@,System.Boolean)">
            <summary>
            Converts an array of elements in RESP format to ArgSlice[] type
            </summary>
            <param name="output">The RESP format output object</param>
            <param name="error">A description of the error, if there is any</param>
            <param name="isScanOutput">True when the output comes from HSCAN, ZSCAN OR SSCAN command</param>
            <returns></returns>
            <remarks>An RESP3 array in array will be flattened into the return array. RESP3 map/set types will be returned as arrays.</remarks>
            <example>"*2\r\n*2\r\n$1\r\na\r\n,0\r\n*2\r\n$1\r\nb\r\n,1\r\n" will return [a, 0, b, 1]</example>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessResp2ArrayOutput(Garnet.server.GarnetObjectStoreOutput,System.String@,System.Boolean)">
            <summary>
            Converts an array of elements in RESP format to ArgSlice[] type
            </summary>
            <param name="outputFooter">The RESP format output object</param>
            <param name="error">A description of the error, if there is any</param>
            <param name="isScanOutput">True when the output comes from HSCAN, ZSCAN OR SSCAN command</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessRespIntegerArrayOutput(Garnet.server.GarnetObjectStoreOutput,System.String@)">
            <summary>
            Converts an array of elements in RESP format to ArgSlice[] type
            </summary>
            <param name="output">The RESP format output object</param>
            <param name="error">A description of the error, if there is any</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessRespInt64ArrayOutput(Garnet.server.GarnetObjectStoreOutput,System.String@)">
            <summary>
            Converts an array of elements in RESP format to ArgSlice[] type
            </summary>
            <param name="output">The RESP format output object</param>
            <param name="error">A description of the error, if there is any</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessRespArrayOutputAsPairs(Garnet.server.GarnetObjectStoreOutput,System.String@)">
            <summary>
            Processes RESP output as pairs of score and member.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.ProcessRespSingleTokenOutput(Garnet.server.GarnetObjectStoreOutput)">
            <summary>
            Converts a single token in RESP format to ArgSlice type
            </summary>
            <param name="output">The RESP format output object</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.TryProcessRespSimple64IntOutput(Garnet.server.GarnetObjectStoreOutput,System.Int64@)">
            <summary>
            Converts a simple integer in RESP format to integer type
            </summary>
            <param name="output">The RESP format output object</param>
            <param name="value"></param>
            <returns>integer</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ReadObjectStoreOperation``1(System.Byte[],Garnet.server.ArgSlice,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Gets the value of the key store in the Object Store
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ReadObjectStoreOperation``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Gets the value of the key store in the Object Store
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ObjectScan``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Iterates members of a collection object using a cursor,
            a match pattern and count parameters
            </summary>
            <param name="key">The key of the sorted set</param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
        </member>
        <member name="M:Garnet.server.StorageSession.CompletePendingAndGetGarnetStatus``1(Tsavorite.core.Status,``0@,Garnet.server.GarnetObjectStoreOutput@)">
            <summary>
            Complete operation if pending and get GarnetStatus based on status returned from the Object Store
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="status"></param>
            <param name="objectStoreContext"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ObjectCollect``1(Garnet.server.ArgSlice,System.ReadOnlySpan{System.Byte},Garnet.common.SingleWriterMultiReaderLock,Garnet.server.ObjectInput@,``0@)">
            <summary>
            Collects objects from the object store based on the specified input and type.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="searchKey">The key to search for in the object store.</param>
            <param name="typeObject">The type of the object to collect.</param>
            <param name="collectLock">The lock to ensure single writer and multiple readers.</param>
            <param name="input">The input object for the operation.</param>
            <param name="objectContext">The context of the object store.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.CompletePendingForObjectStoreSession``1(Tsavorite.core.Status@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Handles the complete pending for Object Store session
            </summary>
            <param name="status"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
        </member>
        <member name="M:Garnet.server.StorageSession.HashSet``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@,System.Boolean)">
            <summary>
            HashSet: Sets the specified fields to their respective values in the hash stored at key.
            Values of specified fields that exist in the hash are overwritten.
            If key doesn't exist, a new hash is created.
            HashSetNX: Sets only if field does not yet exist. A new hash is created if it does not exists.
            If field exists the operation has no effect.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
            <param name="itemsDoneCount"></param>
            <param name="objectStoreContext"></param>
            <param name="nx"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashSet``1(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@,``0@)">
            <summary>
            Sets the specified fields to their respective values in the hash stored at key.
            Values of specified fields that exist in the hash are overwritten.
            If key doesn't exist, a new hash is created.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="elements"></param>
            <param name="itemsDoneCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashDelete``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@,System.Boolean)">
            <summary>
            Removes the specified field from the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="field"></param>
            <param name="itemsDoneCount"></param>
            <param name="objectStoreContext"></param>
            <param name="nx"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashDelete``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,``0@)">
            <summary>
            Removes the specified fields from the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="fields"></param>
            <param name="itemsDoneCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGet``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice@,``0@)">
            <summary>
            Returns the value associated with the field in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGetMultiple``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Returns the values associated with the fields in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="fields"></param>
            <param name="values"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGetAll``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Returns all fields and values of the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="values"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashLength``1(Garnet.server.ArgSlice,System.Int32@,``0@,System.Boolean)">
            <summary>
            Returns the number of fields contained in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="items"></param>
            <param name="objectStoreContext"></param>
            <param name="nx"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashExists``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean@,``0@)">
            <summary>
            Returns if field exists in the hash stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="field"></param>
            <param name="exists"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashRandomField``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice@,``0@)">
            <summary>
            Returns a random field from the hash value stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="field"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashRandomField``1(Garnet.server.ArgSlice,System.Int32,System.Boolean,Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Returns an array of distinct fields, the lenght is either count or the len of the hash,
            whichever is lower. If count is negative, it is allowed to return ssame field multiple times,
            in this case the fields returned is the absolute value of count.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="count"></param>
            <param name="withValues"></param>
            <param name="fields"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashSet``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Sets the specified fields to their respective values in the hash stored at key.
            Values of specified fields that exist in the hash are overwritten.
            If key doesn't exist, a new hash is created.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGet``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            HashGet: Returns the value associated with field in the hash stored at key.
            HashGetAll: Returns all fields and values of the hash stored at key.
            HashGetMultiple: Returns the values associated with the specified fields in the hash stored at key.
            HashRandomField: Returns a random field from the hash value stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGetAll``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns all fields and values of the hash stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashGetMultiple``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashRandomField``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns a random field from the hash value stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashLength``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns the number of fields contained in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashStrLength``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns the string length of the value associated with field in the hash stored at key. If the key or the field do not exist, 0 is returned.
            </summary>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <typeparam name="TObjectContext"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashDelete``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes the specified fields from the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashExists``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns if field exists in the hash stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashKeys``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns all field names in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashVals``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns all values in the hash key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashIncrement``1(System.Byte[],Garnet.server.ArgSlice,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Increments the number stored at field in the hash stored at key by increment.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashIncrement``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            HashIncrementByFloat: Increment the specified field of a hash stored at key,
            and representing a floating point number, by the specified increment.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashExpire``1(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Sets the expiration time for the specified key.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key for which to set the expiration time.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashTimeToLive``1(Garnet.server.ArgSlice,System.Boolean,System.Boolean,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the time-to-live (TTL) of a hash key.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the hash.</param>
            <param name="isMilliseconds">Indicates whether the TTL is in milliseconds.</param>
            <param name="isTimestamp">Indicates whether the TTL is a timestamp.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashPersist``1(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Removes the expiration time from a hash key, making it persistent.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the hash.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.HashCollect``1(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@,``0@)">
            <summary>
            Collects hash keys and performs a specified operation on them.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="keys">The keys to collect.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
            <remarks>
            If the first key is "*", all hash keys are scanned in batches and the operation is performed on each key.
            Otherwise, the operation is performed on the specified keys.
            </remarks>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPush``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],Garnet.server.ListOperation,System.Int32@,``0@)">
            <summary>
            Adds new elements at the head(right) or tail(left)
            in the list stored at key.
            For the case of ListPushX, the operation is only done if the key already exists
            and holds a list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">The name of the key</param>
            <param name="elements">The elements to be added at the left or the righ of the list</param>
            <param name="lop">The Right or Left modifier of the operation to perform</param>
            <param name="itemsDoneCount">The length of the list after the push operations.</param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPush``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ListOperation,System.Int32@,``0@)">
            <summary>
            Adds new elements at the head(right) or tail(left)
            in the list stored at key.
            For the case of ListPushX, the operation is only done if the key already exists
            and holds a list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="element"></param>
            <param name="lop"></param>
            <param name="itemsDoneCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPop``1(Garnet.server.ArgSlice,Garnet.server.ListOperation,``0@,Garnet.server.ArgSlice@)">
            <summary>
            Removes one element from the head(left) or tail(right)
            of the list stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="lop"></param>
            <param name="objectStoreContext"></param>
            <param name="element"></param>
            <returns>The popped element</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPop``1(Garnet.server.ArgSlice,System.Int32,Garnet.server.ListOperation,``0@,Garnet.server.ArgSlice[]@)">
            <summary>
            Removes the count elements from the head(left) or tail(right) of the list stored at key.
            If the list contains less than count elements, removes and returns the number of elements in the list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="count"></param>
            <param name="lop"></param>
            <param name="objectStoreContext"></param>
            <param name="elements"></param>
            <returns>The count elements popped from the list</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPopMultiple``1(Garnet.server.ArgSlice[],Garnet.server.OperationDirection,System.Int32,``0@,Garnet.server.ArgSlice@,Garnet.server.ArgSlice[]@)">
            <summary>
            Removes the count elements from the head(left) or tail(right) of the first non-empty list key from the list of provided key names.
            If the list contains less than count elements, removes and returns the number of elements in the list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="keys"></param>
            <param name="direction"></param>
            <param name="count"></param>
            <param name="objectContext"></param>
            <param name="key"></param>
            <param name="elements"></param>
            <returns>The count elements popped from the list</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListLength``1(Garnet.server.ArgSlice,``0@,System.Int32@)">
            <summary>
            Gets the current count of elements in the List at Key
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="objectStoreContext"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.OperationDirection,Garnet.server.OperationDirection,System.Byte[]@)">
            <summary>
            Removes the first/last element of the list stored at source
            and pushes it to the first/last element of the list stored at destination
            </summary>
            <param name="sourceKey"></param>
            <param name="destinationKey"></param>
            <param name="sourceDirection"></param>
            <param name="destinationDirection"></param>
            <param name="element">out parameter, The element being popped and pushed</param>
            <returns>GarnetStatus</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListTrim``1(Garnet.server.ArgSlice,System.Int32,System.Int32,``0@)">
            <summary>
            Trim an existing list so it only contains the specified range of elements.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="start"></param>
            <param name="stop"></param>
            <param name="objectStoreContext"></param>
            <returns>true when successful</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPush``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Adds new elements at the head(right) or tail(left)
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPosition``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            The command returns the index of matching elements inside a Redis list.
            By default, when no options are given, it will scan the list from head to tail, looking for the first match of "element".
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListTrim``1(System.Byte[],Garnet.server.ObjectInput@,``0@)">
            <summary>
            Trim an existing list so it only contains the specified range of elements.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListRange``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Gets the specified elements of the list stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListInsert``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Inserts a new element in the list stored at key either before or after a value pivot
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListIndex``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the element at index.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListRemove``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes the first count occurrences of elements equal to element from the list.
            LREM key count element
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListPop``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Removes the count elements from the head(left) or tail(right) of the list stored at key.
            If the list contains less than count elements, removes and returns the number of elements in the list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListLength``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes the count elements from the head(left) or tail(right) of the list stored at key.
            If the list contains less than count elements, removes and returns the number of elements in the list.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.ListSet``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Sets the list element at index to element.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetAdd``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
             Adds the specified member to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">ArgSlice with key</param>
            <param name="member"></param>
            <param name="saddCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetAdd``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,``0@)">
            <summary>
             Adds the specified members to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">ArgSlice with key</param>
            <param name="members"></param>
            <param name="saddCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetRemove``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
            Removes the specified member from the set.
            Members that are not in the set are ignored.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">ArgSlice with key</param>
            <param name="member"></param>
            <param name="sremCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetRemove``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32@,``0@)">
            <summary>
            Removes the specified members from the set.
            Specified members that are not a member of the set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key">ArgSlice with key</param>
            <param name="members"></param>
            <param name="sremCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetLength``1(Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
            Returns the number of elements of the set.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="count"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetMembers``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Returns all members of the set at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="members"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetPop``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice@,``0@)">
            <summary>
            Removes and returns one random member from the set at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="element"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetPop``1(Garnet.server.ArgSlice,System.Int32,Garnet.server.ArgSlice[]@,``0@)">
            <summary>
            Removes and returns up to count random members from the set at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="count"></param>
            <param name="elements"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetMove(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@)">
            <summary>
            Moves a member from a source set to a destination set.
            If the move was performed, this command returns 1.
            If the member was not found in the source set, or if no operation was performed, this command returns 0.
            </summary>
            <param name="sourceKey"></param>
            <param name="destinationKey"></param>
            <param name="member"></param>
            <param name="smoveResult"></param>
        </member>
        <member name="M:Garnet.server.StorageSession.SetIntersect(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the intersection of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="keys"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetIntersectStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SINTER, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key"></param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetUnion(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the union of all the given sets.
            Keys that do not exist are considered to be empty sets.
            </summary>
            <param name="keys"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetUnionStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SUNION, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key"></param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetAdd``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
             Adds the specified members to the set at key.
             Specified members that are already a member of this set are ignored.
             If key does not exist, a new set is created.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetRemove``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes the specified members from the set.
            Specified members that are not a member of this set are ignored.
            If key does not exist, this command returns 0.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetLength``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns the number of elements of the set.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetMembers``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns all members of the set at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetIsMember``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns if member is a member of the set stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetIsMember``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice[],System.Int32[]@,``0@)">
            <summary>
            Returns whether each member is a member of the set stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="members"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetPop``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Removes and returns one or more random members from the set at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetRandomMember``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            When called with just the key argument, return a random element from the set value stored at key.
            If the provided count argument is positive, return an array of distinct elements.
            The array's length is either count or the set's cardinality (SCARD), whichever is lower.
            If called with a negative count, the behavior changes and the command is allowed to return the same element multiple times.
            In this case, the number of returned elements is the absolute value of the specified count.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetDiff(Garnet.server.ArgSlice[],System.Collections.Generic.HashSet{System.Byte[]}@)">
            <summary>
            Returns the members of the set resulting from the difference between the first set at key and all the successive sets at keys.
            </summary>
            <param name="keys"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetDiffStore(System.Byte[],Garnet.server.ArgSlice[],System.Int32@)">
            <summary>
            This command is equal to SDIFF, but instead of returning the resulting set, it is stored in destination.
            If destination already exists, it is overwritten.
            </summary>
            <param name="key">destination</param>
            <param name="keys"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <summary>
            Returns the cardinality of the intersection of all the given sets.
            </summary>
            <param name="keys"></param>
            <param name="limit">Optional limit for stopping early when reaching this size</param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GeoAdd``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Adds the specified geospatial items (longitude, latitude, name) to the specified key.
            Data is stored into the key as a sorted set.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GeoCommands``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            GEOHASH: Returns valid Geohash strings representing the position of one or more elements in a geospatial data of the sorted set.
            GEODIST: Returns the distance between two members in the geospatial index represented by the sorted set.
            GEOPOS: Returns the positions (longitude,latitude) of all the specified members in the sorted set.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GeoSearchReadOnly``1(Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            Geospatial search and return result..
            GEOSEARCH: Returns the members of a sorted set populated with geospatial data, which are within the borders of the area specified by a given shape.
            GEORADIUS (read variant): Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUS_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUSBYMEMBER (read variant): Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            GEORADIUSBYMEMBER_RO: Return the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="opts"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.GeoSearchStore``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.GeoSearchOptions@,Garnet.server.ObjectInput@,Tsavorite.core.SpanByteAndMemory@,``0@)">
            <summary>
            Geospatial search and store in destination key.
            GEOSEARCHSTORE: Store the the members of a sorted set populated with geospatial data, which are within the borders of the area specified by a given shape.
            GEORADIUS (write variant): Store the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center and radius.
            GEORADIUSBYMEMBER (write variant): Store the members of a sorted set populated with geospatial data, which are inside the circular area delimited by center (derived from member) and radius.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="destination"></param>
            <param name="opts"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetAdd``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
            Adds the specified member and score to the sorted set stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="score"></param>
            <param name="member"></param>
            <param name="zaddCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetAdd``1(Garnet.server.ArgSlice,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[],System.Int32@,``0@)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key.
            Current members get the score updated and reordered.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="inputs"></param>
            <param name="zaddCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemove``1(System.Byte[],Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
            Removes the specified member from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="member"></param>
            <param name="zremCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemove``1(System.Byte[],Garnet.server.ArgSlice[],System.Int32@,``0@)">
            <summary>
            Removes the specified members from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="members"></param>
            <param name="zremCount"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemoveRangeByLex``1(Garnet.server.ArgSlice,System.String,System.String,System.Int32@,``0@)">
            <summary>
            Removes all elements in the range specified by min and max, having the same score.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="countRemoved"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemoveRangeByScore``1(Garnet.server.ArgSlice,System.String,System.String,System.Int32@,``0@)">
            <summary>
            Removes all elements that have a score in the range specified by min and max.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="countRemoved"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemoveRangeByRank``1(Garnet.server.ArgSlice,System.Int32,System.Int32,System.Int32@,``0@)">
            <summary>
            Removes all elements with the index in the range specified by start and stop.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="start"></param>
            <param name="stop"></param>
            <param name="countRemoved"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetPop``1(Garnet.server.ArgSlice,System.Int32,System.Boolean,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@,``0@)">
            <summary>
            Removes and returns up to count members with the highest or lowest scores in the sorted set stored at key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="count"></param>
            <param name="lowScoresFirst">When true return the lowest scores, otherwise the highest.</param>
            <param name="pairs"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIncrement``1(Garnet.server.ArgSlice,System.Double,Garnet.server.ArgSlice,System.Double@,``0@)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment.
            Returns the new score of member.
            If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0).
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="increment"></param>
            <param name="member"></param>
            <param name="newScore"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetLength``1(Garnet.server.ArgSlice,System.Int32@,``0@)">
             <summary>
            
             </summary>
             <typeparam name="TObjectContext"></typeparam>
             <param name="key"></param>
             <param name="zcardCount"></param>
             <param name="objectStoreContext"></param>
             <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRange``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.SortedSetOrderOperation,``0@,Garnet.server.ArgSlice[]@,System.String@,System.Boolean,System.Boolean,System.ValueTuple{System.String,System.Int32})">
            <summary>
            Returns the specified range of elements in the sorted set stored at key, using byscore, bylex and rev modifiers.
            Min and max are range boundaries, where 0 is the first element, 1 is the next element and so on.
            There can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="sortedSetOrderOperation"></param>
            <param name="objectContext"></param>
            <param name="elements"></param>
            <param name="error"></param>
            <param name="withScores"></param>
            <param name="reverse"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetDifference(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <summary>
            Computes the difference between the first and all successive sorted sets and returns resulting pairs.
            </summary>
            <param name="keys"></param>
            <param name="pairs"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetDifferenceStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32@)">
            <summary>
            Computes the difference between the first and all successive sorted sets and store resulting pairs in the destination key.
            </summary>
            <param name="keys"></param>
            <param name="destinationKey"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRank``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Boolean,System.Nullable{System.Int64}@,``0@)">
            <summary>
            Returns the rank of member in the sorted set, the scores in the sorted set are ordered from high to low
            <param name="key">The key of the sorted set</param>
            <param name="member">The member to get the rank</param>
            <param name="reverse">If true, the rank is calculated from low to high</param>
            <param name="rank">The rank of the member (null if the member does not exist)</param>
            <param name="objectStoreContext"></param>
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetAdd``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key.
            Current members get the score updated and reordered.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRangeStore``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ObjectInput@,System.Int32@,``0@)">
            <summary>
            ZRANGESTORE - Stores a range of sorted set elements into a destination key.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="dstKey">The destination key where the range will be stored.</param>
            <param name="srcKey">The source key from which the range will be taken.</param>
            <param name="input">The input object containing range parameters.</param>
            <param name="result">The result of the operation, indicating the number of elements stored.</param>
            <param name="objectStoreContext">The context of the object store.</param>
            <returns>Returns a GarnetStatus indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemove``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes the specified members from the sorted set stored at key.
            Non existing members are ignored.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetLength``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns the number of members of the sorted set.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRange``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key.
            Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next element and so on.
            There can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetScore``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the score of member in the sorted set at key.
            If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetScores``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the scores of members in the sorted set at key.
            For every member that does not exist in the sorted set, or if the key does not exist, nil is returned.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetPop``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Removes and returns the first element from the sorted set stored at key,
            with the scores ordered from low to high (min) or high to low (max).
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetCount``1(Garnet.server.ArgSlice,Garnet.server.ArgSlice,Garnet.server.ArgSlice,System.Int32@,``0@)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="minScore"></param>
            <param name="maxScore"></param>
            <param name="numElements"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetCount``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemoveRangeByLex``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Removes all elements in the sorted set between the
            lexicographical range specified by min and max.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetLengthByValue``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.ObjectOutputHeader@,``0@)">
            <summary>
            Returns the number of elements in the sorted set with a value between min and max.
            When all the elements in a sorted set have the same score,
            this command forces lexicographical ordering.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIncrement``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment.
            If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0).
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRemoveRange``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            ZREMRANGEBYRANK: Removes all elements in the sorted set stored at key with rank between start and stop.
            Both start and stop are 0 -based indexes with 0 being the element with the lowest score.
            ZREMRANGEBYSCORE: Removes all elements in the sorted set stored at key with a score between min and max (inclusive by default).
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRank``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the rank of member in the sorted set, the scores in the sorted set are ordered from low to high
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetRandomMember``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns a random member from the sorted set key.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetScan``1(System.Byte[],Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Iterates members of SortedSet key and their associated scores using a cursor,
            a match pattern and count parameters.
            </summary>
            <typeparam name="TObjectContext"></typeparam>
            <param name="key"></param>
            <param name="input"></param>
            <param name="output"></param>
            <param name="objectStoreContext"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetMPop(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32,System.Boolean,Garnet.server.ArgSlice@,System.ValueTuple{Garnet.server.ArgSlice,Garnet.server.ArgSlice}[]@)">
            <summary>
            Removes and returns up to count members and their scores from the first sorted set that contains a member.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIntersectLength(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Nullable{System.Int32},System.Int32@)">
            <summary>
            Computes the cardinality of the intersection of multiple sorted sets.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIntersectStore(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Int32@)">
            <summary>
            Computes the intersection of multiple sorted sets and stores the resulting sorted set at destinationKey.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIntersect(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,System.Collections.Generic.SortedSet{System.ValueTuple{System.Double,System.Byte[]}}@)">
            <summary>
            Computes the intersection of multiple sorted sets and returns the result with optional weights and aggregate type.
            </summary>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetIntersection``1(System.ReadOnlySpan{Garnet.server.ArgSlice},System.Double[],Garnet.server.SortedSetAggregateType,``0@,System.Collections.Generic.Dictionary{System.Byte[],System.Double}@)">
            <summary>
            Computes the intersection of multiple sorted sets and returns the result with optional weights and aggregate type.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="keys">The keys of the sorted sets to intersect.</param>
            <param name="weights">The weights to apply to each sorted set's scores. If null, no weights are applied.</param>
            <param name="aggregateType">The type of aggregation to use (Sum, Min, Max).</param>
            <param name="objectContext">The object context.</param>
            <param name="pairs">The resulting dictionary of intersected elements and their scores.</param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetExpire``1(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Sets the expiration time for the specified key.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key for which to set the expiration time.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetExpire``1(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.DateTimeOffset,Garnet.server.ExpireOption,System.Int32[]@,``0@)">
            <summary>
            Sets the expiration time for the specified key and fields in a sorted set.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members within the sorted set to set the expiration time for.</param>
            <param name="expireAt">The expiration time as a DateTimeOffset.</param>
            <param name="expireOption">The expiration option to use.</param>
            <param name="results">The results of the operation, indicating the number of fields that were successfully set to expire.</param>
            <param name="objectContext">The context of the object store.</param>
            <returns>Returns a GarnetStatus indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetTimeToLive``1(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Returns the time-to-live (TTL) of a SortedSet member.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the hash.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetTimeToLive``1(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.TimeSpan[]@,``0@)">
            <summary>
            Returns the time-to-live (TTL) of a SortedSet member.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members within the sorted set to get the TTL for.</param>
            <param name="expireIn">The array of TimeSpan representing the TTL for each member.</param>
            <param name="objectContext">The context of the object store.</param>
            <returns>Returns a GarnetStatus indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetPersist``1(Garnet.server.ArgSlice,Garnet.server.ObjectInput@,Garnet.server.GarnetObjectStoreOutput@,``0@)">
            <summary>
            Removes the expiration time from a SortedSet member, making it persistent.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the SortedSet.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="output">The output footer object to store the result.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetPersist``1(Garnet.server.ArgSlice,System.ReadOnlySpan{Garnet.server.ArgSlice},System.Int32[]@,``0@)">
            <summary>
            Removes the expiration time from the specified members in the sorted set stored at the given key.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="key">The key of the sorted set.</param>
            <param name="members">The members whose expiration time will be removed.</param>
            <param name="results">The results of the operation, indicating the number of members whose expiration time was successfully removed.</param>
            <param name="objectContext">The context of the object store.</param>
            <returns>Returns a GarnetStatus indicating the success or failure of the operation.</returns>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetCollect``1(System.ReadOnlySpan{Garnet.server.ArgSlice},Garnet.server.ObjectInput@,``0@)">
            <summary>
            Collects SortedSet keys and performs a specified operation on them.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="keys">The keys to collect.</param>
            <param name="input">The input object containing the operation details.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
            <remarks>
            If the first key is "*", all SortedSet keys are scanned in batches and the operation is performed on each key.
            Otherwise, the operation is performed on the specified keys.
            </remarks>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetCollect``1(``0@)">
            <summary>
            Collects SortedSet keys and performs a specified operation on them.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
            <remarks>
            If the first key is "*", all SortedSet keys are scanned in batches and the operation is performed on each key.
            Otherwise, the operation is performed on the specified keys.
            </remarks>
        </member>
        <member name="M:Garnet.server.StorageSession.SortedSetCollect``1(System.ReadOnlySpan{Garnet.server.ArgSlice},``0@)">
            <summary>
            Collects SortedSet keys and performs a specified operation on them.
            </summary>
            <typeparam name="TObjectContext">The type of the object context.</typeparam>
            <param name="keys">The keys to collect.</param>
            <param name="objectContext">The object context for the operation.</param>
            <returns>The status of the operation.</returns>
            <remarks>
            If the first key is "*", all SortedSet keys are scanned in batches and the operation is performed on each key.
            Otherwise, the operation is performed on the specified keys.
            </remarks>
        </member>
        <member name="F:Garnet.server.StorageSession.basicContext">
            <summary>
            Session Contexts for main store
            </summary>
        </member>
        <member name="F:Garnet.server.StorageSession.objectStoreBasicContext">
            <summary>
            Session Contexts for object store
            </summary>
        </member>
        <member name="T:Garnet.server.MemoryUtils">
            <summary>
            Utility class for memory related operations.
            </summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.ByteArrayOverhead">
            <summary>.Net object overhead for byte arrays</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.ListOverhead">
            <summary>.Net object overhead for list</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.ListEntryOverhead">
            <summary>.Net object avg. overhead for holding a list node entry</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.SortedSetOverhead">
            <summary>.Net object overhead for sorted set</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.SortedSetEntryOverhead">
            <summary>.Net object avg. overhead for holding a sorted set entry</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.DictionaryOverhead">
            <summary>.Net object overhead for dictionary</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.DictionaryEntryOverhead">
            <summary>.Net object avg. overhead for holding a dictionary entry</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.HashSetOverhead">
            <summary>.Net object overhead for hash set</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.HashSetEntryOverhead">
            <summary>.Net object avg. overhead for holding a hash set entry</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.PriorityQueueOverhead">
            <summary>.Net object overhead for priority queue</summary>
        </member>
        <member name="F:Garnet.server.MemoryUtils.PriorityQueueEntryOverhead">
            <summary>.Net object avg. overhead for holding a priority queue entry</summary>
        </member>
        <member name="T:Garnet.server.CacheSizeTracker">
            <summary>
            Tracks the size of the main log and read cache. 
            Based on the current size and the target size, it uses the corresponding LogSizeTracker objects to increase
            or decrease memory utilization.
            </summary>
        </member>
        <member name="P:Garnet.server.CacheSizeTracker.TargetSize">
            <summary>
            Total memory size target
            </summary>
        </member>
        <member name="T:Garnet.server.CacheSizeTracker.LogSizeCalculator">
            <summary>Helps calculate size of a record including heap memory in Object store.</summary>
        </member>
        <member name="M:Garnet.server.CacheSizeTracker.LogSizeCalculator.CalculateRecordSize(Tsavorite.core.RecordInfo,System.Byte[],Garnet.server.IGarnetObject)">
            <summary>Calculate the size of a record in the cache</summary>
            <param name="recordInfo">Information about the record</param>
            <param name="key">The record's key</param>
            <param name="value">The record's value</param>
            <returns>The size of the record</returns>
        </member>
        <member name="M:Garnet.server.CacheSizeTracker.#ctor(Tsavorite.core.TsavoriteKV{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.StoreFunctions{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.ByteArrayKeyComparer,Tsavorite.core.DefaultRecordDisposer{System.Byte[],Garnet.server.IGarnetObject}},Tsavorite.core.GenericAllocator{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.StoreFunctions{System.Byte[],Garnet.server.IGarnetObject,Tsavorite.core.ByteArrayKeyComparer,Tsavorite.core.DefaultRecordDisposer{System.Byte[],Garnet.server.IGarnetObject}}}},Tsavorite.core.KVSettings{System.Byte[],Garnet.server.IGarnetObject},System.Int64,System.Int64,Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>Class to track and update cache size</summary>
            <param name="store">Tsavorite store instance</param>
            <param name="logSettings">Hybrid log settings</param>
            <param name="targetSize">Total memory size target</param>
            <param name="readCacheTargetSize">Target memory size for read cache</param>
            <param name="loggerFactory"></param>
        </member>
        <member name="M:Garnet.server.CacheSizeTracker.AddTrackedSize(System.Int64)">
            <summary>Add to the tracked size of the cache.</summary>
            <param name="size">Size to be added</param>
        </member>
        <member name="M:Garnet.server.CacheSizeTracker.AddReadCacheTrackedSize(System.Int64)">
            <summary>Add to the tracked size of read cache.</summary>
            <param name="size">Size to be added</param>
        </member>
        <member name="M:Garnet.server.CacheSizeTracker.TryPreventStart">
            <summary>
            If tracker has not started, prevent it from starting
            </summary>
            <returns>True if tracker hasn't previously started</returns>
        </member>
        <member name="T:Garnet.server.StoreWrapper">
            <summary>
            Wrapper for store and store-specific information
            </summary>   
        </member>
        <member name="P:Garnet.server.StoreWrapper.DefaultDatabase">
            <summary>
            Default database (DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.store">
            <summary>
            Store (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.objectStore">
            <summary>
            Object store (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.appendOnlyFile">
            <summary>
            AOF (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.lastSaveTime">
            <summary>
            Last save time (of DB 0)
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.objectStoreSizeTracker">
            <summary>
            Object store size tracker (of DB 0)
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.serverOptions">
            <summary>
            Server options
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.subscribeBroker">
            <summary>
            Subscribe broker
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.Servers">
            <summary>
            Get servers
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.accessControlList">
            <summary>
            Access control list governing all commands
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.loggerFactory">
            <summary>
            Logger factory
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.GarnetObjectSerializer">
            <summary>
            Object serializer
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.logger">
            <summary>
            The main logger instance associated with this store.
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.storeScriptCache">
            <summary>
            Lua script cache
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.loggingFrequency">
            <summary>
            Logging frequency
            </summary>
        </member>
        <member name="T:Garnet.server.StoreWrapper.DatabaseCreatorDelegate">
            <summary>
            Definition for delegate creating a new logical database
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.DatabaseCount">
            <summary>
            Number of active databases
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.MaxDatabaseId">
            <summary>
            Current max database ID
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.luaTimeoutManager">
            <summary>
            Shared timeout manager for all <see cref="T:Garnet.server.LuaRunner"/> across all sessions.
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.taskManager">
            <summary>
            Background task manager instance
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.RunId">
            <summary>
            Run ID identifies instance history when taking a checkpoint.
            </summary>
        </member>
        <member name="F:Garnet.server.StoreWrapper.disposed">
            <summary>
            True if StoreWrapper instance is disposed
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.StoreCheckpointManager">
            <summary>
            Garnet checkpoint manager for main store
            </summary>
        </member>
        <member name="P:Garnet.server.StoreWrapper.ObjectStoreCheckpointManager">
            <summary>
            Garnet checkpoint manager for object store
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.#ctor(System.String,System.String,Garnet.server.IGarnetServer[],Garnet.server.CustomCommandManager,Garnet.server.GarnetServerOptions,Garnet.server.SubscribeBroker,Garnet.server.ACL.AccessControlList,Garnet.server.StoreWrapper.DatabaseCreatorDelegate,Garnet.server.IDatabaseManager,Garnet.server.IClusterFactory,Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.#ctor(Garnet.server.StoreWrapper,System.Boolean)">
            <summary>
            Copy Constructor
            </summary>
            <param name="storeWrapper">Source instance</param>
            <param name="recordToAof">Enable AOF in database manager</param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.GetClusterEndpoint">
            <summary>
            Get IP
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TakeCheckpoint(System.Boolean,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Take checkpoint of all active databases
            </summary>
            <param name="background">True if method can return before checkpoint is taken</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>False if another checkpointing process is already in progress</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TakeCheckpoint(System.Boolean,System.Int32,Microsoft.Extensions.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
            Take checkpoint of all active database IDs or a specified database ID
            </summary>
            <param name="background">True if method can return before checkpoint is taken</param>
            <param name="dbId">ID of database to checkpoint (default: -1 - checkpoint all active databases)</param>
            <param name="logger">Logger</param>
            <param name="token">Cancellation token</param>
            <returns>False if another checkpointing process is already in progress</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TakeOnDemandCheckpoint(System.DateTimeOffset,System.Int32)">
            <summary>
            Take a checkpoint if no checkpoint was taken after the provided time offset
            </summary>
            <param name="entryTime"></param>
            <param name="dbId"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.RecoverCheckpoint(System.Boolean,System.Boolean,System.Boolean,Garnet.server.CheckpointMetadata)">
            <summary>
            Recover checkpoint
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TryPauseCheckpoints(System.Int32)">
            <summary>
            Mark the beginning of a checkpoint by taking and a lock to avoid concurrent checkpointing
            </summary>
            <param name="dbId">ID of database to lock</param>
            <returns>True if lock acquired</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.ResumeCheckpoints(System.Int32)">
            <summary>
            Release checkpoint task lock
            </summary>
            <param name="dbId">ID of database to unlock</param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.RecoverAOF">
            <summary>
            Recover AOF
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.ReplayAOF(System.Int64)">
            <summary>
            When replaying AOF we do not want to write AOF records again.
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.EnqueueCommit(Garnet.server.AofEntryType,System.Int64,System.Int32)">
            <summary>
            Append a checkpoint commit to the AOF
            </summary>
            <param name="entryType"></param>
            <param name="version"></param>
            <param name="dbId"></param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.CommitAOF(System.Boolean)">
            <summary>
            Commit AOF for all active databases
            </summary>
            <param name="spinWait">True if should wait until all commits complete</param>
            <returns>false if config prevents committing to AOF</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.WaitForCommit">
            <summary>
            Wait for commits from all active databases
            </summary>
            <returns>false if config prevents committing to AOF</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.WaitForCommitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously wait for commits from all active databases
            </summary>
            <param name="token">Cancellation token</param>
            <returns>false if commit is skipped for config reasons</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.CommitAOFAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously wait for AOF commits on all active databases,
            unless specific database ID specified (by default: -1 = all)
            </summary>
            <param name="dbId">Specific database ID to commit AOF for (optional)</param>
            <param name="token">Cancellation token</param>
            <returns>false if commit is skipped for config reasons</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.CreateFunctionsState(System.Int32,System.Byte)">
            <summary>
            Create database functions state
            </summary>
            <param name="dbId">Database ID</param>
            <returns>Functions state</returns>
            <exception cref="T:Garnet.common.GarnetException"></exception>
        </member>
        <member name="M:Garnet.server.StoreWrapper.Reset(System.Int32)">
            <summary>
            Reset
            </summary>
            <param name="dbId">Database ID</param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.GetDatabasesSnapshot">
            <summary>
            Get a snapshot of all active databases
            </summary>
            <returns>Array of active databases</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TryGetDatabase(System.Int32,Garnet.server.GarnetDatabase@)">
            <summary>
            Get database DB ID
            </summary>
            <param name="dbId">DB Id</param>
            <param name="database">Retrieved database</param>
            <returns>True if database was found</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TryGetOrAddDatabase(System.Int32,Garnet.server.GarnetDatabase@,System.Boolean@)">
            <summary>
            Try to get or add a new database
            </summary>
            <param name="dbId">Database ID</param>
            <param name="database">Retrieved or added database</param>
            <param name="added">True if database was added</param>
            <returns>True if database was found or added</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.FlushDatabase(System.Boolean,System.Int32)">
            <summary>
            Flush database with specified ID
            </summary>
            <param name="unsafeTruncateLog">Truncate log</param>
            <param name="dbId">Database ID</param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.FlushAllDatabases(System.Boolean)">
            <summary>
            Flush all active databases 
            </summary>
            <param name="unsafeTruncateLog">Truncate log</param>
        </member>
        <member name="M:Garnet.server.StoreWrapper.TrySwapDatabases(System.Int32,System.Int32)">
            <summary>
            Try to swap between two database instances
            </summary>
            <param name="dbId1">First database ID</param>
            <param name="dbId2">Second database ID</param>
            <returns>True if swap successful</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.ResetRevivificationStats">
            <summary>
            Resets the revivification stats.
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.ExpiredKeyDeletionScan(System.Int32)">
            <summary>
            Expired key deletion scan for a specific database ID.
            </summary>
            <param name="dbId"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.IndexAutoGrowTask(System.Threading.CancellationToken)">
            <summary>
            Grows indexes of both main store and object store if current size is too small.
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.CheckMultiDatabaseCompatibility">
            <summary>
            Check if database manager supports multiple databases. 
            If not - try to swap it with a new MultiDatabaseManager.
            </summary>
            <returns>True if database manager supports multiple databases</returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Garnet.server.StoreWrapper.SuspendPrimaryOnlyTasks">
            <summary>
            Suspend background task that may interfere with the replicas AOF
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.StartPrimaryTasks">
            <summary>
            Start background maintenance tasks that should only run when this node is a primary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.StoreWrapper.StartGenericNodeTasks">
            <summary>
            Start background maintenance generic tasks
            </summary>
        </member>
        <member name="T:Garnet.server.TaskManager">
            <summary>
            Create a new TaskManager instance
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:Garnet.server.TaskManager.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Create a new TaskManager instance
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:Garnet.server.TaskManager.IsRunning(Garnet.server.TaskType)">
            <summary>
            Check if task associated with provided TaskType is running
            </summary>
            <param name="taskType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TaskManager.IsRegistered(Garnet.server.TaskType)">
            <summary>
            Check if task is still registered
            </summary>
            <param name="taskType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TaskManager.Dispose">
            <summary>
            Dispose TaskManager instance
            </summary>
        </member>
        <member name="M:Garnet.server.TaskManager.RegisterAndRun(Garnet.server.TaskType,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Boolean)">
            <summary>
            Register and start new task using the provider taskType and taskFactory
            </summary>
            <param name="taskType">Task type</param>
            <param name="taskFactory">Task factory</param>
            <param name="cleanupOnCompletion">Whether to remove task from task manager registry on completion.</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Garnet.server.TaskManager.Cancel(Garnet.server.TaskType)">
            <summary>
            Cancel task associated with the provided TaskType
            </summary>
            <param name="taskType"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TaskManager.Cancel(Garnet.server.TaskPlacementCategory)">
            <summary>
            Cancel tasks associated with the provided TaskPlacementCategory
            </summary>
            <param name="taskPlacementCategory"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TaskManager.Wait(Garnet.server.TaskType,System.Threading.CancellationToken)">
            <summary>
            Wait for task associated with the provided TaskType to complete.
            </summary>
            <param name="taskType"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TaskManager.WaitAsync(Garnet.server.TaskType,System.Threading.CancellationToken)">
            <summary>
            WaitAsync for task associated with the provided TaskType to complete.
            </summary>
            <param name="taskType"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.TaskMetadata">
            <summary>
            Represents metadata and control objects for a background maintenance task.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskMetadata.Cts">
            <summary>
            Cancellation token source associated with this specific task
            </summary>
        </member>
        <member name="F:Garnet.server.TaskMetadata.Task">
            <summary>
            The running task instance
            </summary>
        </member>
        <member name="T:Garnet.server.TaskPlacementCategory">
            <summary>
            Specifies the placement constraints for background tasks.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskPlacementCategory.All">
            <summary>
            Indicates that this task can safely run on all node types.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskPlacementCategory.Primary">
            <summary>
            Indicates that this task can safely run only on primary nodes.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskPlacementCategory.Replica">
            <summary>
            Indicates that this task can safely run only on replica nodes.
            </summary>
        </member>
        <member name="T:Garnet.server.TaskType">
            <summary>
            Defines the types of background maintenance tasks that can be managed by the TaskManager.
            These tasks represent various server operations that run asynchronously to maintain
            system health, performance, and data integrity.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.AofSizeLimitTask">
            <summary>
            Monitors AOF size and triggers checkpoints when size limit is exceeded.
            <para>See <see cref="M:Garnet.server.StoreWrapper.AutoCheckpointBasedOnAofSizeLimit(System.Int64,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)"/> for implementation.</para>
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.CommitTask">
            <summary>
            Periodically commits AOF data to ensure durability.
            <para>See <see cref="M:Garnet.server.StoreWrapper.CommitTask(System.Int32,System.Threading.CancellationToken,Microsoft.Extensions.Logging.ILogger)"/> for implementation.</para>
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.CompactionTask">
            <summary>
            Performs log compaction to reclaim space from deleted records.
            <para>See <see cref="M:Garnet.server.StoreWrapper.CompactionTask(System.Int32,System.Threading.CancellationToken)"/> for implementation.</para>
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.ObjectCollectTask">
            <summary>
            Collects expired members from object store collections.
            <para>See <see cref="M:Garnet.server.StoreWrapper.ObjectCollectTask(System.Int32,System.Threading.CancellationToken)"/> for implementation.</para>
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.ExpiredKeyDeletionTask">
            <summary>
            Scans and removes expired keys from main and object stores.
            <para>See <see cref="M:Garnet.server.StoreWrapper.ExpiredKeyDeletionScanTask(System.Int32,System.Threading.CancellationToken)"/> for implementation.</para>
            </summary>
        </member>
        <member name="F:Garnet.server.TaskType.IndexAutoGrowTask">
            <summary>
            Automatically grows hash table indexes when overflow thresholds are met.
            <para>See <see cref="M:Garnet.server.StoreWrapper.IndexAutoGrowTask(System.Threading.CancellationToken)"/> for implementation.</para>
            </summary>
        </member>
        <member name="T:Garnet.server.TaskTypeExtensions">
            <summary>
            Provides extensions and utilities for TaskType to TaskPlacementCategory mapping.
            </summary>
        </member>
        <member name="F:Garnet.server.TaskTypeExtensions.TaskPlacementMapping">
            <summary>
            Array mapping task types to their placement categories by enum index.
            </summary>
        </member>
        <member name="M:Garnet.server.TaskTypeExtensions.#cctor">
            <summary>
            Static constructor to initialize the TaskPlacementMapping array.
            </summary>
        </member>
        <member name="M:Garnet.server.TaskTypeExtensions.GetTaskTypes(Garnet.server.TaskPlacementCategory)">
            <summary>
            Retrieves task types for a placement category.
            </summary>
            <param name="lookupPlacementCategory">The placement category to filter by.</param>
            <returns>An enumerable of task types that match the placement category.</returns>
        </member>
        <member name="M:Garnet.server.TaskTypeExtensions.MatchPlacementCategory(Garnet.server.TaskPlacementCategory,Garnet.server.TaskPlacementCategory)">
            <summary>
            Determines if a task placement matches the lookup placement category.
            </summary>
            <param name="taskPlacementCategory">The task's assigned placement.</param>
            <param name="lookupPlacementCategory">The lookup placement category.</param>
            <returns>True if the task can run on the lookup placement.</returns>
        </member>
        <member name="T:Garnet.server.TLS.CertificateUtils">
            <summary>
            CertificateUtils
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.CertificateUtils.GetMachineCertificateBySubjectName(System.String)">
            <summary>
            Gets machine certificate by subject name
            </summary>
            <param name="subjectName"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Garnet.server.TLS.CertificateUtils.GetMachineCertificateByFile(System.String,System.String)">
            <summary>
            Gets machine certificate by file name
            </summary>
            <param name="fileName"></param>
            <param name="password"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:Garnet.server.TLS.GarnetTlsOptions">
            <summary>
            A sample Garnet TLS options class provided for default validations.
            NOTE: Do not use in production without verifying the implementation yourself. This class
            can be replaced with your own implementation when instantiating GarnetServerOptions.
            </summary>
        </member>
        <member name="P:Garnet.server.TLS.GarnetTlsOptions.TlsServerOptions">
            <summary>
            TLS Server Options
            </summary>
        </member>
        <member name="P:Garnet.server.TLS.GarnetTlsOptions.TlsClientOptions">
            <summary>
            TLS Client Options
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.GarnetTlsOptions.ClientCertificateRequired">
            <summary>
            Whether server requires a valid client certificate
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.GarnetTlsOptions.ServerCertificateRequired">
            <summary>
            Whether client requires a valid server certificate
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.GarnetTlsOptions.CertificateRevocationCheckMode">
            <summary>
            Certificate revocation mode (shared by client and server)
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.GarnetTlsOptions.ClientTargetHost">
            <summary>
            Target (server) host name used by the client
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.GarnetTlsOptions.IssuerCertificatePath">
            <summary>
            Issuer certificate path
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.#ctor(System.String,System.String,System.Boolean,System.Security.Cryptography.X509Certificates.X509RevocationMode,System.String,System.String,System.Int32,System.Boolean,System.String,System.Boolean,System.Net.Security.SslServerAuthenticationOptions,System.Net.Security.SslClientAuthenticationOptions,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.UpdateCertFile(System.String,System.String,System.String@)">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.ValidateServerCertificateCallback(System.String,System.String)">
            <summary>
            Callback to verify the TLS certificate
            </summary>
            <param name="issuerCertificatePath">The path to issuer certificate file. </param>
            <returns></returns>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.ValidateCertificateName(System.Security.Cryptography.X509Certificates.X509Certificate2,System.String)">
            <summary>
            Validates certificate subject name by looking into DNS name property (preferred), if missing it falls back to
            legacy SimpleName. The input certificate subject should match the expected host name provided in server config.
            </summary>
            <param name="certificate2">The remote certificate to validate.</param>
            <param name="targetHostName">The expected target host name. </param>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.ValidateClientCertificateCallback(System.String)">
            <summary>
            Callback to verify the TLS certificate
            </summary>
            <param name="issuerCertificatePath">The path to issuer certificate file.</param>
            <returns>The RemoteCertificateValidationCallback delegate to invoke.</returns>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.GetCertificateIssuer(System.String)">
            <summary>
            Loads an issuer X.509 certificate using its file name.
            </summary>
            <param name="issuerCertificatePath">The path to issuer certificate file.</param>
        </member>
        <member name="M:Garnet.server.TLS.GarnetTlsOptions.ValidateCertificateIssuer(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Check the chain certificate and determine if the certificate is valid. NOTE: This is prototype code based on
            https://stackoverflow.com/questions/6497040/how-do-i-validate-that-a-certificate-was-created-by-a-particular-certification-a
            Make sure to validate for your requirements before using in production.
            </summary>
            <param name="certificateToValidate">X509Certificate2 certificate to be validated.</param>
            <param name="authority">X509Certificate2 representing the root cert.</param>
            <returns>A boolean indicating whether the certificate has a valid issuer.</returns>
        </member>
        <member name="T:Garnet.server.TLS.IGarnetTlsOptions">
            <summary>
            Interface to provide Garnet TLS options
            </summary>
        </member>
        <member name="P:Garnet.server.TLS.IGarnetTlsOptions.TlsServerOptions">
            <summary>
            TLS server options
            </summary>
        </member>
        <member name="P:Garnet.server.TLS.IGarnetTlsOptions.TlsClientOptions">
            <summary>
            TLS client options, used by cluster clients
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.IGarnetTlsOptions.UpdateCertFile(System.String,System.String,System.String@)">
            <summary>
            Update certificate file
            </summary>
            <param name="certFileName"></param>
            <param name="certPassword"></param>
            <param name="errorMessage">The ASCII error message if the method returned <see langword="false"/>; otherwise <see langword="null"/></param>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.TLS.ServerCertificateSelector">
            <summary>
            Ssl certificate selection to handle certificate refresh
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.certificateRefreshRetryInterval">
            <summary>
            Ssl certificate retry duration in case of failures.
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.sslCertificateSubjectName">
            <summary>
            Ssl certificate subject name.
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.sslCertificateFileName">
            <summary>
            Ssl certificate file name.
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.sslCertificatePassword">
            <summary>
            Ssl certificate file password
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.certRefreshFrequency">
            <summary>
            Ssl certificate retry duration
            </summary>
        </member>
        <member name="F:Garnet.server.TLS.ServerCertificateSelector.sslServerCertificate">
            <summary>
            Ssl server certificate.
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.ServerCertificateSelector.#ctor(System.String,System.Int32,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Garnet.server.TLS.ServerCertificateSelector"/> class.
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.ServerCertificateSelector.#ctor(System.String,System.String,System.Int32,Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Garnet.server.TLS.ServerCertificateSelector"/> class.
            </summary>changed th
        </member>
        <member name="M:Garnet.server.TLS.ServerCertificateSelector.EndTimer">
            <summary>
            End refresh timer
            </summary>
        </member>
        <member name="M:Garnet.server.TLS.ServerCertificateSelector.GetSslServerCertificate">
            <summary>
            Looks up the server certificate for authenticating an HTTPS connection.
            </summary>
            <returns>The X.509 certificate to use for server authentication.</returns>
        </member>
        <member name="T:Garnet.server.TransactionManager">
            <summary>
            Transaction manager
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.basicContext">
            <summary>
            Basic context for main store
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.lockableContext">
            <summary>
            Lockable context for main store
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.objectStoreBasicContext">
            <summary>
            Basic context for object store
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.objectStoreLockableContext">
            <summary>
            Lockable context for object store
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.state">
            <summary>
            State
            </summary>
        </member>
        <member name="F:Garnet.server.TransactionManager.keyEntries">
            <summary>
            Array to keep pointer keys in keyBuffer
            </summary>
        </member>
        <member name="M:Garnet.server.TransactionManager.SaveKeyArgSlice(Garnet.server.ArgSlice)">
            <summary>
            Keep track of actual key accessed by command
            </summary>
            <param name="argSlice"></param>
        </member>
        <member name="M:Garnet.server.TransactionManager.UpdateRecvBufferPtr(System.Byte*)">
            <summary>
            Update argslice ptr if input buffer has been resized
            </summary>
            <param name="recvBufferPtr"></param>
        </member>
        <member name="M:Garnet.server.TransactionManager.SaveKeyEntryToLock(Garnet.server.ArgSlice,System.Boolean,Tsavorite.core.LockType)">
            <summary>
            Save key entry
            </summary>
            <param name="key"></param>
            <param name="isObject"></param>
            <param name="type"></param>
        </member>
        <member name="M:Garnet.server.TransactionManager.ResetCacheSlotVerificationResult">
            <summary>
            Reset cached slot verification result
            </summary>
        </member>
        <member name="M:Garnet.server.TransactionManager.WriteCachedSlotVerificationMessage(Garnet.common.MemoryResult{System.Byte}@)">
            <summary>
            Reset cached slot verification result
            </summary>
        </member>
        <member name="M:Garnet.server.TransactionManager.VerifyKeyOwnership(Garnet.server.ArgSlice,Tsavorite.core.LockType)">
            <summary>
            Verify key ownership
            </summary>
            <param name="key"></param>
            <param name="type"></param>
        </member>
        <member name="M:Garnet.server.TransactionManager.LockKeys(Garnet.server.SimpleRespCommandInfo)">
            <summary>
            Locks keys according to command's key specifications
            </summary>
            <param name="cmdInfo">Simplified command info</param>
        </member>
        <member name="T:Garnet.server.TxnKeyEntry">
            <summary>
            Entry for a key to lock and unlock in transactions
            </summary>
        </member>
        <member name="P:Garnet.server.TxnKeyEntry.KeyHash">
            <inheritdoc/>
        </member>
        <member name="P:Garnet.server.TxnKeyEntry.LockType">
            <inheritdoc/>
        </member>
        <member name="M:Garnet.server.TxnKeyEntry.ToString">
            <inheritdoc />
        </member>
        <member name="M:Garnet.server.TxnKeyComparison.Compare(Garnet.server.TxnKeyEntry,Garnet.server.TxnKeyEntry)">
            <inheritdoc />
        </member>
        <member name="T:Garnet.server.TxnState">
            <summary>
            Transaction state enum
            </summary>
        </member>
        <member name="F:Garnet.server.TxnState.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Garnet.server.TxnState.Started">
            <summary>
            Started
            </summary>
        </member>
        <member name="F:Garnet.server.TxnState.Running">
            <summary>
            Running
            </summary>
        </member>
        <member name="F:Garnet.server.TxnState.Aborted">
            <summary>
            Aborted
            </summary>
        </member>
        <member name="T:Garnet.server.WatchedKeysContainer">
            <summary>
            A container per session to store information of watched keys
            </summary>
        </member>
        <member name="F:Garnet.server.WatchedKeysContainer.keySlices">
            <summary>
            Array to keep slice of keys inside keyBuffer
            </summary>
        </member>
        <member name="F:Garnet.server.WatchedKeysContainer.versionMap">
            <summary>
            Array to keep slice of keys inside keyBuffer
            </summary>
        </member>
        <member name="M:Garnet.server.WatchedKeysContainer.Reset">
            <summary>
            Reset watched keys
            </summary>
        </member>
        <member name="M:Garnet.server.WatchedKeysContainer.ValidateWatchVersion">
            <summary>
            Validate record version to validate that records are unmodified
            </summary>
            <returns></returns>
        </member>
        <member name="T:Garnet.server.WatchVersionMap">
            <summary>
            Watch Version Map
            An instance per garnet server to store versions of watched keys
            </summary>
        </member>
        <member name="M:Garnet.server.WatchVersionMap.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Garnet.server.WatchVersionMap.ReadVersion(System.Int64)">
            <summary>
            Read a version of a key
            Call before watch
            </summary>
        </member>
        <member name="M:Garnet.server.WatchVersionMap.IncrementVersion(System.Int64)">
            <summary>
            Increment version of a watched key
            Call while modifying a watched key
            </summary>
        </member>
        <member name="T:AssemblyRef">
            <summary>
            Sets public key string for friend assemblies.
            </summary>
        </member>
    </members>
</doc>
